(() => {
  function e(r) {
    var s = n[r];
    if (void 0 !== s) return s.exports;
    var i = (n[r] = { exports: {} });
    return t[r](i, i.exports, e), i.exports;
  }
  var t = {
      462: (e, t, n) => {
        e.exports = (function e(t, n, r) {
          function s(o) {
            if (!n[o]) {
              if (!t[o]) {
                if (i) return i(o, !0);
                var a = new Error("Cannot find module '" + o + "'");
                throw ((a.code = "MODULE_NOT_FOUND"), a);
              }
              var l = (n[o] = { exports: {} });
              t[o][0].call(
                l.exports,
                function (e) {
                  return s(t[o][1][e] || e);
                },
                l,
                l.exports,
                e,
                t,
                n,
                r
              );
            }
            return n[o].exports;
          }
          for (var i = void 0, o = 0; o < r.length; o++) s(r[o]);
          return s;
        })(
          {
            1: [
              function (e, t, n) {
                "use strict";
                var r = e("./utils"),
                  s = e("./support"),
                  i =
                    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                (n.encode = function (e) {
                  for (
                    var t,
                      n,
                      s,
                      o,
                      a,
                      l,
                      c,
                      u = [],
                      A = 0,
                      d = e.length,
                      h = d,
                      p = "string" !== r.getTypeOf(e);
                    A < e.length;

                  )
                    (h = d - A),
                      p
                        ? ((t = e[A++]),
                          (n = A < d ? e[A++] : 0),
                          (s = A < d ? e[A++] : 0))
                        : ((t = e.charCodeAt(A++)),
                          (n = A < d ? e.charCodeAt(A++) : 0),
                          (s = A < d ? e.charCodeAt(A++) : 0)),
                      (o = t >> 2),
                      (a = ((3 & t) << 4) | (n >> 4)),
                      (l = h > 1 ? ((15 & n) << 2) | (s >> 6) : 64),
                      (c = h > 2 ? 63 & s : 64),
                      u.push(
                        i.charAt(o) + i.charAt(a) + i.charAt(l) + i.charAt(c)
                      );
                  return u.join("");
                }),
                  (n.decode = function (e) {
                    var t,
                      n,
                      r,
                      o,
                      a,
                      l,
                      c = 0,
                      u = 0;
                    if ("data:" === e.substr(0, 5))
                      throw new Error(
                        "Invalid base64 input, it looks like a data url."
                      );
                    var A,
                      d =
                        (3 *
                          (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length) /
                        4;
                    if (
                      (e.charAt(e.length - 1) === i.charAt(64) && d--,
                      e.charAt(e.length - 2) === i.charAt(64) && d--,
                      d % 1 != 0)
                    )
                      throw new Error(
                        "Invalid base64 input, bad content length."
                      );
                    for (
                      A = s.uint8array
                        ? new Uint8Array(0 | d)
                        : new Array(0 | d);
                      c < e.length;

                    )
                      (t =
                        (i.indexOf(e.charAt(c++)) << 2) |
                        ((o = i.indexOf(e.charAt(c++))) >> 4)),
                        (n =
                          ((15 & o) << 4) |
                          ((a = i.indexOf(e.charAt(c++))) >> 2)),
                        (r = ((3 & a) << 6) | (l = i.indexOf(e.charAt(c++)))),
                        (A[u++] = t),
                        64 !== a && (A[u++] = n),
                        64 !== l && (A[u++] = r);
                    return A;
                  });
              },
              { "./support": 30, "./utils": 32 },
            ],
            2: [
              function (e, t) {
                "use strict";
                function n(e, t, n, r, s) {
                  (this.compressedSize = e),
                    (this.uncompressedSize = t),
                    (this.crc32 = n),
                    (this.compression = r),
                    (this.compressedContent = s);
                }
                var r = e("./external"),
                  s = e("./stream/DataWorker"),
                  i = e("./stream/DataLengthProbe"),
                  o = e("./stream/Crc32Probe");
                (i = e("./stream/DataLengthProbe")),
                  (n.prototype = {
                    getContentWorker: function () {
                      var e = new s(r.Promise.resolve(this.compressedContent))
                          .pipe(this.compression.uncompressWorker())
                          .pipe(new i("data_length")),
                        t = this;
                      return (
                        e.on("end", function () {
                          if (
                            this.streamInfo.data_length !== t.uncompressedSize
                          )
                            throw new Error(
                              "Bug : uncompressed data size mismatch"
                            );
                        }),
                        e
                      );
                    },
                    getCompressedWorker: function () {
                      return new s(r.Promise.resolve(this.compressedContent))
                        .withStreamInfo("compressedSize", this.compressedSize)
                        .withStreamInfo(
                          "uncompressedSize",
                          this.uncompressedSize
                        )
                        .withStreamInfo("crc32", this.crc32)
                        .withStreamInfo("compression", this.compression);
                    },
                  }),
                  (n.createWorkerFrom = function (e, t, n) {
                    return e
                      .pipe(new o())
                      .pipe(new i("uncompressedSize"))
                      .pipe(t.compressWorker(n))
                      .pipe(new i("compressedSize"))
                      .withStreamInfo("compression", t);
                  }),
                  (t.exports = n);
              },
              {
                "./external": 6,
                "./stream/Crc32Probe": 25,
                "./stream/DataLengthProbe": 26,
                "./stream/DataWorker": 27,
              },
            ],
            3: [
              function (e, t, n) {
                "use strict";
                var r = e("./stream/GenericWorker");
                (n.STORE = {
                  magic: "\0\0",
                  compressWorker: function () {
                    return new r("STORE compression");
                  },
                  uncompressWorker: function () {
                    return new r("STORE decompression");
                  },
                }),
                  (n.DEFLATE = e("./flate"));
              },
              { "./flate": 7, "./stream/GenericWorker": 28 },
            ],
            4: [
              function (e, t) {
                "use strict";
                var n = e("./utils"),
                  r = (function () {
                    for (var e, t = [], n = 0; n < 256; n++) {
                      e = n;
                      for (var r = 0; r < 8; r++)
                        e = 1 & e ? 3988292384 ^ (e >>> 1) : e >>> 1;
                      t[n] = e;
                    }
                    return t;
                  })();
                t.exports = function (e, t) {
                  return void 0 !== e && e.length
                    ? "string" !== n.getTypeOf(e)
                      ? (function (e, t, n) {
                          var s = r,
                            i = 0 + n;
                          e ^= -1;
                          for (var o = 0; o < i; o++)
                            e = (e >>> 8) ^ s[255 & (e ^ t[o])];
                          return -1 ^ e;
                        })(0 | t, e, e.length)
                      : (function (e, t, n) {
                          var s = r,
                            i = 0 + n;
                          e ^= -1;
                          for (var o = 0; o < i; o++)
                            e = (e >>> 8) ^ s[255 & (e ^ t.charCodeAt(o))];
                          return -1 ^ e;
                        })(0 | t, e, e.length)
                    : 0;
                };
              },
              { "./utils": 32 },
            ],
            5: [
              function (e, t, n) {
                "use strict";
                (n.base64 = !1),
                  (n.binary = !1),
                  (n.dir = !1),
                  (n.createFolders = !0),
                  (n.date = null),
                  (n.compression = null),
                  (n.compressionOptions = null),
                  (n.comment = null),
                  (n.unixPermissions = null),
                  (n.dosPermissions = null);
              },
              {},
            ],
            6: [
              function (e, t) {
                "use strict";
                var n;
                (n = "undefined" != typeof Promise ? Promise : e("lie")),
                  (t.exports = { Promise: n });
              },
              { lie: 37 },
            ],
            7: [
              function (e, t, n) {
                "use strict";
                function r(e, t) {
                  a.call(this, "FlateWorker/" + e),
                    (this._pako = null),
                    (this._pakoAction = e),
                    (this._pakoOptions = t),
                    (this.meta = {});
                }
                var s =
                    "undefined" != typeof Uint8Array &&
                    "undefined" != typeof Uint16Array &&
                    "undefined" != typeof Uint32Array,
                  i = e("pako"),
                  o = e("./utils"),
                  a = e("./stream/GenericWorker"),
                  l = s ? "uint8array" : "array";
                (n.magic = "\b\0"),
                  o.inherits(r, a),
                  (r.prototype.processChunk = function (e) {
                    (this.meta = e.meta),
                      null === this._pako && this._createPako(),
                      this._pako.push(o.transformTo(l, e.data), !1);
                  }),
                  (r.prototype.flush = function () {
                    a.prototype.flush.call(this),
                      null === this._pako && this._createPako(),
                      this._pako.push([], !0);
                  }),
                  (r.prototype.cleanUp = function () {
                    a.prototype.cleanUp.call(this), (this._pako = null);
                  }),
                  (r.prototype._createPako = function () {
                    this._pako = new i[this._pakoAction]({
                      raw: !0,
                      level: this._pakoOptions.level || -1,
                    });
                    var e = this;
                    this._pako.onData = function (t) {
                      e.push({ data: t, meta: e.meta });
                    };
                  }),
                  (n.compressWorker = function (e) {
                    return new r("Deflate", e);
                  }),
                  (n.uncompressWorker = function () {
                    return new r("Inflate", {});
                  });
              },
              { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 },
            ],
            8: [
              function (e, t) {
                "use strict";
                function n(e, t, n, r) {
                  s.call(this, "ZipFileWorker"),
                    (this.bytesWritten = 0),
                    (this.zipComment = t),
                    (this.zipPlatform = n),
                    (this.encodeFileName = r),
                    (this.streamFiles = e),
                    (this.accumulate = !1),
                    (this.contentBuffer = []),
                    (this.dirRecords = []),
                    (this.currentSourceOffset = 0),
                    (this.entriesCount = 0),
                    (this.currentFile = null),
                    (this._sources = []);
                }
                var r = e("../utils"),
                  s = e("../stream/GenericWorker"),
                  i = e("../utf8"),
                  o = e("../crc32"),
                  a = e("../signature"),
                  l = function (e, t) {
                    var n,
                      r = "";
                    for (n = 0; n < t; n++)
                      (r += String.fromCharCode(255 & e)), (e >>>= 8);
                    return r;
                  },
                  c = function (e, t, n, s, c, u) {
                    var A,
                      d,
                      h = e.file,
                      p = e.compression,
                      f = u !== i.utf8encode,
                      m = r.transformTo("string", u(h.name)),
                      g = r.transformTo("string", i.utf8encode(h.name)),
                      v = h.comment,
                      _ = r.transformTo("string", u(v)),
                      w = r.transformTo("string", i.utf8encode(v)),
                      b = g.length !== h.name.length,
                      y = w.length !== v.length,
                      k = "",
                      R = "",
                      x = "",
                      E = h.dir,
                      S = h.date,
                      C = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
                    (t && !n) ||
                      ((C.crc32 = e.crc32),
                      (C.compressedSize = e.compressedSize),
                      (C.uncompressedSize = e.uncompressedSize));
                    var M = 0;
                    t && (M |= 8), f || (!b && !y) || (M |= 2048);
                    var I,
                      G,
                      U = 0,
                      Z = 0;
                    E && (U |= 16),
                      "UNIX" === c
                        ? ((Z = 798),
                          (U |=
                            ((G = I = h.unixPermissions),
                            I || (G = E ? 16893 : 33204),
                            (65535 & G) << 16)))
                        : ((Z = 20), (U |= 63 & (h.dosPermissions || 0))),
                      (A = S.getUTCHours()),
                      (A <<= 6),
                      (A |= S.getUTCMinutes()),
                      (A <<= 5),
                      (A |= S.getUTCSeconds() / 2),
                      (d = S.getUTCFullYear() - 1980),
                      (d <<= 4),
                      (d |= S.getUTCMonth() + 1),
                      (d <<= 5),
                      (d |= S.getUTCDate()),
                      b &&
                        ((R = l(1, 1) + l(o(m), 4) + g),
                        (k += "up" + l(R.length, 2) + R)),
                      y &&
                        ((x = l(1, 1) + l(o(_), 4) + w),
                        (k += "uc" + l(x.length, 2) + x));
                    var T = "";
                    return (
                      (T += "\n\0"),
                      (T += l(M, 2)),
                      (T += p.magic),
                      (T += l(A, 2)),
                      (T += l(d, 2)),
                      (T += l(C.crc32, 4)),
                      (T += l(C.compressedSize, 4)),
                      (T += l(C.uncompressedSize, 4)),
                      (T += l(m.length, 2)),
                      (T += l(k.length, 2)),
                      {
                        fileRecord: a.LOCAL_FILE_HEADER + T + m + k,
                        dirRecord:
                          a.CENTRAL_FILE_HEADER +
                          l(Z, 2) +
                          T +
                          l(_.length, 2) +
                          "\0\0\0\0" +
                          l(U, 4) +
                          l(s, 4) +
                          m +
                          k +
                          _,
                      }
                    );
                  },
                  u = function (e) {
                    return (
                      a.DATA_DESCRIPTOR +
                      l(e.crc32, 4) +
                      l(e.compressedSize, 4) +
                      l(e.uncompressedSize, 4)
                    );
                  };
                r.inherits(n, s),
                  (n.prototype.push = function (e) {
                    var t = e.meta.percent || 0,
                      n = this.entriesCount,
                      r = this._sources.length;
                    this.accumulate
                      ? this.contentBuffer.push(e)
                      : ((this.bytesWritten += e.data.length),
                        s.prototype.push.call(this, {
                          data: e.data,
                          meta: {
                            currentFile: this.currentFile,
                            percent: n ? (t + 100 * (n - r - 1)) / n : 100,
                          },
                        }));
                  }),
                  (n.prototype.openedSource = function (e) {
                    (this.currentSourceOffset = this.bytesWritten),
                      (this.currentFile = e.file.name);
                    var t = this.streamFiles && !e.file.dir;
                    if (t) {
                      var n = c(
                        e,
                        t,
                        !1,
                        this.currentSourceOffset,
                        this.zipPlatform,
                        this.encodeFileName
                      );
                      this.push({ data: n.fileRecord, meta: { percent: 0 } });
                    } else this.accumulate = !0;
                  }),
                  (n.prototype.closedSource = function (e) {
                    this.accumulate = !1;
                    var t = this.streamFiles && !e.file.dir,
                      n = c(
                        e,
                        t,
                        !0,
                        this.currentSourceOffset,
                        this.zipPlatform,
                        this.encodeFileName
                      );
                    if ((this.dirRecords.push(n.dirRecord), t))
                      this.push({ data: u(e), meta: { percent: 100 } });
                    else
                      for (
                        this.push({ data: n.fileRecord, meta: { percent: 0 } });
                        this.contentBuffer.length;

                      )
                        this.push(this.contentBuffer.shift());
                    this.currentFile = null;
                  }),
                  (n.prototype.flush = function () {
                    for (
                      var e = this.bytesWritten, t = 0;
                      t < this.dirRecords.length;
                      t++
                    )
                      this.push({
                        data: this.dirRecords[t],
                        meta: { percent: 100 },
                      });
                    var n = this.bytesWritten - e,
                      s = (function (e, t, n, s, i) {
                        var o = r.transformTo("string", i(s));
                        return (
                          a.CENTRAL_DIRECTORY_END +
                          "\0\0\0\0" +
                          l(e, 2) +
                          l(e, 2) +
                          l(t, 4) +
                          l(n, 4) +
                          l(o.length, 2) +
                          o
                        );
                      })(
                        this.dirRecords.length,
                        n,
                        e,
                        this.zipComment,
                        this.encodeFileName
                      );
                    this.push({ data: s, meta: { percent: 100 } });
                  }),
                  (n.prototype.prepareNextSource = function () {
                    (this.previous = this._sources.shift()),
                      this.openedSource(this.previous.streamInfo),
                      this.isPaused
                        ? this.previous.pause()
                        : this.previous.resume();
                  }),
                  (n.prototype.registerPrevious = function (e) {
                    this._sources.push(e);
                    var t = this;
                    return (
                      e.on("data", function (e) {
                        t.processChunk(e);
                      }),
                      e.on("end", function () {
                        t.closedSource(t.previous.streamInfo),
                          t._sources.length ? t.prepareNextSource() : t.end();
                      }),
                      e.on("error", function (e) {
                        t.error(e);
                      }),
                      this
                    );
                  }),
                  (n.prototype.resume = function () {
                    return (
                      !!s.prototype.resume.call(this) &&
                      (!this.previous && this._sources.length
                        ? (this.prepareNextSource(), !0)
                        : this.previous ||
                          this._sources.length ||
                          this.generatedError
                        ? void 0
                        : (this.end(), !0))
                    );
                  }),
                  (n.prototype.error = function (e) {
                    var t = this._sources;
                    if (!s.prototype.error.call(this, e)) return !1;
                    for (var n = 0; n < t.length; n++)
                      try {
                        t[n].error(e);
                      } catch (e) {}
                    return !0;
                  }),
                  (n.prototype.lock = function () {
                    s.prototype.lock.call(this);
                    for (var e = this._sources, t = 0; t < e.length; t++)
                      e[t].lock();
                  }),
                  (t.exports = n);
              },
              {
                "../crc32": 4,
                "../signature": 23,
                "../stream/GenericWorker": 28,
                "../utf8": 31,
                "../utils": 32,
              },
            ],
            9: [
              function (e, t, n) {
                "use strict";
                var r = e("../compressions"),
                  s = e("./ZipFileWorker");
                n.generateWorker = function (e, t, n) {
                  var i = new s(t.streamFiles, n, t.platform, t.encodeFileName),
                    o = 0;
                  try {
                    e.forEach(function (e, n) {
                      o++;
                      var s = (function (e, t) {
                          var n = e || t,
                            s = r[n];
                          if (!s)
                            throw new Error(
                              n + " is not a valid compression method !"
                            );
                          return s;
                        })(n.options.compression, t.compression),
                        a =
                          n.options.compressionOptions ||
                          t.compressionOptions ||
                          {},
                        l = n.dir,
                        c = n.date;
                      n._compressWorker(s, a)
                        .withStreamInfo("file", {
                          name: e,
                          dir: l,
                          date: c,
                          comment: n.comment || "",
                          unixPermissions: n.unixPermissions,
                          dosPermissions: n.dosPermissions,
                        })
                        .pipe(i);
                    }),
                      (i.entriesCount = o);
                  } catch (e) {
                    i.error(e);
                  }
                  return i;
                };
              },
              { "../compressions": 3, "./ZipFileWorker": 8 },
            ],
            10: [
              function (e, t) {
                "use strict";
                function n() {
                  if (!(this instanceof n)) return new n();
                  if (arguments.length)
                    throw new Error(
                      "The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide."
                    );
                  (this.files = {}),
                    (this.comment = null),
                    (this.root = ""),
                    (this.clone = function () {
                      var e = new n();
                      for (var t in this)
                        "function" != typeof this[t] && (e[t] = this[t]);
                      return e;
                    });
                }
                (n.prototype = e("./object")),
                  (n.prototype.loadAsync = e("./load")),
                  (n.support = e("./support")),
                  (n.defaults = e("./defaults")),
                  (n.version = "3.5.0"),
                  (n.loadAsync = function (e, t) {
                    return new n().loadAsync(e, t);
                  }),
                  (n.external = e("./external")),
                  (t.exports = n);
              },
              {
                "./defaults": 5,
                "./external": 6,
                "./load": 11,
                "./object": 15,
                "./support": 30,
              },
            ],
            11: [
              function (e, t) {
                "use strict";
                function n(e) {
                  return new s.Promise(function (t, n) {
                    var r = e.decompressed.getContentWorker().pipe(new a());
                    r.on("error", function (e) {
                      n(e);
                    })
                      .on("end", function () {
                        r.streamInfo.crc32 !== e.decompressed.crc32
                          ? n(new Error("Corrupted zip : CRC32 mismatch"))
                          : t();
                      })
                      .resume();
                  });
                }
                var r = e("./utils"),
                  s = e("./external"),
                  i = e("./utf8"),
                  o = ((r = e("./utils")), e("./zipEntries")),
                  a = e("./stream/Crc32Probe"),
                  l = e("./nodejsUtils");
                t.exports = function (e, t) {
                  var a = this;
                  return (
                    (t = r.extend(t || {}, {
                      base64: !1,
                      checkCRC32: !1,
                      optimizedBinaryString: !1,
                      createFolders: !1,
                      decodeFileName: i.utf8decode,
                    })),
                    l.isNode && l.isStream(e)
                      ? s.Promise.reject(
                          new Error(
                            "JSZip can't accept a stream when loading a zip file."
                          )
                        )
                      : r
                          .prepareContent(
                            "the loaded zip file",
                            e,
                            !0,
                            t.optimizedBinaryString,
                            t.base64
                          )
                          .then(function (e) {
                            var n = new o(t);
                            return n.load(e), n;
                          })
                          .then(function (e) {
                            var r = [s.Promise.resolve(e)],
                              i = e.files;
                            if (t.checkCRC32)
                              for (var o = 0; o < i.length; o++)
                                r.push(n(i[o]));
                            return s.Promise.all(r);
                          })
                          .then(function (e) {
                            for (
                              var n = e.shift(), r = n.files, s = 0;
                              s < r.length;
                              s++
                            ) {
                              var i = r[s];
                              a.file(i.fileNameStr, i.decompressed, {
                                binary: !0,
                                optimizedBinaryString: !0,
                                date: i.date,
                                dir: i.dir,
                                comment: i.fileCommentStr.length
                                  ? i.fileCommentStr
                                  : null,
                                unixPermissions: i.unixPermissions,
                                dosPermissions: i.dosPermissions,
                                createFolders: t.createFolders,
                              });
                            }
                            return (
                              n.zipComment.length && (a.comment = n.zipComment),
                              a
                            );
                          })
                  );
                };
              },
              {
                "./external": 6,
                "./nodejsUtils": 14,
                "./stream/Crc32Probe": 25,
                "./utf8": 31,
                "./utils": 32,
                "./zipEntries": 33,
              },
            ],
            12: [
              function (e, t) {
                "use strict";
                function n(e, t) {
                  s.call(this, "Nodejs stream input adapter for " + e),
                    (this._upstreamEnded = !1),
                    this._bindStream(t);
                }
                var r = e("../utils"),
                  s = e("../stream/GenericWorker");
                r.inherits(n, s),
                  (n.prototype._bindStream = function (e) {
                    var t = this;
                    (this._stream = e),
                      e.pause(),
                      e
                        .on("data", function (e) {
                          t.push({ data: e, meta: { percent: 0 } });
                        })
                        .on("error", function (e) {
                          t.isPaused ? (this.generatedError = e) : t.error(e);
                        })
                        .on("end", function () {
                          t.isPaused ? (t._upstreamEnded = !0) : t.end();
                        });
                  }),
                  (n.prototype.pause = function () {
                    return (
                      !!s.prototype.pause.call(this) &&
                      (this._stream.pause(), !0)
                    );
                  }),
                  (n.prototype.resume = function () {
                    return (
                      !!s.prototype.resume.call(this) &&
                      (this._upstreamEnded ? this.end() : this._stream.resume(),
                      !0)
                    );
                  }),
                  (t.exports = n);
              },
              { "../stream/GenericWorker": 28, "../utils": 32 },
            ],
            13: [
              function (e, t) {
                "use strict";
                function n(e, t, n) {
                  r.call(this, t), (this._helper = e);
                  var s = this;
                  e.on("data", function (e, t) {
                    s.push(e) || s._helper.pause(), n && n(t);
                  })
                    .on("error", function (e) {
                      s.emit("error", e);
                    })
                    .on("end", function () {
                      s.push(null);
                    });
                }
                var r = e("readable-stream").Readable;
                e("../utils").inherits(n, r),
                  (n.prototype._read = function () {
                    this._helper.resume();
                  }),
                  (t.exports = n);
              },
              { "../utils": 32, "readable-stream": 16 },
            ],
            14: [
              function (e, t) {
                "use strict";
                t.exports = {
                  isNode: "undefined" != typeof Buffer,
                  newBufferFrom: function (e, t) {
                    if (Buffer.from && Buffer.from !== Uint8Array.from)
                      return Buffer.from(e, t);
                    if ("number" == typeof e)
                      throw new Error(
                        'The "data" argument must not be a number'
                      );
                    return new Buffer(e, t);
                  },
                  allocBuffer: function (e) {
                    if (Buffer.alloc) return Buffer.alloc(e);
                    var t = new Buffer(e);
                    return t.fill(0), t;
                  },
                  isBuffer: function (e) {
                    return Buffer.isBuffer(e);
                  },
                  isStream: function (e) {
                    return (
                      e &&
                      "function" == typeof e.on &&
                      "function" == typeof e.pause &&
                      "function" == typeof e.resume
                    );
                  },
                };
              },
              {},
            ],
            15: [
              function (e, t) {
                "use strict";
                function n(e) {
                  return "[object RegExp]" === {}.toString.call(e);
                }
                var r = e("./utf8"),
                  s = e("./utils"),
                  i = e("./stream/GenericWorker"),
                  o = e("./stream/StreamHelper"),
                  a = e("./defaults"),
                  l = e("./compressedObject"),
                  c = e("./zipObject"),
                  u = e("./generate"),
                  A = e("./nodejsUtils"),
                  d = e("./nodejs/NodejsStreamInputAdapter"),
                  h = function (e, t, n) {
                    var r,
                      o = s.getTypeOf(t),
                      u = s.extend(n || {}, a);
                    (u.date = u.date || new Date()),
                      null !== u.compression &&
                        (u.compression = u.compression.toUpperCase()),
                      "string" == typeof u.unixPermissions &&
                        (u.unixPermissions = parseInt(u.unixPermissions, 8)),
                      u.unixPermissions &&
                        16384 & u.unixPermissions &&
                        (u.dir = !0),
                      u.dosPermissions && 16 & u.dosPermissions && (u.dir = !0),
                      u.dir && (e = f(e)),
                      u.createFolders && (r = p(e)) && m.call(this, r, !0);
                    var h,
                      g = "string" === o && !1 === u.binary && !1 === u.base64;
                    (n && void 0 !== n.binary) || (u.binary = !g),
                      ((t instanceof l && 0 === t.uncompressedSize) ||
                        u.dir ||
                        !t ||
                        0 === t.length) &&
                        ((u.base64 = !1),
                        (u.binary = !0),
                        (t = ""),
                        (u.compression = "STORE"),
                        (o = "string")),
                      (h =
                        t instanceof l || t instanceof i
                          ? t
                          : A.isNode && A.isStream(t)
                          ? new d(e, t)
                          : s.prepareContent(
                              e,
                              t,
                              u.binary,
                              u.optimizedBinaryString,
                              u.base64
                            ));
                    var v = new c(e, h, u);
                    this.files[e] = v;
                  },
                  p = function (e) {
                    "/" === e.slice(-1) && (e = e.substring(0, e.length - 1));
                    var t = e.lastIndexOf("/");
                    return t > 0 ? e.substring(0, t) : "";
                  },
                  f = function (e) {
                    return "/" !== e.slice(-1) && (e += "/"), e;
                  },
                  m = function (e, t) {
                    return (
                      (t = void 0 !== t ? t : a.createFolders),
                      (e = f(e)),
                      this.files[e] ||
                        h.call(this, e, null, { dir: !0, createFolders: t }),
                      this.files[e]
                    );
                  },
                  g = {
                    load: function () {
                      throw new Error(
                        "This method has been removed in JSZip 3.0, please check the upgrade guide."
                      );
                    },
                    forEach: function (e) {
                      var t, n, r;
                      for (t in this.files)
                        this.files.hasOwnProperty(t) &&
                          ((r = this.files[t]),
                          (n = t.slice(this.root.length, t.length)) &&
                            t.slice(0, this.root.length) === this.root &&
                            e(n, r));
                    },
                    filter: function (e) {
                      var t = [];
                      return (
                        this.forEach(function (n, r) {
                          e(n, r) && t.push(r);
                        }),
                        t
                      );
                    },
                    file: function (e, t, r) {
                      if (1 === arguments.length) {
                        if (n(e)) {
                          var s = e;
                          return this.filter(function (e, t) {
                            return !t.dir && s.test(e);
                          });
                        }
                        var i = this.files[this.root + e];
                        return i && !i.dir ? i : null;
                      }
                      return (e = this.root + e), h.call(this, e, t, r), this;
                    },
                    folder: function (e) {
                      if (!e) return this;
                      if (n(e))
                        return this.filter(function (t, n) {
                          return n.dir && e.test(t);
                        });
                      var t = this.root + e,
                        r = m.call(this, t),
                        s = this.clone();
                      return (s.root = r.name), s;
                    },
                    remove: function (e) {
                      e = this.root + e;
                      var t = this.files[e];
                      if (
                        (t ||
                          ("/" !== e.slice(-1) && (e += "/"),
                          (t = this.files[e])),
                        t && !t.dir)
                      )
                        delete this.files[e];
                      else
                        for (
                          var n = this.filter(function (t, n) {
                              return n.name.slice(0, e.length) === e;
                            }),
                            r = 0;
                          r < n.length;
                          r++
                        )
                          delete this.files[n[r].name];
                      return this;
                    },
                    generate: function () {
                      throw new Error(
                        "This method has been removed in JSZip 3.0, please check the upgrade guide."
                      );
                    },
                    generateInternalStream: function (e) {
                      var t,
                        n = {};
                      try {
                        if (
                          (((n = s.extend(e || {}, {
                            streamFiles: !1,
                            compression: "STORE",
                            compressionOptions: null,
                            type: "",
                            platform: "DOS",
                            comment: null,
                            mimeType: "application/zip",
                            encodeFileName: r.utf8encode,
                          })).type = n.type.toLowerCase()),
                          (n.compression = n.compression.toUpperCase()),
                          "binarystring" === n.type && (n.type = "string"),
                          !n.type)
                        )
                          throw new Error("No output type specified.");
                        s.checkSupport(n.type),
                          ("darwin" !== n.platform &&
                            "freebsd" !== n.platform &&
                            "linux" !== n.platform &&
                            "sunos" !== n.platform) ||
                            (n.platform = "UNIX"),
                          "win32" === n.platform && (n.platform = "DOS");
                        var a = n.comment || this.comment || "";
                        t = u.generateWorker(this, n, a);
                      } catch (e) {
                        (t = new i("error")).error(e);
                      }
                      return new o(t, n.type || "string", n.mimeType);
                    },
                    generateAsync: function (e, t) {
                      return this.generateInternalStream(e).accumulate(t);
                    },
                    generateNodeStream: function (e, t) {
                      return (
                        (e = e || {}).type || (e.type = "nodebuffer"),
                        this.generateInternalStream(e).toNodejsStream(t)
                      );
                    },
                  };
                t.exports = g;
              },
              {
                "./compressedObject": 2,
                "./defaults": 5,
                "./generate": 9,
                "./nodejs/NodejsStreamInputAdapter": 12,
                "./nodejsUtils": 14,
                "./stream/GenericWorker": 28,
                "./stream/StreamHelper": 29,
                "./utf8": 31,
                "./utils": 32,
                "./zipObject": 35,
              },
            ],
            16: [
              function (e, t) {
                t.exports = e("stream");
              },
              { stream: void 0 },
            ],
            17: [
              function (e, t) {
                "use strict";
                function n(e) {
                  r.call(this, e);
                  for (var t = 0; t < this.data.length; t++) e[t] = 255 & e[t];
                }
                var r = e("./DataReader");
                e("../utils").inherits(n, r),
                  (n.prototype.byteAt = function (e) {
                    return this.data[this.zero + e];
                  }),
                  (n.prototype.lastIndexOfSignature = function (e) {
                    for (
                      var t = e.charCodeAt(0),
                        n = e.charCodeAt(1),
                        r = e.charCodeAt(2),
                        s = e.charCodeAt(3),
                        i = this.length - 4;
                      i >= 0;
                      --i
                    )
                      if (
                        this.data[i] === t &&
                        this.data[i + 1] === n &&
                        this.data[i + 2] === r &&
                        this.data[i + 3] === s
                      )
                        return i - this.zero;
                    return -1;
                  }),
                  (n.prototype.readAndCheckSignature = function (e) {
                    var t = e.charCodeAt(0),
                      n = e.charCodeAt(1),
                      r = e.charCodeAt(2),
                      s = e.charCodeAt(3),
                      i = this.readData(4);
                    return t === i[0] && n === i[1] && r === i[2] && s === i[3];
                  }),
                  (n.prototype.readData = function (e) {
                    if ((this.checkOffset(e), 0 === e)) return [];
                    var t = this.data.slice(
                      this.zero + this.index,
                      this.zero + this.index + e
                    );
                    return (this.index += e), t;
                  }),
                  (t.exports = n);
              },
              { "../utils": 32, "./DataReader": 18 },
            ],
            18: [
              function (e, t) {
                "use strict";
                function n(e) {
                  (this.data = e),
                    (this.length = e.length),
                    (this.index = 0),
                    (this.zero = 0);
                }
                var r = e("../utils");
                (n.prototype = {
                  checkOffset: function (e) {
                    this.checkIndex(this.index + e);
                  },
                  checkIndex: function (e) {
                    if (this.length < this.zero + e || e < 0)
                      throw new Error(
                        "End of data reached (data length = " +
                          this.length +
                          ", asked index = " +
                          e +
                          "). Corrupted zip ?"
                      );
                  },
                  setIndex: function (e) {
                    this.checkIndex(e), (this.index = e);
                  },
                  skip: function (e) {
                    this.setIndex(this.index + e);
                  },
                  byteAt: function () {},
                  readInt: function (e) {
                    var t,
                      n = 0;
                    for (
                      this.checkOffset(e), t = this.index + e - 1;
                      t >= this.index;
                      t--
                    )
                      n = (n << 8) + this.byteAt(t);
                    return (this.index += e), n;
                  },
                  readString: function (e) {
                    return r.transformTo("string", this.readData(e));
                  },
                  readData: function () {},
                  lastIndexOfSignature: function () {},
                  readAndCheckSignature: function () {},
                  readDate: function () {
                    var e = this.readInt(4);
                    return new Date(
                      Date.UTC(
                        1980 + ((e >> 25) & 127),
                        ((e >> 21) & 15) - 1,
                        (e >> 16) & 31,
                        (e >> 11) & 31,
                        (e >> 5) & 63,
                        (31 & e) << 1
                      )
                    );
                  },
                }),
                  (t.exports = n);
              },
              { "../utils": 32 },
            ],
            19: [
              function (e, t) {
                "use strict";
                function n(e) {
                  r.call(this, e);
                }
                var r = e("./Uint8ArrayReader");
                e("../utils").inherits(n, r),
                  (n.prototype.readData = function (e) {
                    this.checkOffset(e);
                    var t = this.data.slice(
                      this.zero + this.index,
                      this.zero + this.index + e
                    );
                    return (this.index += e), t;
                  }),
                  (t.exports = n);
              },
              { "../utils": 32, "./Uint8ArrayReader": 21 },
            ],
            20: [
              function (e, t) {
                "use strict";
                function n(e) {
                  r.call(this, e);
                }
                var r = e("./DataReader");
                e("../utils").inherits(n, r),
                  (n.prototype.byteAt = function (e) {
                    return this.data.charCodeAt(this.zero + e);
                  }),
                  (n.prototype.lastIndexOfSignature = function (e) {
                    return this.data.lastIndexOf(e) - this.zero;
                  }),
                  (n.prototype.readAndCheckSignature = function (e) {
                    return e === this.readData(4);
                  }),
                  (n.prototype.readData = function (e) {
                    this.checkOffset(e);
                    var t = this.data.slice(
                      this.zero + this.index,
                      this.zero + this.index + e
                    );
                    return (this.index += e), t;
                  }),
                  (t.exports = n);
              },
              { "../utils": 32, "./DataReader": 18 },
            ],
            21: [
              function (e, t) {
                "use strict";
                function n(e) {
                  r.call(this, e);
                }
                var r = e("./ArrayReader");
                e("../utils").inherits(n, r),
                  (n.prototype.readData = function (e) {
                    if ((this.checkOffset(e), 0 === e))
                      return new Uint8Array(0);
                    var t = this.data.subarray(
                      this.zero + this.index,
                      this.zero + this.index + e
                    );
                    return (this.index += e), t;
                  }),
                  (t.exports = n);
              },
              { "../utils": 32, "./ArrayReader": 17 },
            ],
            22: [
              function (e, t) {
                "use strict";
                var n = e("../utils"),
                  r = e("../support"),
                  s = e("./ArrayReader"),
                  i = e("./StringReader"),
                  o = e("./NodeBufferReader"),
                  a = e("./Uint8ArrayReader");
                t.exports = function (e) {
                  var t = n.getTypeOf(e);
                  return (
                    n.checkSupport(t),
                    "string" !== t || r.uint8array
                      ? "nodebuffer" === t
                        ? new o(e)
                        : r.uint8array
                        ? new a(n.transformTo("uint8array", e))
                        : new s(n.transformTo("array", e))
                      : new i(e)
                  );
                };
              },
              {
                "../support": 30,
                "../utils": 32,
                "./ArrayReader": 17,
                "./NodeBufferReader": 19,
                "./StringReader": 20,
                "./Uint8ArrayReader": 21,
              },
            ],
            23: [
              function (e, t, n) {
                "use strict";
                (n.LOCAL_FILE_HEADER = "PK"),
                  (n.CENTRAL_FILE_HEADER = "PK"),
                  (n.CENTRAL_DIRECTORY_END = "PK"),
                  (n.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK"),
                  (n.ZIP64_CENTRAL_DIRECTORY_END = "PK"),
                  (n.DATA_DESCRIPTOR = "PK\b");
              },
              {},
            ],
            24: [
              function (e, t) {
                "use strict";
                function n(e) {
                  r.call(this, "ConvertWorker to " + e), (this.destType = e);
                }
                var r = e("./GenericWorker"),
                  s = e("../utils");
                s.inherits(n, r),
                  (n.prototype.processChunk = function (e) {
                    this.push({
                      data: s.transformTo(this.destType, e.data),
                      meta: e.meta,
                    });
                  }),
                  (t.exports = n);
              },
              { "../utils": 32, "./GenericWorker": 28 },
            ],
            25: [
              function (e, t) {
                "use strict";
                function n() {
                  r.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
                }
                var r = e("./GenericWorker"),
                  s = e("../crc32");
                e("../utils").inherits(n, r),
                  (n.prototype.processChunk = function (e) {
                    (this.streamInfo.crc32 = s(
                      e.data,
                      this.streamInfo.crc32 || 0
                    )),
                      this.push(e);
                  }),
                  (t.exports = n);
              },
              { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 },
            ],
            26: [
              function (e, t) {
                "use strict";
                function n(e) {
                  s.call(this, "DataLengthProbe for " + e),
                    (this.propName = e),
                    this.withStreamInfo(e, 0);
                }
                var r = e("../utils"),
                  s = e("./GenericWorker");
                r.inherits(n, s),
                  (n.prototype.processChunk = function (e) {
                    if (e) {
                      var t = this.streamInfo[this.propName] || 0;
                      this.streamInfo[this.propName] = t + e.data.length;
                    }
                    s.prototype.processChunk.call(this, e);
                  }),
                  (t.exports = n);
              },
              { "../utils": 32, "./GenericWorker": 28 },
            ],
            27: [
              function (e, t) {
                "use strict";
                function n(e) {
                  s.call(this, "DataWorker");
                  var t = this;
                  (this.dataIsReady = !1),
                    (this.index = 0),
                    (this.max = 0),
                    (this.data = null),
                    (this.type = ""),
                    (this._tickScheduled = !1),
                    e.then(
                      function (e) {
                        (t.dataIsReady = !0),
                          (t.data = e),
                          (t.max = (e && e.length) || 0),
                          (t.type = r.getTypeOf(e)),
                          t.isPaused || t._tickAndRepeat();
                      },
                      function (e) {
                        t.error(e);
                      }
                    );
                }
                var r = e("../utils"),
                  s = e("./GenericWorker");
                r.inherits(n, s),
                  (n.prototype.cleanUp = function () {
                    s.prototype.cleanUp.call(this), (this.data = null);
                  }),
                  (n.prototype.resume = function () {
                    return (
                      !!s.prototype.resume.call(this) &&
                      (!this._tickScheduled &&
                        this.dataIsReady &&
                        ((this._tickScheduled = !0),
                        r.delay(this._tickAndRepeat, [], this)),
                      !0)
                    );
                  }),
                  (n.prototype._tickAndRepeat = function () {
                    (this._tickScheduled = !1),
                      this.isPaused ||
                        this.isFinished ||
                        (this._tick(),
                        this.isFinished ||
                          (r.delay(this._tickAndRepeat, [], this),
                          (this._tickScheduled = !0)));
                  }),
                  (n.prototype._tick = function () {
                    if (this.isPaused || this.isFinished) return !1;
                    var e = null,
                      t = Math.min(this.max, this.index + 16384);
                    if (this.index >= this.max) return this.end();
                    switch (this.type) {
                      case "string":
                        e = this.data.substring(this.index, t);
                        break;
                      case "uint8array":
                        e = this.data.subarray(this.index, t);
                        break;
                      case "array":
                      case "nodebuffer":
                        e = this.data.slice(this.index, t);
                    }
                    return (
                      (this.index = t),
                      this.push({
                        data: e,
                        meta: {
                          percent: this.max ? (this.index / this.max) * 100 : 0,
                        },
                      })
                    );
                  }),
                  (t.exports = n);
              },
              { "../utils": 32, "./GenericWorker": 28 },
            ],
            28: [
              function (e, t) {
                "use strict";
                function n(e) {
                  (this.name = e || "default"),
                    (this.streamInfo = {}),
                    (this.generatedError = null),
                    (this.extraStreamInfo = {}),
                    (this.isPaused = !0),
                    (this.isFinished = !1),
                    (this.isLocked = !1),
                    (this._listeners = { data: [], end: [], error: [] }),
                    (this.previous = null);
                }
                (n.prototype = {
                  push: function (e) {
                    this.emit("data", e);
                  },
                  end: function () {
                    if (this.isFinished) return !1;
                    this.flush();
                    try {
                      this.emit("end"), this.cleanUp(), (this.isFinished = !0);
                    } catch (e) {
                      this.emit("error", e);
                    }
                    return !0;
                  },
                  error: function (e) {
                    return (
                      !this.isFinished &&
                      (this.isPaused
                        ? (this.generatedError = e)
                        : ((this.isFinished = !0),
                          this.emit("error", e),
                          this.previous && this.previous.error(e),
                          this.cleanUp()),
                      !0)
                    );
                  },
                  on: function (e, t) {
                    return this._listeners[e].push(t), this;
                  },
                  cleanUp: function () {
                    (this.streamInfo =
                      this.generatedError =
                      this.extraStreamInfo =
                        null),
                      (this._listeners = []);
                  },
                  emit: function (e, t) {
                    if (this._listeners[e])
                      for (var n = 0; n < this._listeners[e].length; n++)
                        this._listeners[e][n].call(this, t);
                  },
                  pipe: function (e) {
                    return e.registerPrevious(this);
                  },
                  registerPrevious: function (e) {
                    if (this.isLocked)
                      throw new Error(
                        "The stream '" + this + "' has already been used."
                      );
                    (this.streamInfo = e.streamInfo),
                      this.mergeStreamInfo(),
                      (this.previous = e);
                    var t = this;
                    return (
                      e.on("data", function (e) {
                        t.processChunk(e);
                      }),
                      e.on("end", function () {
                        t.end();
                      }),
                      e.on("error", function (e) {
                        t.error(e);
                      }),
                      this
                    );
                  },
                  pause: function () {
                    return (
                      !this.isPaused &&
                      !this.isFinished &&
                      ((this.isPaused = !0),
                      this.previous && this.previous.pause(),
                      !0)
                    );
                  },
                  resume: function () {
                    if (!this.isPaused || this.isFinished) return !1;
                    this.isPaused = !1;
                    var e = !1;
                    return (
                      this.generatedError &&
                        (this.error(this.generatedError), (e = !0)),
                      this.previous && this.previous.resume(),
                      !e
                    );
                  },
                  flush: function () {},
                  processChunk: function (e) {
                    this.push(e);
                  },
                  withStreamInfo: function (e, t) {
                    return (
                      (this.extraStreamInfo[e] = t),
                      this.mergeStreamInfo(),
                      this
                    );
                  },
                  mergeStreamInfo: function () {
                    for (var e in this.extraStreamInfo)
                      this.extraStreamInfo.hasOwnProperty(e) &&
                        (this.streamInfo[e] = this.extraStreamInfo[e]);
                  },
                  lock: function () {
                    if (this.isLocked)
                      throw new Error(
                        "The stream '" + this + "' has already been used."
                      );
                    (this.isLocked = !0), this.previous && this.previous.lock();
                  },
                  toString: function () {
                    var e = "Worker " + this.name;
                    return this.previous ? this.previous + " -> " + e : e;
                  },
                }),
                  (t.exports = n);
              },
              {},
            ],
            29: [
              function (e, t) {
                "use strict";
                function n(e, t, n) {
                  var o = t;
                  switch (t) {
                    case "blob":
                    case "arraybuffer":
                      o = "uint8array";
                      break;
                    case "base64":
                      o = "string";
                  }
                  try {
                    (this._internalType = o),
                      (this._outputType = t),
                      (this._mimeType = n),
                      r.checkSupport(o),
                      (this._worker = e.pipe(new s(o))),
                      e.lock();
                  } catch (e) {
                    (this._worker = new i("error")), this._worker.error(e);
                  }
                }
                var r = e("../utils"),
                  s = e("./ConvertWorker"),
                  i = e("./GenericWorker"),
                  o = e("../base64"),
                  a = e("../support"),
                  l = e("../external"),
                  c = null;
                if (a.nodestream)
                  try {
                    c = e("../nodejs/NodejsStreamOutputAdapter");
                  } catch (e) {}
                (n.prototype = {
                  accumulate: function (e) {
                    return (
                      (t = this),
                      (n = e),
                      new l.Promise(function (e, s) {
                        var i = [],
                          a = t._internalType,
                          l = t._outputType,
                          c = t._mimeType;
                        t.on("data", function (e, t) {
                          i.push(e), n && n(t);
                        })
                          .on("error", function (e) {
                            (i = []), s(e);
                          })
                          .on("end", function () {
                            try {
                              var t = (function (e, t, n) {
                                switch (e) {
                                  case "blob":
                                    return r.newBlob(
                                      r.transformTo("arraybuffer", t),
                                      n
                                    );
                                  case "base64":
                                    return o.encode(t);
                                  default:
                                    return r.transformTo(e, t);
                                }
                              })(
                                l,
                                (function (e, t) {
                                  var n,
                                    r = 0,
                                    s = null,
                                    i = 0;
                                  for (n = 0; n < t.length; n++)
                                    i += t[n].length;
                                  switch (e) {
                                    case "string":
                                      return t.join("");
                                    case "array":
                                      return [].concat.apply([], t);
                                    case "uint8array":
                                      for (
                                        s = new Uint8Array(i), n = 0;
                                        n < t.length;
                                        n++
                                      )
                                        s.set(t[n], r), (r += t[n].length);
                                      return s;
                                    case "nodebuffer":
                                      return Buffer.concat(t);
                                    default:
                                      throw new Error(
                                        "concat : unsupported type '" + e + "'"
                                      );
                                  }
                                })(a, i),
                                c
                              );
                              e(t);
                            } catch (e) {
                              s(e);
                            }
                            i = [];
                          })
                          .resume();
                      })
                    );
                    var t, n;
                  },
                  on: function (e, t) {
                    var n = this;
                    return (
                      "data" === e
                        ? this._worker.on(e, function (e) {
                            t.call(n, e.data, e.meta);
                          })
                        : this._worker.on(e, function () {
                            r.delay(t, arguments, n);
                          }),
                      this
                    );
                  },
                  resume: function () {
                    return r.delay(this._worker.resume, [], this._worker), this;
                  },
                  pause: function () {
                    return this._worker.pause(), this;
                  },
                  toNodejsStream: function (e) {
                    if (
                      (r.checkSupport("nodestream"),
                      "nodebuffer" !== this._outputType)
                    )
                      throw new Error(
                        this._outputType + " is not supported by this method"
                      );
                    return new c(
                      this,
                      { objectMode: "nodebuffer" !== this._outputType },
                      e
                    );
                  },
                }),
                  (t.exports = n);
              },
              {
                "../base64": 1,
                "../external": 6,
                "../nodejs/NodejsStreamOutputAdapter": 13,
                "../support": 30,
                "../utils": 32,
                "./ConvertWorker": 24,
                "./GenericWorker": 28,
              },
            ],
            30: [
              function (e, t, n) {
                "use strict";
                if (
                  ((n.base64 = !0),
                  (n.array = !0),
                  (n.string = !0),
                  (n.arraybuffer =
                    "undefined" != typeof ArrayBuffer &&
                    "undefined" != typeof Uint8Array),
                  (n.nodebuffer = "undefined" != typeof Buffer),
                  (n.uint8array = "undefined" != typeof Uint8Array),
                  "undefined" == typeof ArrayBuffer)
                )
                  n.blob = !1;
                else {
                  var r = new ArrayBuffer(0);
                  try {
                    n.blob =
                      0 === new Blob([r], { type: "application/zip" }).size;
                  } catch (e) {
                    try {
                      var s = new (self.BlobBuilder ||
                        self.WebKitBlobBuilder ||
                        self.MozBlobBuilder ||
                        self.MSBlobBuilder)();
                      s.append(r),
                        (n.blob = 0 === s.getBlob("application/zip").size);
                    } catch (e) {
                      n.blob = !1;
                    }
                  }
                }
                try {
                  n.nodestream = !!e("readable-stream").Readable;
                } catch (e) {
                  n.nodestream = !1;
                }
              },
              { "readable-stream": 16 },
            ],
            31: [
              function (e, t, n) {
                "use strict";
                function r() {
                  l.call(this, "utf-8 decode"), (this.leftOver = null);
                }
                function s() {
                  l.call(this, "utf-8 encode");
                }
                for (
                  var i = e("./utils"),
                    o = e("./support"),
                    a = e("./nodejsUtils"),
                    l = e("./stream/GenericWorker"),
                    c = new Array(256),
                    u = 0;
                  u < 256;
                  u++
                )
                  c[u] =
                    u >= 252
                      ? 6
                      : u >= 248
                      ? 5
                      : u >= 240
                      ? 4
                      : u >= 224
                      ? 3
                      : u >= 192
                      ? 2
                      : 1;
                (c[254] = c[254] = 1),
                  (n.utf8encode = function (e) {
                    return o.nodebuffer
                      ? a.newBufferFrom(e, "utf-8")
                      : (function (e) {
                          var t,
                            n,
                            r,
                            s,
                            i,
                            a = e.length,
                            l = 0;
                          for (s = 0; s < a; s++)
                            55296 == (64512 & (n = e.charCodeAt(s))) &&
                              s + 1 < a &&
                              56320 == (64512 & (r = e.charCodeAt(s + 1))) &&
                              ((n = 65536 + ((n - 55296) << 10) + (r - 56320)),
                              s++),
                              (l +=
                                n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4);
                          for (
                            t = o.uint8array ? new Uint8Array(l) : new Array(l),
                              i = 0,
                              s = 0;
                            i < l;
                            s++
                          )
                            55296 == (64512 & (n = e.charCodeAt(s))) &&
                              s + 1 < a &&
                              56320 == (64512 & (r = e.charCodeAt(s + 1))) &&
                              ((n = 65536 + ((n - 55296) << 10) + (r - 56320)),
                              s++),
                              n < 128
                                ? (t[i++] = n)
                                : n < 2048
                                ? ((t[i++] = 192 | (n >>> 6)),
                                  (t[i++] = 128 | (63 & n)))
                                : n < 65536
                                ? ((t[i++] = 224 | (n >>> 12)),
                                  (t[i++] = 128 | ((n >>> 6) & 63)),
                                  (t[i++] = 128 | (63 & n)))
                                : ((t[i++] = 240 | (n >>> 18)),
                                  (t[i++] = 128 | ((n >>> 12) & 63)),
                                  (t[i++] = 128 | ((n >>> 6) & 63)),
                                  (t[i++] = 128 | (63 & n)));
                          return t;
                        })(e);
                  }),
                  (n.utf8decode = function (e) {
                    return o.nodebuffer
                      ? i.transformTo("nodebuffer", e).toString("utf-8")
                      : (function (e) {
                          var t,
                            n,
                            r,
                            s,
                            o = e.length,
                            a = new Array(2 * o);
                          for (n = 0, t = 0; t < o; )
                            if ((r = e[t++]) < 128) a[n++] = r;
                            else if ((s = c[r]) > 4)
                              (a[n++] = 65533), (t += s - 1);
                            else {
                              for (
                                r &= 2 === s ? 31 : 3 === s ? 15 : 7;
                                s > 1 && t < o;

                              )
                                (r = (r << 6) | (63 & e[t++])), s--;
                              s > 1
                                ? (a[n++] = 65533)
                                : r < 65536
                                ? (a[n++] = r)
                                : ((r -= 65536),
                                  (a[n++] = 55296 | ((r >> 10) & 1023)),
                                  (a[n++] = 56320 | (1023 & r)));
                            }
                          return (
                            a.length !== n &&
                              (a.subarray
                                ? (a = a.subarray(0, n))
                                : (a.length = n)),
                            i.applyFromCharCode(a)
                          );
                        })(
                          (e = i.transformTo(
                            o.uint8array ? "uint8array" : "array",
                            e
                          ))
                        );
                  }),
                  i.inherits(r, l),
                  (r.prototype.processChunk = function (e) {
                    var t = i.transformTo(
                      o.uint8array ? "uint8array" : "array",
                      e.data
                    );
                    if (this.leftOver && this.leftOver.length) {
                      if (o.uint8array) {
                        var r = t;
                        (t = new Uint8Array(
                          r.length + this.leftOver.length
                        )).set(this.leftOver, 0),
                          t.set(r, this.leftOver.length);
                      } else t = this.leftOver.concat(t);
                      this.leftOver = null;
                    }
                    var s = (function (e, t) {
                        var n;
                        for (
                          (t = t || e.length) > e.length && (t = e.length),
                            n = t - 1;
                          n >= 0 && 128 == (192 & e[n]);

                        )
                          n--;
                        return n < 0 || 0 === n ? t : n + c[e[n]] > t ? n : t;
                      })(t),
                      a = t;
                    s !== t.length &&
                      (o.uint8array
                        ? ((a = t.subarray(0, s)),
                          (this.leftOver = t.subarray(s, t.length)))
                        : ((a = t.slice(0, s)),
                          (this.leftOver = t.slice(s, t.length)))),
                      this.push({ data: n.utf8decode(a), meta: e.meta });
                  }),
                  (r.prototype.flush = function () {
                    this.leftOver &&
                      this.leftOver.length &&
                      (this.push({
                        data: n.utf8decode(this.leftOver),
                        meta: {},
                      }),
                      (this.leftOver = null));
                  }),
                  (n.Utf8DecodeWorker = r),
                  i.inherits(s, l),
                  (s.prototype.processChunk = function (e) {
                    this.push({ data: n.utf8encode(e.data), meta: e.meta });
                  }),
                  (n.Utf8EncodeWorker = s);
              },
              {
                "./nodejsUtils": 14,
                "./stream/GenericWorker": 28,
                "./support": 30,
                "./utils": 32,
              },
            ],
            32: [
              function (e, t, n) {
                "use strict";
                function r(e) {
                  return e;
                }
                function s(e, t) {
                  for (var n = 0; n < e.length; ++n)
                    t[n] = 255 & e.charCodeAt(n);
                  return t;
                }
                function i(e) {
                  var t = 65536,
                    r = n.getTypeOf(e),
                    s = !0;
                  if (
                    ("uint8array" === r
                      ? (s = d.applyCanBeUsed.uint8array)
                      : "nodebuffer" === r && (s = d.applyCanBeUsed.nodebuffer),
                    s)
                  )
                    for (; t > 1; )
                      try {
                        return d.stringifyByChunk(e, r, t);
                      } catch (e) {
                        t = Math.floor(t / 2);
                      }
                  return d.stringifyByChar(e);
                }
                function o(e, t) {
                  for (var n = 0; n < e.length; n++) t[n] = e[n];
                  return t;
                }
                var a = e("./support"),
                  l = e("./base64"),
                  c = e("./nodejsUtils"),
                  u = e("set-immediate-shim"),
                  A = e("./external");
                n.newBlob = function (e, t) {
                  n.checkSupport("blob");
                  try {
                    return new Blob([e], { type: t });
                  } catch (n) {
                    try {
                      var r = new (self.BlobBuilder ||
                        self.WebKitBlobBuilder ||
                        self.MozBlobBuilder ||
                        self.MSBlobBuilder)();
                      return r.append(e), r.getBlob(t);
                    } catch (e) {
                      throw new Error("Bug : can't construct the Blob.");
                    }
                  }
                };
                var d = {
                  stringifyByChunk: function (e, t, n) {
                    var r = [],
                      s = 0,
                      i = e.length;
                    if (i <= n) return String.fromCharCode.apply(null, e);
                    for (; s < i; )
                      "array" === t || "nodebuffer" === t
                        ? r.push(
                            String.fromCharCode.apply(
                              null,
                              e.slice(s, Math.min(s + n, i))
                            )
                          )
                        : r.push(
                            String.fromCharCode.apply(
                              null,
                              e.subarray(s, Math.min(s + n, i))
                            )
                          ),
                        (s += n);
                    return r.join("");
                  },
                  stringifyByChar: function (e) {
                    for (var t = "", n = 0; n < e.length; n++)
                      t += String.fromCharCode(e[n]);
                    return t;
                  },
                  applyCanBeUsed: {
                    uint8array: (function () {
                      try {
                        return (
                          a.uint8array &&
                          1 ===
                            String.fromCharCode.apply(null, new Uint8Array(1))
                              .length
                        );
                      } catch (e) {
                        return !1;
                      }
                    })(),
                    nodebuffer: (function () {
                      try {
                        return (
                          a.nodebuffer &&
                          1 ===
                            String.fromCharCode.apply(null, c.allocBuffer(1))
                              .length
                        );
                      } catch (e) {
                        return !1;
                      }
                    })(),
                  },
                };
                n.applyFromCharCode = i;
                var h = {};
                (h.string = {
                  string: r,
                  array: function (e) {
                    return s(e, new Array(e.length));
                  },
                  arraybuffer: function (e) {
                    return h.string.uint8array(e).buffer;
                  },
                  uint8array: function (e) {
                    return s(e, new Uint8Array(e.length));
                  },
                  nodebuffer: function (e) {
                    return s(e, c.allocBuffer(e.length));
                  },
                }),
                  (h.array = {
                    string: i,
                    array: r,
                    arraybuffer: function (e) {
                      return new Uint8Array(e).buffer;
                    },
                    uint8array: function (e) {
                      return new Uint8Array(e);
                    },
                    nodebuffer: function (e) {
                      return c.newBufferFrom(e);
                    },
                  }),
                  (h.arraybuffer = {
                    string: function (e) {
                      return i(new Uint8Array(e));
                    },
                    array: function (e) {
                      return o(new Uint8Array(e), new Array(e.byteLength));
                    },
                    arraybuffer: r,
                    uint8array: function (e) {
                      return new Uint8Array(e);
                    },
                    nodebuffer: function (e) {
                      return c.newBufferFrom(new Uint8Array(e));
                    },
                  }),
                  (h.uint8array = {
                    string: i,
                    array: function (e) {
                      return o(e, new Array(e.length));
                    },
                    arraybuffer: function (e) {
                      return e.buffer;
                    },
                    uint8array: r,
                    nodebuffer: function (e) {
                      return c.newBufferFrom(e);
                    },
                  }),
                  (h.nodebuffer = {
                    string: i,
                    array: function (e) {
                      return o(e, new Array(e.length));
                    },
                    arraybuffer: function (e) {
                      return h.nodebuffer.uint8array(e).buffer;
                    },
                    uint8array: function (e) {
                      return o(e, new Uint8Array(e.length));
                    },
                    nodebuffer: r,
                  }),
                  (n.transformTo = function (e, t) {
                    if ((t || (t = ""), !e)) return t;
                    n.checkSupport(e);
                    var r = n.getTypeOf(t);
                    return h[r][e](t);
                  }),
                  (n.getTypeOf = function (e) {
                    return "string" == typeof e
                      ? "string"
                      : "[object Array]" === {}.toString.call(e)
                      ? "array"
                      : a.nodebuffer && c.isBuffer(e)
                      ? "nodebuffer"
                      : a.uint8array && e instanceof Uint8Array
                      ? "uint8array"
                      : a.arraybuffer && e instanceof ArrayBuffer
                      ? "arraybuffer"
                      : void 0;
                  }),
                  (n.checkSupport = function (e) {
                    if (!a[e.toLowerCase()])
                      throw new Error(e + " is not supported by this platform");
                  }),
                  (n.MAX_VALUE_16BITS = 65535),
                  (n.MAX_VALUE_32BITS = -1),
                  (n.pretty = function (e) {
                    var t,
                      n,
                      r = "";
                    for (n = 0; n < (e || "").length; n++)
                      r +=
                        "\\x" +
                        ((t = e.charCodeAt(n)) < 16 ? "0" : "") +
                        t.toString(16).toUpperCase();
                    return r;
                  }),
                  (n.delay = function (e, t, n) {
                    u(function () {
                      e.apply(n || null, t || []);
                    });
                  }),
                  (n.inherits = function (e, t) {
                    var n = function () {};
                    (n.prototype = t.prototype), (e.prototype = new n());
                  }),
                  (n.extend = function () {
                    var e,
                      t,
                      n = {};
                    for (e = 0; e < arguments.length; e++)
                      for (t in arguments[e])
                        arguments[e].hasOwnProperty(t) &&
                          void 0 === n[t] &&
                          (n[t] = arguments[e][t]);
                    return n;
                  }),
                  (n.prepareContent = function (e, t, r, i, o) {
                    return A.Promise.resolve(t)
                      .then(function (e) {
                        return a.blob &&
                          (e instanceof Blob ||
                            -1 !==
                              ["[object File]", "[object Blob]"].indexOf(
                                {}.toString.call(e)
                              )) &&
                          "undefined" != typeof FileReader
                          ? new A.Promise(function (t, n) {
                              var r = new FileReader();
                              (r.onload = function (e) {
                                t(e.target.result);
                              }),
                                (r.onerror = function (e) {
                                  n(e.target.error);
                                }),
                                r.readAsArrayBuffer(e);
                            })
                          : e;
                      })
                      .then(function (t) {
                        var c,
                          u = n.getTypeOf(t);
                        return u
                          ? ("arraybuffer" === u
                              ? (t = n.transformTo("uint8array", t))
                              : "string" === u &&
                                (o
                                  ? (t = l.decode(t))
                                  : r &&
                                    !0 !== i &&
                                    (t = s(
                                      (c = t),
                                      a.uint8array
                                        ? new Uint8Array(c.length)
                                        : new Array(c.length)
                                    ))),
                            t)
                          : A.Promise.reject(
                              new Error(
                                "Can't read the data of '" +
                                  e +
                                  "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"
                              )
                            );
                      });
                  });
              },
              {
                "./base64": 1,
                "./external": 6,
                "./nodejsUtils": 14,
                "./support": 30,
                "set-immediate-shim": 54,
              },
            ],
            33: [
              function (e, t) {
                "use strict";
                function n(e) {
                  (this.files = []), (this.loadOptions = e);
                }
                var r = e("./reader/readerFor"),
                  s = e("./utils"),
                  i = e("./signature"),
                  o = e("./zipEntry"),
                  a = (e("./utf8"), e("./support"));
                (n.prototype = {
                  checkSignature: function (e) {
                    if (!this.reader.readAndCheckSignature(e)) {
                      this.reader.index -= 4;
                      var t = this.reader.readString(4);
                      throw new Error(
                        "Corrupted zip or bug: unexpected signature (" +
                          s.pretty(t) +
                          ", expected " +
                          s.pretty(e) +
                          ")"
                      );
                    }
                  },
                  isSignature: function (e, t) {
                    var n = this.reader.index;
                    this.reader.setIndex(e);
                    var r = this.reader.readString(4) === t;
                    return this.reader.setIndex(n), r;
                  },
                  readBlockEndOfCentral: function () {
                    (this.diskNumber = this.reader.readInt(2)),
                      (this.diskWithCentralDirStart = this.reader.readInt(2)),
                      (this.centralDirRecordsOnThisDisk =
                        this.reader.readInt(2)),
                      (this.centralDirRecords = this.reader.readInt(2)),
                      (this.centralDirSize = this.reader.readInt(4)),
                      (this.centralDirOffset = this.reader.readInt(4)),
                      (this.zipCommentLength = this.reader.readInt(2));
                    var e = this.reader.readData(this.zipCommentLength),
                      t = a.uint8array ? "uint8array" : "array",
                      n = s.transformTo(t, e);
                    this.zipComment = this.loadOptions.decodeFileName(n);
                  },
                  readBlockZip64EndOfCentral: function () {
                    (this.zip64EndOfCentralSize = this.reader.readInt(8)),
                      this.reader.skip(4),
                      (this.diskNumber = this.reader.readInt(4)),
                      (this.diskWithCentralDirStart = this.reader.readInt(4)),
                      (this.centralDirRecordsOnThisDisk =
                        this.reader.readInt(8)),
                      (this.centralDirRecords = this.reader.readInt(8)),
                      (this.centralDirSize = this.reader.readInt(8)),
                      (this.centralDirOffset = this.reader.readInt(8)),
                      (this.zip64ExtensibleData = {});
                    for (
                      var e, t, n, r = this.zip64EndOfCentralSize - 44;
                      0 < r;

                    )
                      (e = this.reader.readInt(2)),
                        (t = this.reader.readInt(4)),
                        (n = this.reader.readData(t)),
                        (this.zip64ExtensibleData[e] = {
                          id: e,
                          length: t,
                          value: n,
                        });
                  },
                  readBlockZip64EndOfCentralLocator: function () {
                    if (
                      ((this.diskWithZip64CentralDirStart =
                        this.reader.readInt(4)),
                      (this.relativeOffsetEndOfZip64CentralDir =
                        this.reader.readInt(8)),
                      (this.disksCount = this.reader.readInt(4)),
                      this.disksCount > 1)
                    )
                      throw new Error("Multi-volumes zip are not supported");
                  },
                  readLocalFiles: function () {
                    var e, t;
                    for (e = 0; e < this.files.length; e++)
                      (t = this.files[e]),
                        this.reader.setIndex(t.localHeaderOffset),
                        this.checkSignature(i.LOCAL_FILE_HEADER),
                        t.readLocalPart(this.reader),
                        t.handleUTF8(),
                        t.processAttributes();
                  },
                  readCentralDir: function () {
                    var e;
                    for (
                      this.reader.setIndex(this.centralDirOffset);
                      this.reader.readAndCheckSignature(i.CENTRAL_FILE_HEADER);

                    )
                      (e = new o(
                        {
                          zip64: this.zip64,
                        },
                        this.loadOptions
                      )).readCentralPart(this.reader),
                        this.files.push(e);
                    if (
                      this.centralDirRecords !== this.files.length &&
                      0 !== this.centralDirRecords &&
                      0 === this.files.length
                    )
                      throw new Error(
                        "Corrupted zip or bug: expected " +
                          this.centralDirRecords +
                          " records in central dir, got " +
                          this.files.length
                      );
                  },
                  readEndOfCentral: function () {
                    var e = this.reader.lastIndexOfSignature(
                      i.CENTRAL_DIRECTORY_END
                    );
                    if (e < 0)
                      throw this.isSignature(0, i.LOCAL_FILE_HEADER)
                        ? new Error(
                            "Corrupted zip: can't find end of central directory"
                          )
                        : new Error(
                            "Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"
                          );
                    this.reader.setIndex(e);
                    var t = e;
                    if (
                      (this.checkSignature(i.CENTRAL_DIRECTORY_END),
                      this.readBlockEndOfCentral(),
                      this.diskNumber === s.MAX_VALUE_16BITS ||
                        this.diskWithCentralDirStart === s.MAX_VALUE_16BITS ||
                        this.centralDirRecordsOnThisDisk ===
                          s.MAX_VALUE_16BITS ||
                        this.centralDirRecords === s.MAX_VALUE_16BITS ||
                        this.centralDirSize === s.MAX_VALUE_32BITS ||
                        this.centralDirOffset === s.MAX_VALUE_32BITS)
                    ) {
                      if (
                        ((this.zip64 = !0),
                        (e = this.reader.lastIndexOfSignature(
                          i.ZIP64_CENTRAL_DIRECTORY_LOCATOR
                        )) < 0)
                      )
                        throw new Error(
                          "Corrupted zip: can't find the ZIP64 end of central directory locator"
                        );
                      if (
                        (this.reader.setIndex(e),
                        this.checkSignature(i.ZIP64_CENTRAL_DIRECTORY_LOCATOR),
                        this.readBlockZip64EndOfCentralLocator(),
                        !this.isSignature(
                          this.relativeOffsetEndOfZip64CentralDir,
                          i.ZIP64_CENTRAL_DIRECTORY_END
                        ) &&
                          ((this.relativeOffsetEndOfZip64CentralDir =
                            this.reader.lastIndexOfSignature(
                              i.ZIP64_CENTRAL_DIRECTORY_END
                            )),
                          this.relativeOffsetEndOfZip64CentralDir < 0))
                      )
                        throw new Error(
                          "Corrupted zip: can't find the ZIP64 end of central directory"
                        );
                      this.reader.setIndex(
                        this.relativeOffsetEndOfZip64CentralDir
                      ),
                        this.checkSignature(i.ZIP64_CENTRAL_DIRECTORY_END),
                        this.readBlockZip64EndOfCentral();
                    }
                    var n = this.centralDirOffset + this.centralDirSize;
                    this.zip64 &&
                      ((n += 20), (n += 12 + this.zip64EndOfCentralSize));
                    var r = t - n;
                    if (r > 0)
                      this.isSignature(t, i.CENTRAL_FILE_HEADER) ||
                        (this.reader.zero = r);
                    else if (r < 0)
                      throw new Error(
                        "Corrupted zip: missing " + Math.abs(r) + " bytes."
                      );
                  },
                  prepareReader: function (e) {
                    this.reader = r(e);
                  },
                  load: function (e) {
                    this.prepareReader(e),
                      this.readEndOfCentral(),
                      this.readCentralDir(),
                      this.readLocalFiles();
                  },
                }),
                  (t.exports = n);
              },
              {
                "./reader/readerFor": 22,
                "./signature": 23,
                "./support": 30,
                "./utf8": 31,
                "./utils": 32,
                "./zipEntry": 34,
              },
            ],
            34: [
              function (e, t) {
                "use strict";
                function n(e, t) {
                  (this.options = e), (this.loadOptions = t);
                }
                var r = e("./reader/readerFor"),
                  s = e("./utils"),
                  i = e("./compressedObject"),
                  o = e("./crc32"),
                  a = e("./utf8"),
                  l = e("./compressions"),
                  c = e("./support");
                (n.prototype = {
                  isEncrypted: function () {
                    return 1 == (1 & this.bitFlag);
                  },
                  useUTF8: function () {
                    return 2048 == (2048 & this.bitFlag);
                  },
                  readLocalPart: function (e) {
                    var t, n;
                    if (
                      (e.skip(22),
                      (this.fileNameLength = e.readInt(2)),
                      (n = e.readInt(2)),
                      (this.fileName = e.readData(this.fileNameLength)),
                      e.skip(n),
                      -1 === this.compressedSize ||
                        -1 === this.uncompressedSize)
                    )
                      throw new Error(
                        "Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)"
                      );
                    if (
                      null ===
                      (t = (function (e) {
                        for (var t in l)
                          if (l.hasOwnProperty(t) && l[t].magic === e)
                            return l[t];
                        return null;
                      })(this.compressionMethod))
                    )
                      throw new Error(
                        "Corrupted zip : compression " +
                          s.pretty(this.compressionMethod) +
                          " unknown (inner file : " +
                          s.transformTo("string", this.fileName) +
                          ")"
                      );
                    this.decompressed = new i(
                      this.compressedSize,
                      this.uncompressedSize,
                      this.crc32,
                      t,
                      e.readData(this.compressedSize)
                    );
                  },
                  readCentralPart: function (e) {
                    (this.versionMadeBy = e.readInt(2)),
                      e.skip(2),
                      (this.bitFlag = e.readInt(2)),
                      (this.compressionMethod = e.readString(2)),
                      (this.date = e.readDate()),
                      (this.crc32 = e.readInt(4)),
                      (this.compressedSize = e.readInt(4)),
                      (this.uncompressedSize = e.readInt(4));
                    var t = e.readInt(2);
                    if (
                      ((this.extraFieldsLength = e.readInt(2)),
                      (this.fileCommentLength = e.readInt(2)),
                      (this.diskNumberStart = e.readInt(2)),
                      (this.internalFileAttributes = e.readInt(2)),
                      (this.externalFileAttributes = e.readInt(4)),
                      (this.localHeaderOffset = e.readInt(4)),
                      this.isEncrypted())
                    )
                      throw new Error("Encrypted zip are not supported");
                    e.skip(t),
                      this.readExtraFields(e),
                      this.parseZIP64ExtraField(e),
                      (this.fileComment = e.readData(this.fileCommentLength));
                  },
                  processAttributes: function () {
                    (this.unixPermissions = null), (this.dosPermissions = null);
                    var e = this.versionMadeBy >> 8;
                    (this.dir = !!(16 & this.externalFileAttributes)),
                      0 === e &&
                        (this.dosPermissions =
                          63 & this.externalFileAttributes),
                      3 === e &&
                        (this.unixPermissions =
                          (this.externalFileAttributes >> 16) & 65535),
                      this.dir ||
                        "/" !== this.fileNameStr.slice(-1) ||
                        (this.dir = !0);
                  },
                  parseZIP64ExtraField: function () {
                    if (this.extraFields[1]) {
                      var e = r(this.extraFields[1].value);
                      this.uncompressedSize === s.MAX_VALUE_32BITS &&
                        (this.uncompressedSize = e.readInt(8)),
                        this.compressedSize === s.MAX_VALUE_32BITS &&
                          (this.compressedSize = e.readInt(8)),
                        this.localHeaderOffset === s.MAX_VALUE_32BITS &&
                          (this.localHeaderOffset = e.readInt(8)),
                        this.diskNumberStart === s.MAX_VALUE_32BITS &&
                          (this.diskNumberStart = e.readInt(4));
                    }
                  },
                  readExtraFields: function (e) {
                    var t,
                      n,
                      r,
                      s = e.index + this.extraFieldsLength;
                    for (
                      this.extraFields || (this.extraFields = {});
                      e.index + 4 < s;

                    )
                      (t = e.readInt(2)),
                        (n = e.readInt(2)),
                        (r = e.readData(n)),
                        (this.extraFields[t] = { id: t, length: n, value: r });
                    e.setIndex(s);
                  },
                  handleUTF8: function () {
                    var e = c.uint8array ? "uint8array" : "array";
                    if (this.useUTF8())
                      (this.fileNameStr = a.utf8decode(this.fileName)),
                        (this.fileCommentStr = a.utf8decode(this.fileComment));
                    else {
                      var t = this.findExtraFieldUnicodePath();
                      if (null !== t) this.fileNameStr = t;
                      else {
                        var n = s.transformTo(e, this.fileName);
                        this.fileNameStr = this.loadOptions.decodeFileName(n);
                      }
                      var r = this.findExtraFieldUnicodeComment();
                      if (null !== r) this.fileCommentStr = r;
                      else {
                        var i = s.transformTo(e, this.fileComment);
                        this.fileCommentStr =
                          this.loadOptions.decodeFileName(i);
                      }
                    }
                  },
                  findExtraFieldUnicodePath: function () {
                    var e = this.extraFields[28789];
                    if (e) {
                      var t = r(e.value);
                      return 1 !== t.readInt(1) ||
                        o(this.fileName) !== t.readInt(4)
                        ? null
                        : a.utf8decode(t.readData(e.length - 5));
                    }
                    return null;
                  },
                  findExtraFieldUnicodeComment: function () {
                    var e = this.extraFields[25461];
                    if (e) {
                      var t = r(e.value);
                      return 1 !== t.readInt(1) ||
                        o(this.fileComment) !== t.readInt(4)
                        ? null
                        : a.utf8decode(t.readData(e.length - 5));
                    }
                    return null;
                  },
                }),
                  (t.exports = n);
              },
              {
                "./compressedObject": 2,
                "./compressions": 3,
                "./crc32": 4,
                "./reader/readerFor": 22,
                "./support": 30,
                "./utf8": 31,
                "./utils": 32,
              },
            ],
            35: [
              function (e, t) {
                "use strict";
                var n = e("./stream/StreamHelper"),
                  r = e("./stream/DataWorker"),
                  s = e("./utf8"),
                  i = e("./compressedObject"),
                  o = e("./stream/GenericWorker"),
                  a = function (e, t, n) {
                    (this.name = e),
                      (this.dir = n.dir),
                      (this.date = n.date),
                      (this.comment = n.comment),
                      (this.unixPermissions = n.unixPermissions),
                      (this.dosPermissions = n.dosPermissions),
                      (this._data = t),
                      (this._dataBinary = n.binary),
                      (this.options = {
                        compression: n.compression,
                        compressionOptions: n.compressionOptions,
                      });
                  };
                a.prototype = {
                  internalStream: function (e) {
                    var t = null,
                      r = "string";
                    try {
                      if (!e) throw new Error("No output type specified.");
                      var i =
                        "string" === (r = e.toLowerCase()) || "text" === r;
                      ("binarystring" !== r && "text" !== r) || (r = "string"),
                        (t = this._decompressWorker());
                      var a = !this._dataBinary;
                      a && !i && (t = t.pipe(new s.Utf8EncodeWorker())),
                        !a && i && (t = t.pipe(new s.Utf8DecodeWorker()));
                    } catch (e) {
                      (t = new o("error")).error(e);
                    }
                    return new n(t, r, "");
                  },
                  async: function (e, t) {
                    return this.internalStream(e).accumulate(t);
                  },
                  nodeStream: function (e, t) {
                    return this.internalStream(
                      e || "nodebuffer"
                    ).toNodejsStream(t);
                  },
                  _compressWorker: function (e, t) {
                    if (
                      this._data instanceof i &&
                      this._data.compression.magic === e.magic
                    )
                      return this._data.getCompressedWorker();
                    var n = this._decompressWorker();
                    return (
                      this._dataBinary ||
                        (n = n.pipe(new s.Utf8EncodeWorker())),
                      i.createWorkerFrom(n, e, t)
                    );
                  },
                  _decompressWorker: function () {
                    return this._data instanceof i
                      ? this._data.getContentWorker()
                      : this._data instanceof o
                      ? this._data
                      : new r(this._data);
                  },
                };
                for (
                  var l = [
                      "asText",
                      "asBinary",
                      "asNodeBuffer",
                      "asUint8Array",
                      "asArrayBuffer",
                    ],
                    c = function () {
                      throw new Error(
                        "This method has been removed in JSZip 3.0, please check the upgrade guide."
                      );
                    },
                    u = 0;
                  u < l.length;
                  u++
                )
                  a.prototype[l[u]] = c;
                t.exports = a;
              },
              {
                "./compressedObject": 2,
                "./stream/DataWorker": 27,
                "./stream/GenericWorker": 28,
                "./stream/StreamHelper": 29,
                "./utf8": 31,
              },
            ],
            36: [
              function (e, t) {
                (function (e) {
                  "use strict";
                  function n() {
                    var e, t;
                    s = !0;
                    for (var n = u.length; n; ) {
                      for (t = u, u = [], e = -1; ++e < n; ) t[e]();
                      n = u.length;
                    }
                    s = !1;
                  }
                  var r,
                    s,
                    i = e.MutationObserver || e.WebKitMutationObserver;
                  if (i) {
                    var o = 0,
                      a = new i(n),
                      l = e.document.createTextNode("");
                    a.observe(l, { characterData: !0 }),
                      (r = function () {
                        l.data = o = ++o % 2;
                      });
                  } else if (e.setImmediate || void 0 === e.MessageChannel)
                    r =
                      "document" in e &&
                      "onreadystatechange" in e.document.createElement("script")
                        ? function () {
                            var t = e.document.createElement("script");
                            (t.onreadystatechange = function () {
                              n(),
                                (t.onreadystatechange = null),
                                t.parentNode.removeChild(t),
                                (t = null);
                            }),
                              e.document.documentElement.appendChild(t);
                          }
                        : function () {
                            setTimeout(n, 0);
                          };
                  else {
                    var c = new e.MessageChannel();
                    (c.port1.onmessage = n),
                      (r = function () {
                        c.port2.postMessage(0);
                      });
                  }
                  var u = [];
                  t.exports = function (e) {
                    1 !== u.push(e) || s || r();
                  };
                }).call(
                  this,
                  void 0 !== n.g
                    ? n.g
                    : "undefined" != typeof self
                    ? self
                    : "undefined" != typeof window
                    ? window
                    : {}
                );
              },
              {},
            ],
            37: [
              function (e, t) {
                "use strict";
                function n() {}
                function r(e) {
                  if ("function" != typeof e)
                    throw new TypeError("resolver must be a function");
                  (this.state = h),
                    (this.queue = []),
                    (this.outcome = void 0),
                    e !== n && a(this, e);
                }
                function s(e, t, n) {
                  (this.promise = e),
                    "function" == typeof t &&
                      ((this.onFulfilled = t),
                      (this.callFulfilled = this.otherCallFulfilled)),
                    "function" == typeof n &&
                      ((this.onRejected = n),
                      (this.callRejected = this.otherCallRejected));
                }
                function i(e, t, n) {
                  c(function () {
                    var r;
                    try {
                      r = t(n);
                    } catch (t) {
                      return u.reject(e, t);
                    }
                    r === e
                      ? u.reject(
                          e,
                          new TypeError("Cannot resolve promise with itself")
                        )
                      : u.resolve(e, r);
                  });
                }
                function o(e) {
                  var t = e && e.then;
                  if (
                    e &&
                    ("object" == typeof e || "function" == typeof e) &&
                    "function" == typeof t
                  )
                    return function () {
                      t.apply(e, arguments);
                    };
                }
                function a(e, t) {
                  function n(t) {
                    s || ((s = !0), u.reject(e, t));
                  }
                  function r(t) {
                    s || ((s = !0), u.resolve(e, t));
                  }
                  var s = !1,
                    i = l(function () {
                      t(r, n);
                    });
                  "error" === i.status && n(i.value);
                }
                function l(e, t) {
                  var n = {};
                  try {
                    (n.value = e(t)), (n.status = "success");
                  } catch (e) {
                    (n.status = "error"), (n.value = e);
                  }
                  return n;
                }
                var c = e("immediate"),
                  u = {},
                  A = ["REJECTED"],
                  d = ["FULFILLED"],
                  h = ["PENDING"];
                (t.exports = r),
                  (r.prototype.finally = function (e) {
                    if ("function" != typeof e) return this;
                    var t = this.constructor;
                    return this.then(
                      function (n) {
                        return t.resolve(e()).then(function () {
                          return n;
                        });
                      },
                      function (n) {
                        return t.resolve(e()).then(function () {
                          throw n;
                        });
                      }
                    );
                  }),
                  (r.prototype.catch = function (e) {
                    return this.then(null, e);
                  }),
                  (r.prototype.then = function (e, t) {
                    if (
                      ("function" != typeof e && this.state === d) ||
                      ("function" != typeof t && this.state === A)
                    )
                      return this;
                    var r = new this.constructor(n);
                    return (
                      this.state !== h
                        ? i(r, this.state === d ? e : t, this.outcome)
                        : this.queue.push(new s(r, e, t)),
                      r
                    );
                  }),
                  (s.prototype.callFulfilled = function (e) {
                    u.resolve(this.promise, e);
                  }),
                  (s.prototype.otherCallFulfilled = function (e) {
                    i(this.promise, this.onFulfilled, e);
                  }),
                  (s.prototype.callRejected = function (e) {
                    u.reject(this.promise, e);
                  }),
                  (s.prototype.otherCallRejected = function (e) {
                    i(this.promise, this.onRejected, e);
                  }),
                  (u.resolve = function (e, t) {
                    var n = l(o, t);
                    if ("error" === n.status) return u.reject(e, n.value);
                    var r = n.value;
                    if (r) a(e, r);
                    else {
                      (e.state = d), (e.outcome = t);
                      for (var s = -1, i = e.queue.length; ++s < i; )
                        e.queue[s].callFulfilled(t);
                    }
                    return e;
                  }),
                  (u.reject = function (e, t) {
                    (e.state = A), (e.outcome = t);
                    for (var n = -1, r = e.queue.length; ++n < r; )
                      e.queue[n].callRejected(t);
                    return e;
                  }),
                  (r.resolve = function (e) {
                    return e instanceof this ? e : u.resolve(new this(n), e);
                  }),
                  (r.reject = function (e) {
                    var t = new this(n);
                    return u.reject(t, e);
                  }),
                  (r.all = function (e) {
                    function t(e, t) {
                      r.resolve(e).then(
                        function (e) {
                          (o[t] = e),
                            ++a !== s || i || ((i = !0), u.resolve(c, o));
                        },
                        function (e) {
                          i || ((i = !0), u.reject(c, e));
                        }
                      );
                    }
                    var r = this;
                    if ("[object Array]" !== {}.toString.call(e))
                      return this.reject(new TypeError("must be an array"));
                    var s = e.length,
                      i = !1;
                    if (!s) return this.resolve([]);
                    for (
                      var o = new Array(s), a = 0, l = -1, c = new this(n);
                      ++l < s;

                    )
                      t(e[l], l);
                    return c;
                  }),
                  (r.race = function (e) {
                    if ("[object Array]" !== {}.toString.call(e))
                      return this.reject(new TypeError("must be an array"));
                    var t,
                      r = e.length,
                      s = !1;
                    if (!r) return this.resolve([]);
                    for (var i = -1, o = new this(n); ++i < r; )
                      (t = e[i]),
                        this.resolve(t).then(
                          function (e) {
                            s || ((s = !0), u.resolve(o, e));
                          },
                          function (e) {
                            s || ((s = !0), u.reject(o, e));
                          }
                        );
                    return o;
                  });
              },
              { immediate: 36 },
            ],
            38: [
              function (e, t) {
                "use strict";
                var n = {};
                (0, e("./lib/utils/common").assign)(
                  n,
                  e("./lib/deflate"),
                  e("./lib/inflate"),
                  e("./lib/zlib/constants")
                ),
                  (t.exports = n);
              },
              {
                "./lib/deflate": 39,
                "./lib/inflate": 40,
                "./lib/utils/common": 41,
                "./lib/zlib/constants": 44,
              },
            ],
            39: [
              function (e, t, n) {
                "use strict";
                function r(e) {
                  if (!(this instanceof r)) return new r(e);
                  this.options = o.assign(
                    {
                      level: d,
                      method: p,
                      chunkSize: 16384,
                      windowBits: 15,
                      memLevel: 8,
                      strategy: h,
                      to: "",
                    },
                    e || {}
                  );
                  var t = this.options;
                  t.raw && t.windowBits > 0
                    ? (t.windowBits = -t.windowBits)
                    : t.gzip &&
                      t.windowBits > 0 &&
                      t.windowBits < 16 &&
                      (t.windowBits += 16),
                    (this.err = 0),
                    (this.msg = ""),
                    (this.ended = !1),
                    (this.chunks = []),
                    (this.strm = new c()),
                    (this.strm.avail_out = 0);
                  var n = i.deflateInit2(
                    this.strm,
                    t.level,
                    t.method,
                    t.windowBits,
                    t.memLevel,
                    t.strategy
                  );
                  if (n !== A) throw new Error(l[n]);
                  if (
                    (t.header && i.deflateSetHeader(this.strm, t.header),
                    t.dictionary)
                  ) {
                    var s;
                    if (
                      ((s =
                        "string" == typeof t.dictionary
                          ? a.string2buf(t.dictionary)
                          : "[object ArrayBuffer]" === u.call(t.dictionary)
                          ? new Uint8Array(t.dictionary)
                          : t.dictionary),
                      (n = i.deflateSetDictionary(this.strm, s)) !== A)
                    )
                      throw new Error(l[n]);
                    this._dict_set = !0;
                  }
                }
                function s(e, t) {
                  var n = new r(t);
                  if ((n.push(e, !0), n.err)) throw n.msg || l[n.err];
                  return n.result;
                }
                var i = e("./zlib/deflate"),
                  o = e("./utils/common"),
                  a = e("./utils/strings"),
                  l = e("./zlib/messages"),
                  c = e("./zlib/zstream"),
                  u = {}.toString,
                  A = 0,
                  d = -1,
                  h = 0,
                  p = 8;
                (r.prototype.push = function (e, t) {
                  var n,
                    r,
                    s = this.strm,
                    l = this.options.chunkSize;
                  if (this.ended) return !1;
                  (r = t === ~~t ? t : !0 === t ? 4 : 0),
                    "string" == typeof e
                      ? (s.input = a.string2buf(e))
                      : "[object ArrayBuffer]" === u.call(e)
                      ? (s.input = new Uint8Array(e))
                      : (s.input = e),
                    (s.next_in = 0),
                    (s.avail_in = s.input.length);
                  do {
                    if (
                      (0 === s.avail_out &&
                        ((s.output = new o.Buf8(l)),
                        (s.next_out = 0),
                        (s.avail_out = l)),
                      1 !== (n = i.deflate(s, r)) && n !== A)
                    )
                      return this.onEnd(n), (this.ended = !0), !1;
                    (0 !== s.avail_out &&
                      (0 !== s.avail_in || (4 !== r && 2 !== r))) ||
                      ("string" === this.options.to
                        ? this.onData(
                            a.buf2binstring(o.shrinkBuf(s.output, s.next_out))
                          )
                        : this.onData(o.shrinkBuf(s.output, s.next_out)));
                  } while ((s.avail_in > 0 || 0 === s.avail_out) && 1 !== n);
                  return 4 === r
                    ? ((n = i.deflateEnd(this.strm)),
                      this.onEnd(n),
                      (this.ended = !0),
                      n === A)
                    : 2 !== r || (this.onEnd(A), (s.avail_out = 0), !0);
                }),
                  (r.prototype.onData = function (e) {
                    this.chunks.push(e);
                  }),
                  (r.prototype.onEnd = function (e) {
                    e === A &&
                      ("string" === this.options.to
                        ? (this.result = this.chunks.join(""))
                        : (this.result = o.flattenChunks(this.chunks))),
                      (this.chunks = []),
                      (this.err = e),
                      (this.msg = this.strm.msg);
                  }),
                  (n.Deflate = r),
                  (n.deflate = s),
                  (n.deflateRaw = function (e, t) {
                    return ((t = t || {}).raw = !0), s(e, t);
                  }),
                  (n.gzip = function (e, t) {
                    return ((t = t || {}).gzip = !0), s(e, t);
                  });
              },
              {
                "./utils/common": 41,
                "./utils/strings": 42,
                "./zlib/deflate": 46,
                "./zlib/messages": 51,
                "./zlib/zstream": 53,
              },
            ],
            40: [
              function (e, t, n) {
                "use strict";
                function r(e) {
                  if (!(this instanceof r)) return new r(e);
                  this.options = o.assign(
                    { chunkSize: 16384, windowBits: 0, to: "" },
                    e || {}
                  );
                  var t = this.options;
                  t.raw &&
                    t.windowBits >= 0 &&
                    t.windowBits < 16 &&
                    ((t.windowBits = -t.windowBits),
                    0 === t.windowBits && (t.windowBits = -15)),
                    !(t.windowBits >= 0 && t.windowBits < 16) ||
                      (e && e.windowBits) ||
                      (t.windowBits += 32),
                    t.windowBits > 15 &&
                      t.windowBits < 48 &&
                      0 == (15 & t.windowBits) &&
                      (t.windowBits |= 15),
                    (this.err = 0),
                    (this.msg = ""),
                    (this.ended = !1),
                    (this.chunks = []),
                    (this.strm = new u()),
                    (this.strm.avail_out = 0);
                  var n = i.inflateInit2(this.strm, t.windowBits);
                  if (n !== l.Z_OK) throw new Error(c[n]);
                  (this.header = new A()),
                    i.inflateGetHeader(this.strm, this.header);
                }
                function s(e, t) {
                  var n = new r(t);
                  if ((n.push(e, !0), n.err)) throw n.msg || c[n.err];
                  return n.result;
                }
                var i = e("./zlib/inflate"),
                  o = e("./utils/common"),
                  a = e("./utils/strings"),
                  l = e("./zlib/constants"),
                  c = e("./zlib/messages"),
                  u = e("./zlib/zstream"),
                  A = e("./zlib/gzheader"),
                  d = {}.toString;
                (r.prototype.push = function (e, t) {
                  var n,
                    r,
                    s,
                    c,
                    u,
                    A,
                    h = this.strm,
                    p = this.options.chunkSize,
                    f = this.options.dictionary,
                    m = !1;
                  if (this.ended) return !1;
                  (r = t === ~~t ? t : !0 === t ? l.Z_FINISH : l.Z_NO_FLUSH),
                    "string" == typeof e
                      ? (h.input = a.binstring2buf(e))
                      : "[object ArrayBuffer]" === d.call(e)
                      ? (h.input = new Uint8Array(e))
                      : (h.input = e),
                    (h.next_in = 0),
                    (h.avail_in = h.input.length);
                  do {
                    if (
                      (0 === h.avail_out &&
                        ((h.output = new o.Buf8(p)),
                        (h.next_out = 0),
                        (h.avail_out = p)),
                      (n = i.inflate(h, l.Z_NO_FLUSH)) === l.Z_NEED_DICT &&
                        f &&
                        ((A =
                          "string" == typeof f
                            ? a.string2buf(f)
                            : "[object ArrayBuffer]" === d.call(f)
                            ? new Uint8Array(f)
                            : f),
                        (n = i.inflateSetDictionary(this.strm, A))),
                      n === l.Z_BUF_ERROR &&
                        !0 === m &&
                        ((n = l.Z_OK), (m = !1)),
                      n !== l.Z_STREAM_END && n !== l.Z_OK)
                    )
                      return this.onEnd(n), (this.ended = !0), !1;
                    h.next_out &&
                      ((0 !== h.avail_out &&
                        n !== l.Z_STREAM_END &&
                        (0 !== h.avail_in ||
                          (r !== l.Z_FINISH && r !== l.Z_SYNC_FLUSH))) ||
                        ("string" === this.options.to
                          ? ((s = a.utf8border(h.output, h.next_out)),
                            (c = h.next_out - s),
                            (u = a.buf2string(h.output, s)),
                            (h.next_out = c),
                            (h.avail_out = p - c),
                            c && o.arraySet(h.output, h.output, s, c, 0),
                            this.onData(u))
                          : this.onData(o.shrinkBuf(h.output, h.next_out)))),
                      0 === h.avail_in && 0 === h.avail_out && (m = !0);
                  } while (
                    (h.avail_in > 0 || 0 === h.avail_out) &&
                    n !== l.Z_STREAM_END
                  );
                  return (
                    n === l.Z_STREAM_END && (r = l.Z_FINISH),
                    r === l.Z_FINISH
                      ? ((n = i.inflateEnd(this.strm)),
                        this.onEnd(n),
                        (this.ended = !0),
                        n === l.Z_OK)
                      : r !== l.Z_SYNC_FLUSH ||
                        (this.onEnd(l.Z_OK), (h.avail_out = 0), !0)
                  );
                }),
                  (r.prototype.onData = function (e) {
                    this.chunks.push(e);
                  }),
                  (r.prototype.onEnd = function (e) {
                    e === l.Z_OK &&
                      ("string" === this.options.to
                        ? (this.result = this.chunks.join(""))
                        : (this.result = o.flattenChunks(this.chunks))),
                      (this.chunks = []),
                      (this.err = e),
                      (this.msg = this.strm.msg);
                  }),
                  (n.Inflate = r),
                  (n.inflate = s),
                  (n.inflateRaw = function (e, t) {
                    return ((t = t || {}).raw = !0), s(e, t);
                  }),
                  (n.ungzip = s);
              },
              {
                "./utils/common": 41,
                "./utils/strings": 42,
                "./zlib/constants": 44,
                "./zlib/gzheader": 47,
                "./zlib/inflate": 49,
                "./zlib/messages": 51,
                "./zlib/zstream": 53,
              },
            ],
            41: [
              function (e, t, n) {
                "use strict";
                var r =
                  "undefined" != typeof Uint8Array &&
                  "undefined" != typeof Uint16Array &&
                  "undefined" != typeof Int32Array;
                (n.assign = function (e) {
                  for (var t = [].slice.call(arguments, 1); t.length; ) {
                    var n = t.shift();
                    if (n) {
                      if ("object" != typeof n)
                        throw new TypeError(n + "must be non-object");
                      for (var r in n) n.hasOwnProperty(r) && (e[r] = n[r]);
                    }
                  }
                  return e;
                }),
                  (n.shrinkBuf = function (e, t) {
                    return e.length === t
                      ? e
                      : e.subarray
                      ? e.subarray(0, t)
                      : ((e.length = t), e);
                  });
                var s = {
                    arraySet: function (e, t, n, r, s) {
                      if (t.subarray && e.subarray)
                        e.set(t.subarray(n, n + r), s);
                      else for (var i = 0; i < r; i++) e[s + i] = t[n + i];
                    },
                    flattenChunks: function (e) {
                      var t, n, r, s, i, o;
                      for (r = 0, t = 0, n = e.length; t < n; t++)
                        r += e[t].length;
                      for (
                        o = new Uint8Array(r), s = 0, t = 0, n = e.length;
                        t < n;
                        t++
                      )
                        (i = e[t]), o.set(i, s), (s += i.length);
                      return o;
                    },
                  },
                  i = {
                    arraySet: function (e, t, n, r, s) {
                      for (var i = 0; i < r; i++) e[s + i] = t[n + i];
                    },
                    flattenChunks: function (e) {
                      return [].concat.apply([], e);
                    },
                  };
                (n.setTyped = function (e) {
                  e
                    ? ((n.Buf8 = Uint8Array),
                      (n.Buf16 = Uint16Array),
                      (n.Buf32 = Int32Array),
                      n.assign(n, s))
                    : ((n.Buf8 = Array),
                      (n.Buf16 = Array),
                      (n.Buf32 = Array),
                      n.assign(n, i));
                }),
                  n.setTyped(r);
              },
              {},
            ],
            42: [
              function (e, t, n) {
                "use strict";
                function r(e, t) {
                  if (t < 65537 && ((e.subarray && o) || (!e.subarray && i)))
                    return String.fromCharCode.apply(null, s.shrinkBuf(e, t));
                  for (var n = "", r = 0; r < t; r++)
                    n += String.fromCharCode(e[r]);
                  return n;
                }
                var s = e("./common"),
                  i = !0,
                  o = !0;
                try {
                  String.fromCharCode.apply(null, [0]);
                } catch (e) {
                  i = !1;
                }
                try {
                  String.fromCharCode.apply(null, new Uint8Array(1));
                } catch (e) {
                  o = !1;
                }
                for (var a = new s.Buf8(256), l = 0; l < 256; l++)
                  a[l] =
                    l >= 252
                      ? 6
                      : l >= 248
                      ? 5
                      : l >= 240
                      ? 4
                      : l >= 224
                      ? 3
                      : l >= 192
                      ? 2
                      : 1;
                (a[254] = a[254] = 1),
                  (n.string2buf = function (e) {
                    var t,
                      n,
                      r,
                      i,
                      o,
                      a = e.length,
                      l = 0;
                    for (i = 0; i < a; i++)
                      55296 == (64512 & (n = e.charCodeAt(i))) &&
                        i + 1 < a &&
                        56320 == (64512 & (r = e.charCodeAt(i + 1))) &&
                        ((n = 65536 + ((n - 55296) << 10) + (r - 56320)), i++),
                        (l += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4);
                    for (t = new s.Buf8(l), o = 0, i = 0; o < l; i++)
                      55296 == (64512 & (n = e.charCodeAt(i))) &&
                        i + 1 < a &&
                        56320 == (64512 & (r = e.charCodeAt(i + 1))) &&
                        ((n = 65536 + ((n - 55296) << 10) + (r - 56320)), i++),
                        n < 128
                          ? (t[o++] = n)
                          : n < 2048
                          ? ((t[o++] = 192 | (n >>> 6)),
                            (t[o++] = 128 | (63 & n)))
                          : n < 65536
                          ? ((t[o++] = 224 | (n >>> 12)),
                            (t[o++] = 128 | ((n >>> 6) & 63)),
                            (t[o++] = 128 | (63 & n)))
                          : ((t[o++] = 240 | (n >>> 18)),
                            (t[o++] = 128 | ((n >>> 12) & 63)),
                            (t[o++] = 128 | ((n >>> 6) & 63)),
                            (t[o++] = 128 | (63 & n)));
                    return t;
                  }),
                  (n.buf2binstring = function (e) {
                    return r(e, e.length);
                  }),
                  (n.binstring2buf = function (e) {
                    for (
                      var t = new s.Buf8(e.length), n = 0, r = t.length;
                      n < r;
                      n++
                    )
                      t[n] = e.charCodeAt(n);
                    return t;
                  }),
                  (n.buf2string = function (e, t) {
                    var n,
                      s,
                      i,
                      o,
                      l = t || e.length,
                      c = new Array(2 * l);
                    for (s = 0, n = 0; n < l; )
                      if ((i = e[n++]) < 128) c[s++] = i;
                      else if ((o = a[i]) > 4) (c[s++] = 65533), (n += o - 1);
                      else {
                        for (
                          i &= 2 === o ? 31 : 3 === o ? 15 : 7;
                          o > 1 && n < l;

                        )
                          (i = (i << 6) | (63 & e[n++])), o--;
                        o > 1
                          ? (c[s++] = 65533)
                          : i < 65536
                          ? (c[s++] = i)
                          : ((i -= 65536),
                            (c[s++] = 55296 | ((i >> 10) & 1023)),
                            (c[s++] = 56320 | (1023 & i)));
                      }
                    return r(c, s);
                  }),
                  (n.utf8border = function (e, t) {
                    var n;
                    for (
                      (t = t || e.length) > e.length && (t = e.length),
                        n = t - 1;
                      n >= 0 && 128 == (192 & e[n]);

                    )
                      n--;
                    return n < 0 || 0 === n ? t : n + a[e[n]] > t ? n : t;
                  });
              },
              { "./common": 41 },
            ],
            43: [
              function (e, t) {
                "use strict";
                t.exports = function (e, t, n, r) {
                  for (
                    var s = (65535 & e) | 0,
                      i = ((e >>> 16) & 65535) | 0,
                      o = 0;
                    0 !== n;

                  ) {
                    n -= o = n > 2e3 ? 2e3 : n;
                    do {
                      i = (i + (s = (s + t[r++]) | 0)) | 0;
                    } while (--o);
                    (s %= 65521), (i %= 65521);
                  }
                  return s | (i << 16) | 0;
                };
              },
              {},
            ],
            44: [
              function (e, t) {
                "use strict";
                t.exports = {
                  Z_NO_FLUSH: 0,
                  Z_PARTIAL_FLUSH: 1,
                  Z_SYNC_FLUSH: 2,
                  Z_FULL_FLUSH: 3,
                  Z_FINISH: 4,
                  Z_BLOCK: 5,
                  Z_TREES: 6,
                  Z_OK: 0,
                  Z_STREAM_END: 1,
                  Z_NEED_DICT: 2,
                  Z_ERRNO: -1,
                  Z_STREAM_ERROR: -2,
                  Z_DATA_ERROR: -3,
                  Z_BUF_ERROR: -5,
                  Z_NO_COMPRESSION: 0,
                  Z_BEST_SPEED: 1,
                  Z_BEST_COMPRESSION: 9,
                  Z_DEFAULT_COMPRESSION: -1,
                  Z_FILTERED: 1,
                  Z_HUFFMAN_ONLY: 2,
                  Z_RLE: 3,
                  Z_FIXED: 4,
                  Z_DEFAULT_STRATEGY: 0,
                  Z_BINARY: 0,
                  Z_TEXT: 1,
                  Z_UNKNOWN: 2,
                  Z_DEFLATED: 8,
                };
              },
              {},
            ],
            45: [
              function (e, t) {
                "use strict";
                var n = (function () {
                  for (var e, t = [], n = 0; n < 256; n++) {
                    e = n;
                    for (var r = 0; r < 8; r++)
                      e = 1 & e ? 3988292384 ^ (e >>> 1) : e >>> 1;
                    t[n] = e;
                  }
                  return t;
                })();
                t.exports = function (e, t, r, s) {
                  var i = n,
                    o = s + r;
                  e ^= -1;
                  for (var a = s; a < o; a++)
                    e = (e >>> 8) ^ i[255 & (e ^ t[a])];
                  return -1 ^ e;
                };
              },
              {},
            ],
            46: [
              function (e, t, n) {
                "use strict";
                function r(e, t) {
                  return (e.msg = R[t]), t;
                }
                function s(e) {
                  return (e << 1) - (e > 4 ? 9 : 0);
                }
                function i(e) {
                  for (var t = e.length; --t >= 0; ) e[t] = 0;
                }
                function o(e) {
                  var t = e.state,
                    n = t.pending;
                  n > e.avail_out && (n = e.avail_out),
                    0 !== n &&
                      (w.arraySet(
                        e.output,
                        t.pending_buf,
                        t.pending_out,
                        n,
                        e.next_out
                      ),
                      (e.next_out += n),
                      (t.pending_out += n),
                      (e.total_out += n),
                      (e.avail_out -= n),
                      (t.pending -= n),
                      0 === t.pending && (t.pending_out = 0));
                }
                function a(e, t) {
                  b._tr_flush_block(
                    e,
                    e.block_start >= 0 ? e.block_start : -1,
                    e.strstart - e.block_start,
                    t
                  ),
                    (e.block_start = e.strstart),
                    o(e.strm);
                }
                function l(e, t) {
                  e.pending_buf[e.pending++] = t;
                }
                function c(e, t) {
                  (e.pending_buf[e.pending++] = (t >>> 8) & 255),
                    (e.pending_buf[e.pending++] = 255 & t);
                }
                function u(e, t) {
                  var n,
                    r,
                    s = e.max_chain_length,
                    i = e.strstart,
                    o = e.prev_length,
                    a = e.nice_match,
                    l =
                      e.strstart > e.w_size - N
                        ? e.strstart - (e.w_size - N)
                        : 0,
                    c = e.window,
                    u = e.w_mask,
                    A = e.prev,
                    d = e.strstart + L,
                    h = c[i + o - 1],
                    p = c[i + o];
                  e.prev_length >= e.good_match && (s >>= 2),
                    a > e.lookahead && (a = e.lookahead);
                  do {
                    if (
                      c[(n = t) + o] === p &&
                      c[n + o - 1] === h &&
                      c[n] === c[i] &&
                      c[++n] === c[i + 1]
                    ) {
                      (i += 2), n++;
                      do {} while (
                        c[++i] === c[++n] &&
                        c[++i] === c[++n] &&
                        c[++i] === c[++n] &&
                        c[++i] === c[++n] &&
                        c[++i] === c[++n] &&
                        c[++i] === c[++n] &&
                        c[++i] === c[++n] &&
                        c[++i] === c[++n] &&
                        i < d
                      );
                      if (((r = L - (d - i)), (i = d - L), r > o)) {
                        if (((e.match_start = t), (o = r), r >= a)) break;
                        (h = c[i + o - 1]), (p = c[i + o]);
                      }
                    }
                  } while ((t = A[t & u]) > l && 0 != --s);
                  return o <= e.lookahead ? o : e.lookahead;
                }
                function A(e) {
                  var t,
                    n,
                    r,
                    s,
                    i,
                    o,
                    a,
                    l,
                    c,
                    u,
                    A = e.w_size;
                  do {
                    if (
                      ((s = e.window_size - e.lookahead - e.strstart),
                      e.strstart >= A + (A - N))
                    ) {
                      w.arraySet(e.window, e.window, A, A, 0),
                        (e.match_start -= A),
                        (e.strstart -= A),
                        (e.block_start -= A),
                        (t = n = e.hash_size);
                      do {
                        (r = e.head[--t]), (e.head[t] = r >= A ? r - A : 0);
                      } while (--n);
                      t = n = A;
                      do {
                        (r = e.prev[--t]), (e.prev[t] = r >= A ? r - A : 0);
                      } while (--n);
                      s += A;
                    }
                    if (0 === e.strm.avail_in) break;
                    if (
                      ((o = e.strm),
                      (a = e.window),
                      (l = e.strstart + e.lookahead),
                      (c = s),
                      (u = void 0),
                      (u = o.avail_in) > c && (u = c),
                      (n =
                        0 === u
                          ? 0
                          : ((o.avail_in -= u),
                            w.arraySet(a, o.input, o.next_in, u, l),
                            1 === o.state.wrap
                              ? (o.adler = y(o.adler, a, u, l))
                              : 2 === o.state.wrap &&
                                (o.adler = k(o.adler, a, u, l)),
                            (o.next_in += u),
                            (o.total_in += u),
                            u)),
                      (e.lookahead += n),
                      e.lookahead + e.insert >= P)
                    )
                      for (
                        i = e.strstart - e.insert,
                          e.ins_h = e.window[i],
                          e.ins_h =
                            ((e.ins_h << e.hash_shift) ^ e.window[i + 1]) &
                            e.hash_mask;
                        e.insert &&
                        ((e.ins_h =
                          ((e.ins_h << e.hash_shift) ^ e.window[i + P - 1]) &
                          e.hash_mask),
                        (e.prev[i & e.w_mask] = e.head[e.ins_h]),
                        (e.head[e.ins_h] = i),
                        i++,
                        e.insert--,
                        !(e.lookahead + e.insert < P));

                      );
                  } while (e.lookahead < N && 0 !== e.strm.avail_in);
                }
                function d(e, t) {
                  for (var n, r; ; ) {
                    if (e.lookahead < N) {
                      if ((A(e), e.lookahead < N && t === x)) return Q;
                      if (0 === e.lookahead) break;
                    }
                    if (
                      ((n = 0),
                      e.lookahead >= P &&
                        ((e.ins_h =
                          ((e.ins_h << e.hash_shift) ^
                            e.window[e.strstart + P - 1]) &
                          e.hash_mask),
                        (n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]),
                        (e.head[e.ins_h] = e.strstart)),
                      0 !== n &&
                        e.strstart - n <= e.w_size - N &&
                        (e.match_length = u(e, n)),
                      e.match_length >= P)
                    )
                      if (
                        ((r = b._tr_tally(
                          e,
                          e.strstart - e.match_start,
                          e.match_length - P
                        )),
                        (e.lookahead -= e.match_length),
                        e.match_length <= e.max_lazy_match && e.lookahead >= P)
                      ) {
                        e.match_length--;
                        do {
                          e.strstart++,
                            (e.ins_h =
                              ((e.ins_h << e.hash_shift) ^
                                e.window[e.strstart + P - 1]) &
                              e.hash_mask),
                            (n = e.prev[e.strstart & e.w_mask] =
                              e.head[e.ins_h]),
                            (e.head[e.ins_h] = e.strstart);
                        } while (0 != --e.match_length);
                        e.strstart++;
                      } else
                        (e.strstart += e.match_length),
                          (e.match_length = 0),
                          (e.ins_h = e.window[e.strstart]),
                          (e.ins_h =
                            ((e.ins_h << e.hash_shift) ^
                              e.window[e.strstart + 1]) &
                            e.hash_mask);
                    else
                      (r = b._tr_tally(e, 0, e.window[e.strstart])),
                        e.lookahead--,
                        e.strstart++;
                    if (r && (a(e, !1), 0 === e.strm.avail_out)) return Q;
                  }
                  return (
                    (e.insert = e.strstart < P - 1 ? e.strstart : P - 1),
                    t === E
                      ? (a(e, !0), 0 === e.strm.avail_out ? X : Y)
                      : e.last_lit && (a(e, !1), 0 === e.strm.avail_out)
                      ? Q
                      : W
                  );
                }
                function h(e, t) {
                  for (var n, r, s; ; ) {
                    if (e.lookahead < N) {
                      if ((A(e), e.lookahead < N && t === x)) return Q;
                      if (0 === e.lookahead) break;
                    }
                    if (
                      ((n = 0),
                      e.lookahead >= P &&
                        ((e.ins_h =
                          ((e.ins_h << e.hash_shift) ^
                            e.window[e.strstart + P - 1]) &
                          e.hash_mask),
                        (n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]),
                        (e.head[e.ins_h] = e.strstart)),
                      (e.prev_length = e.match_length),
                      (e.prev_match = e.match_start),
                      (e.match_length = P - 1),
                      0 !== n &&
                        e.prev_length < e.max_lazy_match &&
                        e.strstart - n <= e.w_size - N &&
                        ((e.match_length = u(e, n)),
                        e.match_length <= 5 &&
                          (e.strategy === I ||
                            (e.match_length === P &&
                              e.strstart - e.match_start > 4096)) &&
                          (e.match_length = P - 1)),
                      e.prev_length >= P && e.match_length <= e.prev_length)
                    ) {
                      (s = e.strstart + e.lookahead - P),
                        (r = b._tr_tally(
                          e,
                          e.strstart - 1 - e.prev_match,
                          e.prev_length - P
                        )),
                        (e.lookahead -= e.prev_length - 1),
                        (e.prev_length -= 2);
                      do {
                        ++e.strstart <= s &&
                          ((e.ins_h =
                            ((e.ins_h << e.hash_shift) ^
                              e.window[e.strstart + P - 1]) &
                            e.hash_mask),
                          (n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]),
                          (e.head[e.ins_h] = e.strstart));
                      } while (0 != --e.prev_length);
                      if (
                        ((e.match_available = 0),
                        (e.match_length = P - 1),
                        e.strstart++,
                        r && (a(e, !1), 0 === e.strm.avail_out))
                      )
                        return Q;
                    } else if (e.match_available) {
                      if (
                        ((r = b._tr_tally(e, 0, e.window[e.strstart - 1])) &&
                          a(e, !1),
                        e.strstart++,
                        e.lookahead--,
                        0 === e.strm.avail_out)
                      )
                        return Q;
                    } else (e.match_available = 1), e.strstart++, e.lookahead--;
                  }
                  return (
                    e.match_available &&
                      ((r = b._tr_tally(e, 0, e.window[e.strstart - 1])),
                      (e.match_available = 0)),
                    (e.insert = e.strstart < P - 1 ? e.strstart : P - 1),
                    t === E
                      ? (a(e, !0), 0 === e.strm.avail_out ? X : Y)
                      : e.last_lit && (a(e, !1), 0 === e.strm.avail_out)
                      ? Q
                      : W
                  );
                }
                function p(e, t, n, r, s) {
                  (this.good_length = e),
                    (this.max_lazy = t),
                    (this.nice_length = n),
                    (this.max_chain = r),
                    (this.func = s);
                }
                function f() {
                  (this.strm = null),
                    (this.status = 0),
                    (this.pending_buf = null),
                    (this.pending_buf_size = 0),
                    (this.pending_out = 0),
                    (this.pending = 0),
                    (this.wrap = 0),
                    (this.gzhead = null),
                    (this.gzindex = 0),
                    (this.method = Z),
                    (this.last_flush = -1),
                    (this.w_size = 0),
                    (this.w_bits = 0),
                    (this.w_mask = 0),
                    (this.window = null),
                    (this.window_size = 0),
                    (this.prev = null),
                    (this.head = null),
                    (this.ins_h = 0),
                    (this.hash_size = 0),
                    (this.hash_bits = 0),
                    (this.hash_mask = 0),
                    (this.hash_shift = 0),
                    (this.block_start = 0),
                    (this.match_length = 0),
                    (this.prev_match = 0),
                    (this.match_available = 0),
                    (this.strstart = 0),
                    (this.match_start = 0),
                    (this.lookahead = 0),
                    (this.prev_length = 0),
                    (this.max_chain_length = 0),
                    (this.max_lazy_match = 0),
                    (this.level = 0),
                    (this.strategy = 0),
                    (this.good_match = 0),
                    (this.nice_match = 0),
                    (this.dyn_ltree = new w.Buf16(2 * D)),
                    (this.dyn_dtree = new w.Buf16(2 * (2 * O + 1))),
                    (this.bl_tree = new w.Buf16(2 * (2 * F + 1))),
                    i(this.dyn_ltree),
                    i(this.dyn_dtree),
                    i(this.bl_tree),
                    (this.l_desc = null),
                    (this.d_desc = null),
                    (this.bl_desc = null),
                    (this.bl_count = new w.Buf16(j + 1)),
                    (this.heap = new w.Buf16(2 * B + 1)),
                    i(this.heap),
                    (this.heap_len = 0),
                    (this.heap_max = 0),
                    (this.depth = new w.Buf16(2 * B + 1)),
                    i(this.depth),
                    (this.l_buf = 0),
                    (this.lit_bufsize = 0),
                    (this.last_lit = 0),
                    (this.d_buf = 0),
                    (this.opt_len = 0),
                    (this.static_len = 0),
                    (this.matches = 0),
                    (this.insert = 0),
                    (this.bi_buf = 0),
                    (this.bi_valid = 0);
                }
                function m(e) {
                  var t;
                  return e && e.state
                    ? ((e.total_in = e.total_out = 0),
                      (e.data_type = U),
                      ((t = e.state).pending = 0),
                      (t.pending_out = 0),
                      t.wrap < 0 && (t.wrap = -t.wrap),
                      (t.status = t.wrap ? V : q),
                      (e.adler = 2 === t.wrap ? 0 : 1),
                      (t.last_flush = x),
                      b._tr_init(t),
                      S)
                    : r(e, C);
                }
                function g(e) {
                  var t,
                    n = m(e);
                  return (
                    n === S &&
                      (((t = e.state).window_size = 2 * t.w_size),
                      i(t.head),
                      (t.max_lazy_match = _[t.level].max_lazy),
                      (t.good_match = _[t.level].good_length),
                      (t.nice_match = _[t.level].nice_length),
                      (t.max_chain_length = _[t.level].max_chain),
                      (t.strstart = 0),
                      (t.block_start = 0),
                      (t.lookahead = 0),
                      (t.insert = 0),
                      (t.match_length = t.prev_length = P - 1),
                      (t.match_available = 0),
                      (t.ins_h = 0)),
                    n
                  );
                }
                function v(e, t, n, s, i, o) {
                  if (!e) return C;
                  var a = 1;
                  if (
                    (t === M && (t = 6),
                    s < 0
                      ? ((a = 0), (s = -s))
                      : s > 15 && ((a = 2), (s -= 16)),
                    i < 1 ||
                      i > T ||
                      n !== Z ||
                      s < 8 ||
                      s > 15 ||
                      t < 0 ||
                      t > 9 ||
                      o < 0 ||
                      o > G)
                  )
                    return r(e, C);
                  8 === s && (s = 9);
                  var l = new f();
                  return (
                    (e.state = l),
                    (l.strm = e),
                    (l.wrap = a),
                    (l.gzhead = null),
                    (l.w_bits = s),
                    (l.w_size = 1 << l.w_bits),
                    (l.w_mask = l.w_size - 1),
                    (l.hash_bits = i + 7),
                    (l.hash_size = 1 << l.hash_bits),
                    (l.hash_mask = l.hash_size - 1),
                    (l.hash_shift = ~~((l.hash_bits + P - 1) / P)),
                    (l.window = new w.Buf8(2 * l.w_size)),
                    (l.head = new w.Buf16(l.hash_size)),
                    (l.prev = new w.Buf16(l.w_size)),
                    (l.lit_bufsize = 1 << (i + 6)),
                    (l.pending_buf_size = 4 * l.lit_bufsize),
                    (l.pending_buf = new w.Buf8(l.pending_buf_size)),
                    (l.d_buf = 1 * l.lit_bufsize),
                    (l.l_buf = 3 * l.lit_bufsize),
                    (l.level = t),
                    (l.strategy = o),
                    (l.method = n),
                    g(e)
                  );
                }
                var _,
                  w = e("../utils/common"),
                  b = e("./trees"),
                  y = e("./adler32"),
                  k = e("./crc32"),
                  R = e("./messages"),
                  x = 0,
                  E = 4,
                  S = 0,
                  C = -2,
                  M = -1,
                  I = 1,
                  G = 4,
                  U = 2,
                  Z = 8,
                  T = 9,
                  B = 286,
                  O = 30,
                  F = 19,
                  D = 2 * B + 1,
                  j = 15,
                  P = 3,
                  L = 258,
                  N = L + P + 1,
                  V = 42,
                  z = 103,
                  q = 113,
                  H = 666,
                  Q = 1,
                  W = 2,
                  X = 3,
                  Y = 4;
                (_ = [
                  new p(0, 0, 0, 0, function (e, t) {
                    var n = 65535;
                    for (
                      n > e.pending_buf_size - 5 &&
                      (n = e.pending_buf_size - 5);
                      ;

                    ) {
                      if (e.lookahead <= 1) {
                        if ((A(e), 0 === e.lookahead && t === x)) return Q;
                        if (0 === e.lookahead) break;
                      }
                      (e.strstart += e.lookahead), (e.lookahead = 0);
                      var r = e.block_start + n;
                      if (
                        (0 === e.strstart || e.strstart >= r) &&
                        ((e.lookahead = e.strstart - r),
                        (e.strstart = r),
                        a(e, !1),
                        0 === e.strm.avail_out)
                      )
                        return Q;
                      if (
                        e.strstart - e.block_start >= e.w_size - N &&
                        (a(e, !1), 0 === e.strm.avail_out)
                      )
                        return Q;
                    }
                    return (
                      (e.insert = 0),
                      t === E
                        ? (a(e, !0), 0 === e.strm.avail_out ? X : Y)
                        : (e.strstart > e.block_start &&
                            (a(e, !1), e.strm.avail_out),
                          Q)
                    );
                  }),
                  new p(4, 4, 8, 4, d),
                  new p(4, 5, 16, 8, d),
                  new p(4, 6, 32, 32, d),
                  new p(4, 4, 16, 16, h),
                  new p(8, 16, 32, 32, h),
                  new p(8, 16, 128, 128, h),
                  new p(8, 32, 128, 256, h),
                  new p(32, 128, 258, 1024, h),
                  new p(32, 258, 258, 4096, h),
                ]),
                  (n.deflateInit = function (e, t) {
                    return v(e, t, Z, 15, 8, 0);
                  }),
                  (n.deflateInit2 = v),
                  (n.deflateReset = g),
                  (n.deflateResetKeep = m),
                  (n.deflateSetHeader = function (e, t) {
                    return e && e.state
                      ? 2 !== e.state.wrap
                        ? C
                        : ((e.state.gzhead = t), S)
                      : C;
                  }),
                  (n.deflate = function (e, t) {
                    var n, u, d, h;
                    if (!e || !e.state || t > 5 || t < 0)
                      return e ? r(e, C) : C;
                    if (
                      ((u = e.state),
                      !e.output ||
                        (!e.input && 0 !== e.avail_in) ||
                        (u.status === H && t !== E))
                    )
                      return r(e, 0 === e.avail_out ? -5 : C);
                    if (
                      ((u.strm = e),
                      (n = u.last_flush),
                      (u.last_flush = t),
                      u.status === V)
                    )
                      if (2 === u.wrap)
                        (e.adler = 0),
                          l(u, 31),
                          l(u, 139),
                          l(u, 8),
                          u.gzhead
                            ? (l(
                                u,
                                (u.gzhead.text ? 1 : 0) +
                                  (u.gzhead.hcrc ? 2 : 0) +
                                  (u.gzhead.extra ? 4 : 0) +
                                  (u.gzhead.name ? 8 : 0) +
                                  (u.gzhead.comment ? 16 : 0)
                              ),
                              l(u, 255 & u.gzhead.time),
                              l(u, (u.gzhead.time >> 8) & 255),
                              l(u, (u.gzhead.time >> 16) & 255),
                              l(u, (u.gzhead.time >> 24) & 255),
                              l(
                                u,
                                9 === u.level
                                  ? 2
                                  : u.strategy >= 2 || u.level < 2
                                  ? 4
                                  : 0
                              ),
                              l(u, 255 & u.gzhead.os),
                              u.gzhead.extra &&
                                u.gzhead.extra.length &&
                                (l(u, 255 & u.gzhead.extra.length),
                                l(u, (u.gzhead.extra.length >> 8) & 255)),
                              u.gzhead.hcrc &&
                                (e.adler = k(
                                  e.adler,
                                  u.pending_buf,
                                  u.pending,
                                  0
                                )),
                              (u.gzindex = 0),
                              (u.status = 69))
                            : (l(u, 0),
                              l(u, 0),
                              l(u, 0),
                              l(u, 0),
                              l(u, 0),
                              l(
                                u,
                                9 === u.level
                                  ? 2
                                  : u.strategy >= 2 || u.level < 2
                                  ? 4
                                  : 0
                              ),
                              l(u, 3),
                              (u.status = q));
                      else {
                        var p = (Z + ((u.w_bits - 8) << 4)) << 8;
                        (p |=
                          (u.strategy >= 2 || u.level < 2
                            ? 0
                            : u.level < 6
                            ? 1
                            : 6 === u.level
                            ? 2
                            : 3) << 6),
                          0 !== u.strstart && (p |= 32),
                          (p += 31 - (p % 31)),
                          (u.status = q),
                          c(u, p),
                          0 !== u.strstart &&
                            (c(u, e.adler >>> 16), c(u, 65535 & e.adler)),
                          (e.adler = 1);
                      }
                    if (69 === u.status)
                      if (u.gzhead.extra) {
                        for (
                          d = u.pending;
                          u.gzindex < (65535 & u.gzhead.extra.length) &&
                          (u.pending !== u.pending_buf_size ||
                            (u.gzhead.hcrc &&
                              u.pending > d &&
                              (e.adler = k(
                                e.adler,
                                u.pending_buf,
                                u.pending - d,
                                d
                              )),
                            o(e),
                            (d = u.pending),
                            u.pending !== u.pending_buf_size));

                        )
                          l(u, 255 & u.gzhead.extra[u.gzindex]), u.gzindex++;
                        u.gzhead.hcrc &&
                          u.pending > d &&
                          (e.adler = k(
                            e.adler,
                            u.pending_buf,
                            u.pending - d,
                            d
                          )),
                          u.gzindex === u.gzhead.extra.length &&
                            ((u.gzindex = 0), (u.status = 73));
                      } else u.status = 73;
                    if (73 === u.status)
                      if (u.gzhead.name) {
                        d = u.pending;
                        do {
                          if (
                            u.pending === u.pending_buf_size &&
                            (u.gzhead.hcrc &&
                              u.pending > d &&
                              (e.adler = k(
                                e.adler,
                                u.pending_buf,
                                u.pending - d,
                                d
                              )),
                            o(e),
                            (d = u.pending),
                            u.pending === u.pending_buf_size)
                          ) {
                            h = 1;
                            break;
                          }
                          (h =
                            u.gzindex < u.gzhead.name.length
                              ? 255 & u.gzhead.name.charCodeAt(u.gzindex++)
                              : 0),
                            l(u, h);
                        } while (0 !== h);
                        u.gzhead.hcrc &&
                          u.pending > d &&
                          (e.adler = k(
                            e.adler,
                            u.pending_buf,
                            u.pending - d,
                            d
                          )),
                          0 === h && ((u.gzindex = 0), (u.status = 91));
                      } else u.status = 91;
                    if (91 === u.status)
                      if (u.gzhead.comment) {
                        d = u.pending;
                        do {
                          if (
                            u.pending === u.pending_buf_size &&
                            (u.gzhead.hcrc &&
                              u.pending > d &&
                              (e.adler = k(
                                e.adler,
                                u.pending_buf,
                                u.pending - d,
                                d
                              )),
                            o(e),
                            (d = u.pending),
                            u.pending === u.pending_buf_size)
                          ) {
                            h = 1;
                            break;
                          }
                          (h =
                            u.gzindex < u.gzhead.comment.length
                              ? 255 & u.gzhead.comment.charCodeAt(u.gzindex++)
                              : 0),
                            l(u, h);
                        } while (0 !== h);
                        u.gzhead.hcrc &&
                          u.pending > d &&
                          (e.adler = k(
                            e.adler,
                            u.pending_buf,
                            u.pending - d,
                            d
                          )),
                          0 === h && (u.status = z);
                      } else u.status = z;
                    if (
                      (u.status === z &&
                        (u.gzhead.hcrc
                          ? (u.pending + 2 > u.pending_buf_size && o(e),
                            u.pending + 2 <= u.pending_buf_size &&
                              (l(u, 255 & e.adler),
                              l(u, (e.adler >> 8) & 255),
                              (e.adler = 0),
                              (u.status = q)))
                          : (u.status = q)),
                      0 !== u.pending)
                    ) {
                      if ((o(e), 0 === e.avail_out))
                        return (u.last_flush = -1), S;
                    } else if (0 === e.avail_in && s(t) <= s(n) && t !== E)
                      return r(e, -5);
                    if (u.status === H && 0 !== e.avail_in) return r(e, -5);
                    if (
                      0 !== e.avail_in ||
                      0 !== u.lookahead ||
                      (t !== x && u.status !== H)
                    ) {
                      var f =
                        2 === u.strategy
                          ? (function (e, t) {
                              for (var n; ; ) {
                                if (
                                  0 === e.lookahead &&
                                  (A(e), 0 === e.lookahead)
                                ) {
                                  if (t === x) return Q;
                                  break;
                                }
                                if (
                                  ((e.match_length = 0),
                                  (n = b._tr_tally(e, 0, e.window[e.strstart])),
                                  e.lookahead--,
                                  e.strstart++,
                                  n && (a(e, !1), 0 === e.strm.avail_out))
                                )
                                  return Q;
                              }
                              return (
                                (e.insert = 0),
                                t === E
                                  ? (a(e, !0), 0 === e.strm.avail_out ? X : Y)
                                  : e.last_lit &&
                                    (a(e, !1), 0 === e.strm.avail_out)
                                  ? Q
                                  : W
                              );
                            })(u, t)
                          : 3 === u.strategy
                          ? (function (e, t) {
                              for (var n, r, s, i, o = e.window; ; ) {
                                if (e.lookahead <= L) {
                                  if ((A(e), e.lookahead <= L && t === x))
                                    return Q;
                                  if (0 === e.lookahead) break;
                                }
                                if (
                                  ((e.match_length = 0),
                                  e.lookahead >= P &&
                                    e.strstart > 0 &&
                                    (r = o[(s = e.strstart - 1)]) === o[++s] &&
                                    r === o[++s] &&
                                    r === o[++s])
                                ) {
                                  i = e.strstart + L;
                                  do {} while (
                                    r === o[++s] &&
                                    r === o[++s] &&
                                    r === o[++s] &&
                                    r === o[++s] &&
                                    r === o[++s] &&
                                    r === o[++s] &&
                                    r === o[++s] &&
                                    r === o[++s] &&
                                    s < i
                                  );
                                  (e.match_length = L - (i - s)),
                                    e.match_length > e.lookahead &&
                                      (e.match_length = e.lookahead);
                                }
                                if (
                                  (e.match_length >= P
                                    ? ((n = b._tr_tally(
                                        e,
                                        1,
                                        e.match_length - P
                                      )),
                                      (e.lookahead -= e.match_length),
                                      (e.strstart += e.match_length),
                                      (e.match_length = 0))
                                    : ((n = b._tr_tally(
                                        e,
                                        0,
                                        e.window[e.strstart]
                                      )),
                                      e.lookahead--,
                                      e.strstart++),
                                  n && (a(e, !1), 0 === e.strm.avail_out))
                                )
                                  return Q;
                              }
                              return (
                                (e.insert = 0),
                                t === E
                                  ? (a(e, !0), 0 === e.strm.avail_out ? X : Y)
                                  : e.last_lit &&
                                    (a(e, !1), 0 === e.strm.avail_out)
                                  ? Q
                                  : W
                              );
                            })(u, t)
                          : _[u.level].func(u, t);
                      if (
                        ((f !== X && f !== Y) || (u.status = H),
                        f === Q || f === X)
                      )
                        return 0 === e.avail_out && (u.last_flush = -1), S;
                      if (
                        f === W &&
                        (1 === t
                          ? b._tr_align(u)
                          : 5 !== t &&
                            (b._tr_stored_block(u, 0, 0, !1),
                            3 === t &&
                              (i(u.head),
                              0 === u.lookahead &&
                                ((u.strstart = 0),
                                (u.block_start = 0),
                                (u.insert = 0)))),
                        o(e),
                        0 === e.avail_out)
                      )
                        return (u.last_flush = -1), S;
                    }
                    return t !== E
                      ? S
                      : u.wrap <= 0
                      ? 1
                      : (2 === u.wrap
                          ? (l(u, 255 & e.adler),
                            l(u, (e.adler >> 8) & 255),
                            l(u, (e.adler >> 16) & 255),
                            l(u, (e.adler >> 24) & 255),
                            l(u, 255 & e.total_in),
                            l(u, (e.total_in >> 8) & 255),
                            l(u, (e.total_in >> 16) & 255),
                            l(u, (e.total_in >> 24) & 255))
                          : (c(u, e.adler >>> 16), c(u, 65535 & e.adler)),
                        o(e),
                        u.wrap > 0 && (u.wrap = -u.wrap),
                        0 !== u.pending ? S : 1);
                  }),
                  (n.deflateEnd = function (e) {
                    var t;
                    return e && e.state
                      ? (t = e.state.status) !== V &&
                        69 !== t &&
                        73 !== t &&
                        91 !== t &&
                        t !== z &&
                        t !== q &&
                        t !== H
                        ? r(e, C)
                        : ((e.state = null), t === q ? r(e, -3) : S)
                      : C;
                  }),
                  (n.deflateSetDictionary = function (e, t) {
                    var n,
                      r,
                      s,
                      o,
                      a,
                      l,
                      c,
                      u,
                      d = t.length;
                    if (!e || !e.state) return C;
                    if (
                      2 === (o = (n = e.state).wrap) ||
                      (1 === o && n.status !== V) ||
                      n.lookahead
                    )
                      return C;
                    for (
                      1 === o && (e.adler = y(e.adler, t, d, 0)),
                        n.wrap = 0,
                        d >= n.w_size &&
                          (0 === o &&
                            (i(n.head),
                            (n.strstart = 0),
                            (n.block_start = 0),
                            (n.insert = 0)),
                          (u = new w.Buf8(n.w_size)),
                          w.arraySet(u, t, d - n.w_size, n.w_size, 0),
                          (t = u),
                          (d = n.w_size)),
                        a = e.avail_in,
                        l = e.next_in,
                        c = e.input,
                        e.avail_in = d,
                        e.next_in = 0,
                        e.input = t,
                        A(n);
                      n.lookahead >= P;

                    ) {
                      (r = n.strstart), (s = n.lookahead - (P - 1));
                      do {
                        (n.ins_h =
                          ((n.ins_h << n.hash_shift) ^ n.window[r + P - 1]) &
                          n.hash_mask),
                          (n.prev[r & n.w_mask] = n.head[n.ins_h]),
                          (n.head[n.ins_h] = r),
                          r++;
                      } while (--s);
                      (n.strstart = r), (n.lookahead = P - 1), A(n);
                    }
                    return (
                      (n.strstart += n.lookahead),
                      (n.block_start = n.strstart),
                      (n.insert = n.lookahead),
                      (n.lookahead = 0),
                      (n.match_length = n.prev_length = P - 1),
                      (n.match_available = 0),
                      (e.next_in = l),
                      (e.input = c),
                      (e.avail_in = a),
                      (n.wrap = o),
                      S
                    );
                  }),
                  (n.deflateInfo = "pako deflate (from Nodeca project)");
              },
              {
                "../utils/common": 41,
                "./adler32": 43,
                "./crc32": 45,
                "./messages": 51,
                "./trees": 52,
              },
            ],
            47: [
              function (e, t) {
                "use strict";
                t.exports = function () {
                  (this.text = 0),
                    (this.time = 0),
                    (this.xflags = 0),
                    (this.os = 0),
                    (this.extra = null),
                    (this.extra_len = 0),
                    (this.name = ""),
                    (this.comment = ""),
                    (this.hcrc = 0),
                    (this.done = !1);
                };
              },
              {},
            ],
            48: [
              function (e, t) {
                "use strict";
                t.exports = function (e, t) {
                  var n,
                    r,
                    s,
                    i,
                    o,
                    a,
                    l,
                    c,
                    u,
                    A,
                    d,
                    h,
                    p,
                    f,
                    m,
                    g,
                    v,
                    _,
                    w,
                    b,
                    y,
                    k,
                    R,
                    x,
                    E;
                  (n = e.state),
                    (r = e.next_in),
                    (x = e.input),
                    (s = r + (e.avail_in - 5)),
                    (i = e.next_out),
                    (E = e.output),
                    (o = i - (t - e.avail_out)),
                    (a = i + (e.avail_out - 257)),
                    (l = n.dmax),
                    (c = n.wsize),
                    (u = n.whave),
                    (A = n.wnext),
                    (d = n.window),
                    (h = n.hold),
                    (p = n.bits),
                    (f = n.lencode),
                    (m = n.distcode),
                    (g = (1 << n.lenbits) - 1),
                    (v = (1 << n.distbits) - 1);
                  e: do {
                    p < 15 &&
                      ((h += x[r++] << p),
                      (p += 8),
                      (h += x[r++] << p),
                      (p += 8)),
                      (_ = f[h & g]);
                    t: for (;;) {
                      if (
                        ((h >>>= w = _ >>> 24),
                        (p -= w),
                        0 == (w = (_ >>> 16) & 255))
                      )
                        E[i++] = 65535 & _;
                      else {
                        if (!(16 & w)) {
                          if (0 == (64 & w)) {
                            _ = f[(65535 & _) + (h & ((1 << w) - 1))];
                            continue t;
                          }
                          if (32 & w) {
                            n.mode = 12;
                            break e;
                          }
                          (e.msg = "invalid literal/length code"),
                            (n.mode = 30);
                          break e;
                        }
                        (b = 65535 & _),
                          (w &= 15) &&
                            (p < w && ((h += x[r++] << p), (p += 8)),
                            (b += h & ((1 << w) - 1)),
                            (h >>>= w),
                            (p -= w)),
                          p < 15 &&
                            ((h += x[r++] << p),
                            (p += 8),
                            (h += x[r++] << p),
                            (p += 8)),
                          (_ = m[h & v]);
                        n: for (;;) {
                          if (
                            ((h >>>= w = _ >>> 24),
                            (p -= w),
                            !(16 & (w = (_ >>> 16) & 255)))
                          ) {
                            if (0 == (64 & w)) {
                              _ = m[(65535 & _) + (h & ((1 << w) - 1))];
                              continue n;
                            }
                            (e.msg = "invalid distance code"), (n.mode = 30);
                            break e;
                          }
                          if (
                            ((y = 65535 & _),
                            p < (w &= 15) &&
                              ((h += x[r++] << p),
                              (p += 8) < w && ((h += x[r++] << p), (p += 8))),
                            (y += h & ((1 << w) - 1)) > l)
                          ) {
                            (e.msg = "invalid distance too far back"),
                              (n.mode = 30);
                            break e;
                          }
                          if (((h >>>= w), (p -= w), y > (w = i - o))) {
                            if ((w = y - w) > u && n.sane) {
                              (e.msg = "invalid distance too far back"),
                                (n.mode = 30);
                              break e;
                            }
                            if (((k = 0), (R = d), 0 === A)) {
                              if (((k += c - w), w < b)) {
                                b -= w;
                                do {
                                  E[i++] = d[k++];
                                } while (--w);
                                (k = i - y), (R = E);
                              }
                            } else if (A < w) {
                              if (((k += c + A - w), (w -= A) < b)) {
                                b -= w;
                                do {
                                  E[i++] = d[k++];
                                } while (--w);
                                if (((k = 0), A < b)) {
                                  b -= w = A;
                                  do {
                                    E[i++] = d[k++];
                                  } while (--w);
                                  (k = i - y), (R = E);
                                }
                              }
                            } else if (((k += A - w), w < b)) {
                              b -= w;
                              do {
                                E[i++] = d[k++];
                              } while (--w);
                              (k = i - y), (R = E);
                            }
                            for (; b > 2; )
                              (E[i++] = R[k++]),
                                (E[i++] = R[k++]),
                                (E[i++] = R[k++]),
                                (b -= 3);
                            b &&
                              ((E[i++] = R[k++]), b > 1 && (E[i++] = R[k++]));
                          } else {
                            k = i - y;
                            do {
                              (E[i++] = E[k++]),
                                (E[i++] = E[k++]),
                                (E[i++] = E[k++]),
                                (b -= 3);
                            } while (b > 2);
                            b &&
                              ((E[i++] = E[k++]), b > 1 && (E[i++] = E[k++]));
                          }
                          break;
                        }
                      }
                      break;
                    }
                  } while (r < s && i < a);
                  (r -= b = p >> 3),
                    (h &= (1 << (p -= b << 3)) - 1),
                    (e.next_in = r),
                    (e.next_out = i),
                    (e.avail_in = r < s ? s - r + 5 : 5 - (r - s)),
                    (e.avail_out = i < a ? a - i + 257 : 257 - (i - a)),
                    (n.hold = h),
                    (n.bits = p);
                };
              },
              {},
            ],
            49: [
              function (e, t, n) {
                "use strict";
                function r(e) {
                  return (
                    ((e >>> 24) & 255) +
                    ((e >>> 8) & 65280) +
                    ((65280 & e) << 8) +
                    ((255 & e) << 24)
                  );
                }
                function s() {
                  (this.mode = 0),
                    (this.last = !1),
                    (this.wrap = 0),
                    (this.havedict = !1),
                    (this.flags = 0),
                    (this.dmax = 0),
                    (this.check = 0),
                    (this.total = 0),
                    (this.head = null),
                    (this.wbits = 0),
                    (this.wsize = 0),
                    (this.whave = 0),
                    (this.wnext = 0),
                    (this.window = null),
                    (this.hold = 0),
                    (this.bits = 0),
                    (this.length = 0),
                    (this.offset = 0),
                    (this.extra = 0),
                    (this.lencode = null),
                    (this.distcode = null),
                    (this.lenbits = 0),
                    (this.distbits = 0),
                    (this.ncode = 0),
                    (this.nlen = 0),
                    (this.ndist = 0),
                    (this.have = 0),
                    (this.next = null),
                    (this.lens = new h.Buf16(320)),
                    (this.work = new h.Buf16(288)),
                    (this.lendyn = null),
                    (this.distdyn = null),
                    (this.sane = 0),
                    (this.back = 0),
                    (this.was = 0);
                }
                function i(e) {
                  var t;
                  return e && e.state
                    ? ((t = e.state),
                      (e.total_in = e.total_out = t.total = 0),
                      (e.msg = ""),
                      t.wrap && (e.adler = 1 & t.wrap),
                      (t.mode = y),
                      (t.last = 0),
                      (t.havedict = 0),
                      (t.dmax = 32768),
                      (t.head = null),
                      (t.hold = 0),
                      (t.bits = 0),
                      (t.lencode = t.lendyn = new h.Buf32(x)),
                      (t.distcode = t.distdyn = new h.Buf32(E)),
                      (t.sane = 1),
                      (t.back = -1),
                      w)
                    : b;
                }
                function o(e) {
                  var t;
                  return e && e.state
                    ? (((t = e.state).wsize = 0),
                      (t.whave = 0),
                      (t.wnext = 0),
                      i(e))
                    : b;
                }
                function a(e, t) {
                  var n, r;
                  return e && e.state
                    ? ((r = e.state),
                      t < 0
                        ? ((n = 0), (t = -t))
                        : ((n = 1 + (t >> 4)), t < 48 && (t &= 15)),
                      t && (t < 8 || t > 15)
                        ? b
                        : (null !== r.window &&
                            r.wbits !== t &&
                            (r.window = null),
                          (r.wrap = n),
                          (r.wbits = t),
                          o(e)))
                    : b;
                }
                function l(e, t) {
                  var n, r;
                  return e
                    ? ((r = new s()),
                      (e.state = r),
                      (r.window = null),
                      (n = a(e, t)) !== w && (e.state = null),
                      n)
                    : b;
                }
                function c(e) {
                  if (S) {
                    var t;
                    for (
                      A = new h.Buf32(512), d = new h.Buf32(32), t = 0;
                      t < 144;

                    )
                      e.lens[t++] = 8;
                    for (; t < 256; ) e.lens[t++] = 9;
                    for (; t < 280; ) e.lens[t++] = 7;
                    for (; t < 288; ) e.lens[t++] = 8;
                    for (
                      g(v, e.lens, 0, 288, A, 0, e.work, { bits: 9 }), t = 0;
                      t < 32;

                    )
                      e.lens[t++] = 5;
                    g(_, e.lens, 0, 32, d, 0, e.work, { bits: 5 }), (S = !1);
                  }
                  (e.lencode = A),
                    (e.lenbits = 9),
                    (e.distcode = d),
                    (e.distbits = 5);
                }
                function u(e, t, n, r) {
                  var s,
                    i = e.state;
                  return (
                    null === i.window &&
                      ((i.wsize = 1 << i.wbits),
                      (i.wnext = 0),
                      (i.whave = 0),
                      (i.window = new h.Buf8(i.wsize))),
                    r >= i.wsize
                      ? (h.arraySet(i.window, t, n - i.wsize, i.wsize, 0),
                        (i.wnext = 0),
                        (i.whave = i.wsize))
                      : ((s = i.wsize - i.wnext) > r && (s = r),
                        h.arraySet(i.window, t, n - r, s, i.wnext),
                        (r -= s)
                          ? (h.arraySet(i.window, t, n - r, r, 0),
                            (i.wnext = r),
                            (i.whave = i.wsize))
                          : ((i.wnext += s),
                            i.wnext === i.wsize && (i.wnext = 0),
                            i.whave < i.wsize && (i.whave += s))),
                    0
                  );
                }
                var A,
                  d,
                  h = e("../utils/common"),
                  p = e("./adler32"),
                  f = e("./crc32"),
                  m = e("./inffast"),
                  g = e("./inftrees"),
                  v = 1,
                  _ = 2,
                  w = 0,
                  b = -2,
                  y = 1,
                  k = 12,
                  R = 30,
                  x = 852,
                  E = 592,
                  S = !0;
                (n.inflateReset = o),
                  (n.inflateReset2 = a),
                  (n.inflateResetKeep = i),
                  (n.inflateInit = function (e) {
                    return l(e, 15);
                  }),
                  (n.inflateInit2 = l),
                  (n.inflate = function (e, t) {
                    var n,
                      s,
                      i,
                      o,
                      a,
                      l,
                      A,
                      d,
                      x,
                      E,
                      S,
                      C,
                      M,
                      I,
                      G,
                      U,
                      Z,
                      T,
                      B,
                      O,
                      F,
                      D,
                      j,
                      P,
                      L = 0,
                      N = new h.Buf8(4),
                      V = [
                        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2,
                        14, 1, 15,
                      ];
                    if (
                      !e ||
                      !e.state ||
                      !e.output ||
                      (!e.input && 0 !== e.avail_in)
                    )
                      return b;
                    (n = e.state).mode === k && (n.mode = 13),
                      (a = e.next_out),
                      (i = e.output),
                      (A = e.avail_out),
                      (o = e.next_in),
                      (s = e.input),
                      (l = e.avail_in),
                      (d = n.hold),
                      (x = n.bits),
                      (E = l),
                      (S = A),
                      (D = w);
                    e: for (;;)
                      switch (n.mode) {
                        case y:
                          if (0 === n.wrap) {
                            n.mode = 13;
                            break;
                          }
                          for (; x < 16; ) {
                            if (0 === l) break e;
                            l--, (d += s[o++] << x), (x += 8);
                          }
                          if (2 & n.wrap && 35615 === d) {
                            (n.check = 0),
                              (N[0] = 255 & d),
                              (N[1] = (d >>> 8) & 255),
                              (n.check = f(n.check, N, 2, 0)),
                              (d = 0),
                              (x = 0),
                              (n.mode = 2);
                            break;
                          }
                          if (
                            ((n.flags = 0),
                            n.head && (n.head.done = !1),
                            !(1 & n.wrap) || (((255 & d) << 8) + (d >> 8)) % 31)
                          ) {
                            (e.msg = "incorrect header check"), (n.mode = R);
                            break;
                          }
                          if (8 != (15 & d)) {
                            (e.msg = "unknown compression method"),
                              (n.mode = R);
                            break;
                          }
                          if (
                            ((x -= 4),
                            (F = 8 + (15 & (d >>>= 4))),
                            0 === n.wbits)
                          )
                            n.wbits = F;
                          else if (F > n.wbits) {
                            (e.msg = "invalid window size"), (n.mode = R);
                            break;
                          }
                          (n.dmax = 1 << F),
                            (e.adler = n.check = 1),
                            (n.mode = 512 & d ? 10 : k),
                            (d = 0),
                            (x = 0);
                          break;
                        case 2:
                          for (; x < 16; ) {
                            if (0 === l) break e;
                            l--, (d += s[o++] << x), (x += 8);
                          }
                          if (((n.flags = d), 8 != (255 & n.flags))) {
                            (e.msg = "unknown compression method"),
                              (n.mode = R);
                            break;
                          }
                          if (57344 & n.flags) {
                            (e.msg = "unknown header flags set"), (n.mode = R);
                            break;
                          }
                          n.head && (n.head.text = (d >> 8) & 1),
                            512 & n.flags &&
                              ((N[0] = 255 & d),
                              (N[1] = (d >>> 8) & 255),
                              (n.check = f(n.check, N, 2, 0))),
                            (d = 0),
                            (x = 0),
                            (n.mode = 3);
                        case 3:
                          for (; x < 32; ) {
                            if (0 === l) break e;
                            l--, (d += s[o++] << x), (x += 8);
                          }
                          n.head && (n.head.time = d),
                            512 & n.flags &&
                              ((N[0] = 255 & d),
                              (N[1] = (d >>> 8) & 255),
                              (N[2] = (d >>> 16) & 255),
                              (N[3] = (d >>> 24) & 255),
                              (n.check = f(n.check, N, 4, 0))),
                            (d = 0),
                            (x = 0),
                            (n.mode = 4);
                        case 4:
                          for (; x < 16; ) {
                            if (0 === l) break e;
                            l--, (d += s[o++] << x), (x += 8);
                          }
                          n.head &&
                            ((n.head.xflags = 255 & d), (n.head.os = d >> 8)),
                            512 & n.flags &&
                              ((N[0] = 255 & d),
                              (N[1] = (d >>> 8) & 255),
                              (n.check = f(n.check, N, 2, 0))),
                            (d = 0),
                            (x = 0),
                            (n.mode = 5);
                        case 5:
                          if (1024 & n.flags) {
                            for (; x < 16; ) {
                              if (0 === l) break e;
                              l--, (d += s[o++] << x), (x += 8);
                            }
                            (n.length = d),
                              n.head && (n.head.extra_len = d),
                              512 & n.flags &&
                                ((N[0] = 255 & d),
                                (N[1] = (d >>> 8) & 255),
                                (n.check = f(n.check, N, 2, 0))),
                              (d = 0),
                              (x = 0);
                          } else n.head && (n.head.extra = null);
                          n.mode = 6;
                        case 6:
                          if (
                            1024 & n.flags &&
                            ((C = n.length) > l && (C = l),
                            C &&
                              (n.head &&
                                ((F = n.head.extra_len - n.length),
                                n.head.extra ||
                                  (n.head.extra = new Array(n.head.extra_len)),
                                h.arraySet(n.head.extra, s, o, C, F)),
                              512 & n.flags && (n.check = f(n.check, s, C, o)),
                              (l -= C),
                              (o += C),
                              (n.length -= C)),
                            n.length)
                          )
                            break e;
                          (n.length = 0), (n.mode = 7);
                        case 7:
                          if (2048 & n.flags) {
                            if (0 === l) break e;
                            C = 0;
                            do {
                              (F = s[o + C++]),
                                n.head &&
                                  F &&
                                  n.length < 65536 &&
                                  (n.head.name += String.fromCharCode(F));
                            } while (F && C < l);
                            if (
                              (512 & n.flags && (n.check = f(n.check, s, C, o)),
                              (l -= C),
                              (o += C),
                              F)
                            )
                              break e;
                          } else n.head && (n.head.name = null);
                          (n.length = 0), (n.mode = 8);
                        case 8:
                          if (4096 & n.flags) {
                            if (0 === l) break e;
                            C = 0;
                            do {
                              (F = s[o + C++]),
                                n.head &&
                                  F &&
                                  n.length < 65536 &&
                                  (n.head.comment += String.fromCharCode(F));
                            } while (F && C < l);
                            if (
                              (512 & n.flags && (n.check = f(n.check, s, C, o)),
                              (l -= C),
                              (o += C),
                              F)
                            )
                              break e;
                          } else n.head && (n.head.comment = null);
                          n.mode = 9;
                        case 9:
                          if (512 & n.flags) {
                            for (; x < 16; ) {
                              if (0 === l) break e;
                              l--, (d += s[o++] << x), (x += 8);
                            }
                            if (d !== (65535 & n.check)) {
                              (e.msg = "header crc mismatch"), (n.mode = R);
                              break;
                            }
                            (d = 0), (x = 0);
                          }
                          n.head &&
                            ((n.head.hcrc = (n.flags >> 9) & 1),
                            (n.head.done = !0)),
                            (e.adler = n.check = 0),
                            (n.mode = k);
                          break;
                        case 10:
                          for (; x < 32; ) {
                            if (0 === l) break e;
                            l--, (d += s[o++] << x), (x += 8);
                          }
                          (e.adler = n.check = r(d)),
                            (d = 0),
                            (x = 0),
                            (n.mode = 11);
                        case 11:
                          if (0 === n.havedict)
                            return (
                              (e.next_out = a),
                              (e.avail_out = A),
                              (e.next_in = o),
                              (e.avail_in = l),
                              (n.hold = d),
                              (n.bits = x),
                              2
                            );
                          (e.adler = n.check = 1), (n.mode = k);
                        case k:
                          if (5 === t || 6 === t) break e;
                        case 13:
                          if (n.last) {
                            (d >>>= 7 & x), (x -= 7 & x), (n.mode = 27);
                            break;
                          }
                          for (; x < 3; ) {
                            if (0 === l) break e;
                            l--, (d += s[o++] << x), (x += 8);
                          }
                          switch (
                            ((n.last = 1 & d), (x -= 1), 3 & (d >>>= 1))
                          ) {
                            case 0:
                              n.mode = 14;
                              break;
                            case 1:
                              if ((c(n), (n.mode = 20), 6 === t)) {
                                (d >>>= 2), (x -= 2);
                                break e;
                              }
                              break;
                            case 2:
                              n.mode = 17;
                              break;
                            case 3:
                              (e.msg = "invalid block type"), (n.mode = R);
                          }
                          (d >>>= 2), (x -= 2);
                          break;
                        case 14:
                          for (d >>>= 7 & x, x -= 7 & x; x < 32; ) {
                            if (0 === l) break e;
                            l--, (d += s[o++] << x), (x += 8);
                          }
                          if ((65535 & d) != ((d >>> 16) ^ 65535)) {
                            (e.msg = "invalid stored block lengths"),
                              (n.mode = R);
                            break;
                          }
                          if (
                            ((n.length = 65535 & d),
                            (d = 0),
                            (x = 0),
                            (n.mode = 15),
                            6 === t)
                          )
                            break e;
                        case 15:
                          n.mode = 16;
                        case 16:
                          if ((C = n.length)) {
                            if ((C > l && (C = l), C > A && (C = A), 0 === C))
                              break e;
                            h.arraySet(i, s, o, C, a),
                              (l -= C),
                              (o += C),
                              (A -= C),
                              (a += C),
                              (n.length -= C);
                            break;
                          }
                          n.mode = k;
                          break;
                        case 17:
                          for (; x < 14; ) {
                            if (0 === l) break e;
                            l--, (d += s[o++] << x), (x += 8);
                          }
                          if (
                            ((n.nlen = 257 + (31 & d)),
                            (d >>>= 5),
                            (x -= 5),
                            (n.ndist = 1 + (31 & d)),
                            (d >>>= 5),
                            (x -= 5),
                            (n.ncode = 4 + (15 & d)),
                            (d >>>= 4),
                            (x -= 4),
                            n.nlen > 286 || n.ndist > 30)
                          ) {
                            (e.msg = "too many length or distance symbols"),
                              (n.mode = R);
                            break;
                          }
                          (n.have = 0), (n.mode = 18);
                        case 18:
                          for (; n.have < n.ncode; ) {
                            for (; x < 3; ) {
                              if (0 === l) break e;
                              l--, (d += s[o++] << x), (x += 8);
                            }
                            (n.lens[V[n.have++]] = 7 & d), (d >>>= 3), (x -= 3);
                          }
                          for (; n.have < 19; ) n.lens[V[n.have++]] = 0;
                          if (
                            ((n.lencode = n.lendyn),
                            (n.lenbits = 7),
                            (j = { bits: n.lenbits }),
                            (D = g(0, n.lens, 0, 19, n.lencode, 0, n.work, j)),
                            (n.lenbits = j.bits),
                            D)
                          ) {
                            (e.msg = "invalid code lengths set"), (n.mode = R);
                            break;
                          }
                          (n.have = 0), (n.mode = 19);
                        case 19:
                          for (; n.have < n.nlen + n.ndist; ) {
                            for (
                              ;
                              (U =
                                ((L = n.lencode[d & ((1 << n.lenbits) - 1)]) >>>
                                  16) &
                                255),
                                (Z = 65535 & L),
                                !((G = L >>> 24) <= x);

                            ) {
                              if (0 === l) break e;
                              l--, (d += s[o++] << x), (x += 8);
                            }
                            if (Z < 16)
                              (d >>>= G), (x -= G), (n.lens[n.have++] = Z);
                            else {
                              if (16 === Z) {
                                for (P = G + 2; x < P; ) {
                                  if (0 === l) break e;
                                  l--, (d += s[o++] << x), (x += 8);
                                }
                                if (((d >>>= G), (x -= G), 0 === n.have)) {
                                  (e.msg = "invalid bit length repeat"),
                                    (n.mode = R);
                                  break;
                                }
                                (F = n.lens[n.have - 1]),
                                  (C = 3 + (3 & d)),
                                  (d >>>= 2),
                                  (x -= 2);
                              } else if (17 === Z) {
                                for (P = G + 3; x < P; ) {
                                  if (0 === l) break e;
                                  l--, (d += s[o++] << x), (x += 8);
                                }
                                (x -= G),
                                  (F = 0),
                                  (C = 3 + (7 & (d >>>= G))),
                                  (d >>>= 3),
                                  (x -= 3);
                              } else {
                                for (P = G + 7; x < P; ) {
                                  if (0 === l) break e;
                                  l--, (d += s[o++] << x), (x += 8);
                                }
                                (x -= G),
                                  (F = 0),
                                  (C = 11 + (127 & (d >>>= G))),
                                  (d >>>= 7),
                                  (x -= 7);
                              }
                              if (n.have + C > n.nlen + n.ndist) {
                                (e.msg = "invalid bit length repeat"),
                                  (n.mode = R);
                                break;
                              }
                              for (; C--; ) n.lens[n.have++] = F;
                            }
                          }
                          if (n.mode === R) break;
                          if (0 === n.lens[256]) {
                            (e.msg = "invalid code -- missing end-of-block"),
                              (n.mode = R);
                            break;
                          }
                          if (
                            ((n.lenbits = 9),
                            (j = { bits: n.lenbits }),
                            (D = g(
                              v,
                              n.lens,
                              0,
                              n.nlen,
                              n.lencode,
                              0,
                              n.work,
                              j
                            )),
                            (n.lenbits = j.bits),
                            D)
                          ) {
                            (e.msg = "invalid literal/lengths set"),
                              (n.mode = R);
                            break;
                          }
                          if (
                            ((n.distbits = 6),
                            (n.distcode = n.distdyn),
                            (j = { bits: n.distbits }),
                            (D = g(
                              _,
                              n.lens,
                              n.nlen,
                              n.ndist,
                              n.distcode,
                              0,
                              n.work,
                              j
                            )),
                            (n.distbits = j.bits),
                            D)
                          ) {
                            (e.msg = "invalid distances set"), (n.mode = R);
                            break;
                          }
                          if (((n.mode = 20), 6 === t)) break e;
                        case 20:
                          n.mode = 21;
                        case 21:
                          if (l >= 6 && A >= 258) {
                            (e.next_out = a),
                              (e.avail_out = A),
                              (e.next_in = o),
                              (e.avail_in = l),
                              (n.hold = d),
                              (n.bits = x),
                              m(e, S),
                              (a = e.next_out),
                              (i = e.output),
                              (A = e.avail_out),
                              (o = e.next_in),
                              (s = e.input),
                              (l = e.avail_in),
                              (d = n.hold),
                              (x = n.bits),
                              n.mode === k && (n.back = -1);
                            break;
                          }
                          for (
                            n.back = 0;
                            (U =
                              ((L = n.lencode[d & ((1 << n.lenbits) - 1)]) >>>
                                16) &
                              255),
                              (Z = 65535 & L),
                              !((G = L >>> 24) <= x);

                          ) {
                            if (0 === l) break e;
                            l--, (d += s[o++] << x), (x += 8);
                          }
                          if (U && 0 == (240 & U)) {
                            for (
                              T = G, B = U, O = Z;
                              (U =
                                ((L =
                                  n.lencode[
                                    O + ((d & ((1 << (T + B)) - 1)) >> T)
                                  ]) >>>
                                  16) &
                                255),
                                (Z = 65535 & L),
                                !(T + (G = L >>> 24) <= x);

                            ) {
                              if (0 === l) break e;
                              l--, (d += s[o++] << x), (x += 8);
                            }
                            (d >>>= T), (x -= T), (n.back += T);
                          }
                          if (
                            ((d >>>= G),
                            (x -= G),
                            (n.back += G),
                            (n.length = Z),
                            0 === U)
                          ) {
                            n.mode = 26;
                            break;
                          }
                          if (32 & U) {
                            (n.back = -1), (n.mode = k);
                            break;
                          }
                          if (64 & U) {
                            (e.msg = "invalid literal/length code"),
                              (n.mode = R);
                            break;
                          }
                          (n.extra = 15 & U), (n.mode = 22);
                        case 22:
                          if (n.extra) {
                            for (P = n.extra; x < P; ) {
                              if (0 === l) break e;
                              l--, (d += s[o++] << x), (x += 8);
                            }
                            (n.length += d & ((1 << n.extra) - 1)),
                              (d >>>= n.extra),
                              (x -= n.extra),
                              (n.back += n.extra);
                          }
                          (n.was = n.length), (n.mode = 23);
                        case 23:
                          for (
                            ;
                            (U =
                              ((L = n.distcode[d & ((1 << n.distbits) - 1)]) >>>
                                16) &
                              255),
                              (Z = 65535 & L),
                              !((G = L >>> 24) <= x);

                          ) {
                            if (0 === l) break e;
                            l--, (d += s[o++] << x), (x += 8);
                          }
                          if (0 == (240 & U)) {
                            for (
                              T = G, B = U, O = Z;
                              (U =
                                ((L =
                                  n.distcode[
                                    O + ((d & ((1 << (T + B)) - 1)) >> T)
                                  ]) >>>
                                  16) &
                                255),
                                (Z = 65535 & L),
                                !(T + (G = L >>> 24) <= x);

                            ) {
                              if (0 === l) break e;
                              l--, (d += s[o++] << x), (x += 8);
                            }
                            (d >>>= T), (x -= T), (n.back += T);
                          }
                          if (((d >>>= G), (x -= G), (n.back += G), 64 & U)) {
                            (e.msg = "invalid distance code"), (n.mode = R);
                            break;
                          }
                          (n.offset = Z), (n.extra = 15 & U), (n.mode = 24);
                        case 24:
                          if (n.extra) {
                            for (P = n.extra; x < P; ) {
                              if (0 === l) break e;
                              l--, (d += s[o++] << x), (x += 8);
                            }
                            (n.offset += d & ((1 << n.extra) - 1)),
                              (d >>>= n.extra),
                              (x -= n.extra),
                              (n.back += n.extra);
                          }
                          if (n.offset > n.dmax) {
                            (e.msg = "invalid distance too far back"),
                              (n.mode = R);
                            break;
                          }
                          n.mode = 25;
                        case 25:
                          if (0 === A) break e;
                          if (((C = S - A), n.offset > C)) {
                            if ((C = n.offset - C) > n.whave && n.sane) {
                              (e.msg = "invalid distance too far back"),
                                (n.mode = R);
                              break;
                            }
                            C > n.wnext
                              ? ((C -= n.wnext), (M = n.wsize - C))
                              : (M = n.wnext - C),
                              C > n.length && (C = n.length),
                              (I = n.window);
                          } else (I = i), (M = a - n.offset), (C = n.length);
                          C > A && (C = A), (A -= C), (n.length -= C);
                          do {
                            i[a++] = I[M++];
                          } while (--C);
                          0 === n.length && (n.mode = 21);
                          break;
                        case 26:
                          if (0 === A) break e;
                          (i[a++] = n.length), A--, (n.mode = 21);
                          break;
                        case 27:
                          if (n.wrap) {
                            for (; x < 32; ) {
                              if (0 === l) break e;
                              l--, (d |= s[o++] << x), (x += 8);
                            }
                            if (
                              ((S -= A),
                              (e.total_out += S),
                              (n.total += S),
                              S &&
                                (e.adler = n.check =
                                  n.flags
                                    ? f(n.check, i, S, a - S)
                                    : p(n.check, i, S, a - S)),
                              (S = A),
                              (n.flags ? d : r(d)) !== n.check)
                            ) {
                              (e.msg = "incorrect data check"), (n.mode = R);
                              break;
                            }
                            (d = 0), (x = 0);
                          }
                          n.mode = 28;
                        case 28:
                          if (n.wrap && n.flags) {
                            for (; x < 32; ) {
                              if (0 === l) break e;
                              l--, (d += s[o++] << x), (x += 8);
                            }
                            if (d !== (4294967295 & n.total)) {
                              (e.msg = "incorrect length check"), (n.mode = R);
                              break;
                            }
                            (d = 0), (x = 0);
                          }
                          n.mode = 29;
                        case 29:
                          D = 1;
                          break e;
                        case R:
                          D = -3;
                          break e;
                        case 31:
                          return -4;
                        default:
                          return b;
                      }
                    return (
                      (e.next_out = a),
                      (e.avail_out = A),
                      (e.next_in = o),
                      (e.avail_in = l),
                      (n.hold = d),
                      (n.bits = x),
                      (n.wsize ||
                        (S !== e.avail_out &&
                          n.mode < R &&
                          (n.mode < 27 || 4 !== t))) &&
                      u(e, e.output, e.next_out, S - e.avail_out)
                        ? ((n.mode = 31), -4)
                        : ((E -= e.avail_in),
                          (S -= e.avail_out),
                          (e.total_in += E),
                          (e.total_out += S),
                          (n.total += S),
                          n.wrap &&
                            S &&
                            (e.adler = n.check =
                              n.flags
                                ? f(n.check, i, S, e.next_out - S)
                                : p(n.check, i, S, e.next_out - S)),
                          (e.data_type =
                            n.bits +
                            (n.last ? 64 : 0) +
                            (n.mode === k ? 128 : 0) +
                            (20 === n.mode || 15 === n.mode ? 256 : 0)),
                          ((0 === E && 0 === S) || 4 === t) &&
                            D === w &&
                            (D = -5),
                          D)
                    );
                  }),
                  (n.inflateEnd = function (e) {
                    if (!e || !e.state) return b;
                    var t = e.state;
                    return t.window && (t.window = null), (e.state = null), w;
                  }),
                  (n.inflateGetHeader = function (e, t) {
                    var n;
                    return e && e.state
                      ? 0 == (2 & (n = e.state).wrap)
                        ? b
                        : ((n.head = t), (t.done = !1), w)
                      : b;
                  }),
                  (n.inflateSetDictionary = function (e, t) {
                    var n,
                      r = t.length;
                    return e && e.state
                      ? 0 !== (n = e.state).wrap && 11 !== n.mode
                        ? b
                        : 11 === n.mode && p(1, t, r, 0) !== n.check
                        ? -3
                        : u(e, t, r, r)
                        ? ((n.mode = 31), -4)
                        : ((n.havedict = 1), w)
                      : b;
                  }),
                  (n.inflateInfo = "pako inflate (from Nodeca project)");
              },
              {
                "../utils/common": 41,
                "./adler32": 43,
                "./crc32": 45,
                "./inffast": 48,
                "./inftrees": 50,
              },
            ],
            50: [
              function (e, t) {
                "use strict";
                var n = e("../utils/common"),
                  r = [
                    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35,
                    43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0,
                  ],
                  s = [
                    16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18,
                    18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72,
                    78,
                  ],
                  i = [
                    1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
                    257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
                    8193, 12289, 16385, 24577, 0, 0,
                  ],
                  o = [
                    16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22,
                    22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29,
                    64, 64,
                  ];
                t.exports = function (e, t, a, l, c, u, A, d) {
                  var h,
                    p,
                    f,
                    m,
                    g,
                    v,
                    _,
                    w,
                    b,
                    y = d.bits,
                    k = 0,
                    R = 0,
                    x = 0,
                    E = 0,
                    S = 0,
                    C = 0,
                    M = 0,
                    I = 0,
                    G = 0,
                    U = 0,
                    Z = null,
                    T = 0,
                    B = new n.Buf16(16),
                    O = new n.Buf16(16),
                    F = null,
                    D = 0;
                  for (k = 0; k <= 15; k++) B[k] = 0;
                  for (R = 0; R < l; R++) B[t[a + R]]++;
                  for (S = y, E = 15; E >= 1 && 0 === B[E]; E--);
                  if ((S > E && (S = E), 0 === E))
                    return (
                      (c[u++] = 20971520), (c[u++] = 20971520), (d.bits = 1), 0
                    );
                  for (x = 1; x < E && 0 === B[x]; x++);
                  for (S < x && (S = x), I = 1, k = 1; k <= 15; k++)
                    if (((I <<= 1), (I -= B[k]) < 0)) return -1;
                  if (I > 0 && (0 === e || 1 !== E)) return -1;
                  for (O[1] = 0, k = 1; k < 15; k++) O[k + 1] = O[k] + B[k];
                  for (R = 0; R < l; R++)
                    0 !== t[a + R] && (A[O[t[a + R]]++] = R);
                  if (
                    (0 === e
                      ? ((Z = F = A), (v = 19))
                      : 1 === e
                      ? ((Z = r), (T -= 257), (F = s), (D -= 257), (v = 256))
                      : ((Z = i), (F = o), (v = -1)),
                    (U = 0),
                    (R = 0),
                    (k = x),
                    (g = u),
                    (C = S),
                    (M = 0),
                    (f = -1),
                    (m = (G = 1 << S) - 1),
                    (1 === e && G > 852) || (2 === e && G > 592))
                  )
                    return 1;
                  for (;;) {
                    (_ = k - M),
                      A[R] < v
                        ? ((w = 0), (b = A[R]))
                        : A[R] > v
                        ? ((w = F[D + A[R]]), (b = Z[T + A[R]]))
                        : ((w = 96), (b = 0)),
                      (h = 1 << (k - M)),
                      (x = p = 1 << C);
                    do {
                      c[g + (U >> M) + (p -= h)] =
                        (_ << 24) | (w << 16) | b | 0;
                    } while (0 !== p);
                    for (h = 1 << (k - 1); U & h; ) h >>= 1;
                    if (
                      (0 !== h ? ((U &= h - 1), (U += h)) : (U = 0),
                      R++,
                      0 == --B[k])
                    ) {
                      if (k === E) break;
                      k = t[a + A[R]];
                    }
                    if (k > S && (U & m) !== f) {
                      for (
                        0 === M && (M = S), g += x, I = 1 << (C = k - M);
                        C + M < E && !((I -= B[C + M]) <= 0);

                      )
                        C++, (I <<= 1);
                      if (
                        ((G += 1 << C),
                        (1 === e && G > 852) || (2 === e && G > 592))
                      )
                        return 1;
                      c[(f = U & m)] = (S << 24) | (C << 16) | (g - u) | 0;
                    }
                  }
                  return (
                    0 !== U && (c[g + U] = ((k - M) << 24) | (64 << 16) | 0),
                    (d.bits = S),
                    0
                  );
                };
              },
              { "../utils/common": 41 },
            ],
            51: [
              function (e, t) {
                "use strict";
                t.exports = {
                  2: "need dictionary",
                  1: "stream end",
                  0: "",
                  "-1": "file error",
                  "-2": "stream error",
                  "-3": "data error",
                  "-4": "insufficient memory",
                  "-5": "buffer error",
                  "-6": "incompatible version",
                };
              },
              {},
            ],
            52: [
              function (e, t, n) {
                "use strict";
                function r(e) {
                  for (var t = e.length; --t >= 0; ) e[t] = 0;
                }
                function s(e, t, n, r, s) {
                  (this.static_tree = e),
                    (this.extra_bits = t),
                    (this.extra_base = n),
                    (this.elems = r),
                    (this.max_length = s),
                    (this.has_stree = e && e.length);
                }
                function i(e, t) {
                  (this.dyn_tree = e),
                    (this.max_code = 0),
                    (this.stat_desc = t);
                }
                function o(e) {
                  return e < 256 ? P[e] : P[256 + (e >>> 7)];
                }
                function a(e, t) {
                  (e.pending_buf[e.pending++] = 255 & t),
                    (e.pending_buf[e.pending++] = (t >>> 8) & 255);
                }
                function l(e, t, n) {
                  e.bi_valid > M - n
                    ? ((e.bi_buf |= (t << e.bi_valid) & 65535),
                      a(e, e.bi_buf),
                      (e.bi_buf = t >> (M - e.bi_valid)),
                      (e.bi_valid += n - M))
                    : ((e.bi_buf |= (t << e.bi_valid) & 65535),
                      (e.bi_valid += n));
                }
                function c(e, t, n) {
                  l(e, n[2 * t], n[2 * t + 1]);
                }
                function u(e, t) {
                  var n = 0;
                  do {
                    (n |= 1 & e), (e >>>= 1), (n <<= 1);
                  } while (--t > 0);
                  return n >>> 1;
                }
                function A(e, t, n) {
                  var r,
                    s,
                    i = new Array(C + 1),
                    o = 0;
                  for (r = 1; r <= C; r++) i[r] = o = (o + n[r - 1]) << 1;
                  for (s = 0; s <= t; s++) {
                    var a = e[2 * s + 1];
                    0 !== a && (e[2 * s] = u(i[a]++, a));
                  }
                }
                function d(e) {
                  var t;
                  for (t = 0; t < R; t++) e.dyn_ltree[2 * t] = 0;
                  for (t = 0; t < x; t++) e.dyn_dtree[2 * t] = 0;
                  for (t = 0; t < E; t++) e.bl_tree[2 * t] = 0;
                  (e.dyn_ltree[2 * I] = 1),
                    (e.opt_len = e.static_len = 0),
                    (e.last_lit = e.matches = 0);
                }
                function h(e) {
                  e.bi_valid > 8
                    ? a(e, e.bi_buf)
                    : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf),
                    (e.bi_buf = 0),
                    (e.bi_valid = 0);
                }
                function p(e, t, n, r) {
                  var s = 2 * t,
                    i = 2 * n;
                  return e[s] < e[i] || (e[s] === e[i] && r[t] <= r[n]);
                }
                function f(e, t, n) {
                  for (
                    var r = e.heap[n], s = n << 1;
                    s <= e.heap_len &&
                    (s < e.heap_len &&
                      p(t, e.heap[s + 1], e.heap[s], e.depth) &&
                      s++,
                    !p(t, r, e.heap[s], e.depth));

                  )
                    (e.heap[n] = e.heap[s]), (n = s), (s <<= 1);
                  e.heap[n] = r;
                }
                function m(e, t, n) {
                  var r,
                    s,
                    i,
                    a,
                    u = 0;
                  if (0 !== e.last_lit)
                    do {
                      (r =
                        (e.pending_buf[e.d_buf + 2 * u] << 8) |
                        e.pending_buf[e.d_buf + 2 * u + 1]),
                        (s = e.pending_buf[e.l_buf + u]),
                        u++,
                        0 === r
                          ? c(e, s, t)
                          : (c(e, (i = L[s]) + k + 1, t),
                            0 !== (a = T[i]) && l(e, (s -= N[i]), a),
                            c(e, (i = o(--r)), n),
                            0 !== (a = B[i]) && l(e, (r -= H[i]), a));
                    } while (u < e.last_lit);
                  c(e, I, t);
                }
                function g(e, t) {
                  var n,
                    r,
                    s,
                    i = t.dyn_tree,
                    o = t.stat_desc.static_tree,
                    a = t.stat_desc.has_stree,
                    l = t.stat_desc.elems,
                    c = -1;
                  for (e.heap_len = 0, e.heap_max = S, n = 0; n < l; n++)
                    0 !== i[2 * n]
                      ? ((e.heap[++e.heap_len] = c = n), (e.depth[n] = 0))
                      : (i[2 * n + 1] = 0);
                  for (; e.heap_len < 2; )
                    (i[2 * (s = e.heap[++e.heap_len] = c < 2 ? ++c : 0)] = 1),
                      (e.depth[s] = 0),
                      e.opt_len--,
                      a && (e.static_len -= o[2 * s + 1]);
                  for (t.max_code = c, n = e.heap_len >> 1; n >= 1; n--)
                    f(e, i, n);
                  s = l;
                  do {
                    (n = e.heap[1]),
                      (e.heap[1] = e.heap[e.heap_len--]),
                      f(e, i, 1),
                      (r = e.heap[1]),
                      (e.heap[--e.heap_max] = n),
                      (e.heap[--e.heap_max] = r),
                      (i[2 * s] = i[2 * n] + i[2 * r]),
                      (e.depth[s] =
                        (e.depth[n] >= e.depth[r] ? e.depth[n] : e.depth[r]) +
                        1),
                      (i[2 * n + 1] = i[2 * r + 1] = s),
                      (e.heap[1] = s++),
                      f(e, i, 1);
                  } while (e.heap_len >= 2);
                  (e.heap[--e.heap_max] = e.heap[1]),
                    (function (e, t) {
                      var n,
                        r,
                        s,
                        i,
                        o,
                        a,
                        l = t.dyn_tree,
                        c = t.max_code,
                        u = t.stat_desc.static_tree,
                        A = t.stat_desc.has_stree,
                        d = t.stat_desc.extra_bits,
                        h = t.stat_desc.extra_base,
                        p = t.stat_desc.max_length,
                        f = 0;
                      for (i = 0; i <= C; i++) e.bl_count[i] = 0;
                      for (
                        l[2 * e.heap[e.heap_max] + 1] = 0, n = e.heap_max + 1;
                        n < S;
                        n++
                      )
                        (i = l[2 * l[2 * (r = e.heap[n]) + 1] + 1] + 1) > p &&
                          ((i = p), f++),
                          (l[2 * r + 1] = i),
                          r > c ||
                            (e.bl_count[i]++,
                            (o = 0),
                            r >= h && (o = d[r - h]),
                            (a = l[2 * r]),
                            (e.opt_len += a * (i + o)),
                            A && (e.static_len += a * (u[2 * r + 1] + o)));
                      if (0 !== f) {
                        do {
                          for (i = p - 1; 0 === e.bl_count[i]; ) i--;
                          e.bl_count[i]--,
                            (e.bl_count[i + 1] += 2),
                            e.bl_count[p]--,
                            (f -= 2);
                        } while (f > 0);
                        for (i = p; 0 !== i; i--)
                          for (r = e.bl_count[i]; 0 !== r; )
                            (s = e.heap[--n]) > c ||
                              (l[2 * s + 1] !== i &&
                                ((e.opt_len += (i - l[2 * s + 1]) * l[2 * s]),
                                (l[2 * s + 1] = i)),
                              r--);
                      }
                    })(e, t),
                    A(i, c, e.bl_count);
                }
                function v(e, t, n) {
                  var r,
                    s,
                    i = -1,
                    o = t[1],
                    a = 0,
                    l = 7,
                    c = 4;
                  for (
                    0 === o && ((l = 138), (c = 3)),
                      t[2 * (n + 1) + 1] = 65535,
                      r = 0;
                    r <= n;
                    r++
                  )
                    (s = o),
                      (o = t[2 * (r + 1) + 1]),
                      (++a < l && s === o) ||
                        (a < c
                          ? (e.bl_tree[2 * s] += a)
                          : 0 !== s
                          ? (s !== i && e.bl_tree[2 * s]++, e.bl_tree[2 * G]++)
                          : a <= 10
                          ? e.bl_tree[2 * U]++
                          : e.bl_tree[2 * Z]++,
                        (a = 0),
                        (i = s),
                        0 === o
                          ? ((l = 138), (c = 3))
                          : s === o
                          ? ((l = 6), (c = 3))
                          : ((l = 7), (c = 4)));
                }
                function _(e, t, n) {
                  var r,
                    s,
                    i = -1,
                    o = t[1],
                    a = 0,
                    u = 7,
                    A = 4;
                  for (0 === o && ((u = 138), (A = 3)), r = 0; r <= n; r++)
                    if (
                      ((s = o), (o = t[2 * (r + 1) + 1]), !(++a < u && s === o))
                    ) {
                      if (a < A)
                        do {
                          c(e, s, e.bl_tree);
                        } while (0 != --a);
                      else
                        0 !== s
                          ? (s !== i && (c(e, s, e.bl_tree), a--),
                            c(e, G, e.bl_tree),
                            l(e, a - 3, 2))
                          : a <= 10
                          ? (c(e, U, e.bl_tree), l(e, a - 3, 3))
                          : (c(e, Z, e.bl_tree), l(e, a - 11, 7));
                      (a = 0),
                        (i = s),
                        0 === o
                          ? ((u = 138), (A = 3))
                          : s === o
                          ? ((u = 6), (A = 3))
                          : ((u = 7), (A = 4));
                    }
                }
                function w(e, t, n, r) {
                  l(e, (y << 1) + (r ? 1 : 0), 3),
                    (function (e, t, n) {
                      h(e),
                        a(e, n),
                        a(e, ~n),
                        b.arraySet(e.pending_buf, e.window, t, n, e.pending),
                        (e.pending += n);
                    })(e, t, n);
                }
                var b = e("../utils/common"),
                  y = 0,
                  k = 256,
                  R = k + 1 + 29,
                  x = 30,
                  E = 19,
                  S = 2 * R + 1,
                  C = 15,
                  M = 16,
                  I = 256,
                  G = 16,
                  U = 17,
                  Z = 18,
                  T = [
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3,
                    4, 4, 4, 4, 5, 5, 5, 5, 0,
                  ],
                  B = [
                    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8,
                    9, 9, 10, 10, 11, 11, 12, 12, 13, 13,
                  ],
                  O = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
                  F = [
                    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14,
                    1, 15,
                  ],
                  D = new Array(2 * (R + 2));
                r(D);
                var j = new Array(2 * x);
                r(j);
                var P = new Array(512);
                r(P);
                var L = new Array(256);
                r(L);
                var N = new Array(29);
                r(N);
                var V,
                  z,
                  q,
                  H = new Array(x);
                r(H);
                var Q = !1;
                (n._tr_init = function (e) {
                  Q ||
                    ((function () {
                      var e,
                        t,
                        n,
                        r,
                        i,
                        o = new Array(C + 1);
                      for (n = 0, r = 0; r < 28; r++)
                        for (N[r] = n, e = 0; e < 1 << T[r]; e++) L[n++] = r;
                      for (L[n - 1] = r, i = 0, r = 0; r < 16; r++)
                        for (H[r] = i, e = 0; e < 1 << B[r]; e++) P[i++] = r;
                      for (i >>= 7; r < x; r++)
                        for (H[r] = i << 7, e = 0; e < 1 << (B[r] - 7); e++)
                          P[256 + i++] = r;
                      for (t = 0; t <= C; t++) o[t] = 0;
                      for (e = 0; e <= 143; ) (D[2 * e + 1] = 8), e++, o[8]++;
                      for (; e <= 255; ) (D[2 * e + 1] = 9), e++, o[9]++;
                      for (; e <= 279; ) (D[2 * e + 1] = 7), e++, o[7]++;
                      for (; e <= 287; ) (D[2 * e + 1] = 8), e++, o[8]++;
                      for (A(D, R + 1, o), e = 0; e < x; e++)
                        (j[2 * e + 1] = 5), (j[2 * e] = u(e, 5));
                      (V = new s(D, T, k + 1, R, C)),
                        (z = new s(j, B, 0, x, C)),
                        (q = new s(new Array(0), O, 0, E, 7));
                    })(),
                    (Q = !0)),
                    (e.l_desc = new i(e.dyn_ltree, V)),
                    (e.d_desc = new i(e.dyn_dtree, z)),
                    (e.bl_desc = new i(e.bl_tree, q)),
                    (e.bi_buf = 0),
                    (e.bi_valid = 0),
                    d(e);
                }),
                  (n._tr_stored_block = w),
                  (n._tr_flush_block = function (e, t, n, r) {
                    var s,
                      i,
                      o = 0;
                    e.level > 0
                      ? (2 === e.strm.data_type &&
                          (e.strm.data_type = (function (e) {
                            var t,
                              n = 4093624447;
                            for (t = 0; t <= 31; t++, n >>>= 1)
                              if (1 & n && 0 !== e.dyn_ltree[2 * t]) return 0;
                            if (
                              0 !== e.dyn_ltree[18] ||
                              0 !== e.dyn_ltree[20] ||
                              0 !== e.dyn_ltree[26]
                            )
                              return 1;
                            for (t = 32; t < k; t++)
                              if (0 !== e.dyn_ltree[2 * t]) return 1;
                            return 0;
                          })(e)),
                        g(e, e.l_desc),
                        g(e, e.d_desc),
                        (o = (function (e) {
                          var t;
                          for (
                            v(e, e.dyn_ltree, e.l_desc.max_code),
                              v(e, e.dyn_dtree, e.d_desc.max_code),
                              g(e, e.bl_desc),
                              t = E - 1;
                            t >= 3 && 0 === e.bl_tree[2 * F[t] + 1];
                            t--
                          );
                          return (e.opt_len += 3 * (t + 1) + 5 + 5 + 4), t;
                        })(e)),
                        (s = (e.opt_len + 3 + 7) >>> 3),
                        (i = (e.static_len + 3 + 7) >>> 3) <= s && (s = i))
                      : (s = i = n + 5),
                      n + 4 <= s && -1 !== t
                        ? w(e, t, n, r)
                        : 4 === e.strategy || i === s
                        ? (l(e, 2 + (r ? 1 : 0), 3), m(e, D, j))
                        : (l(e, 4 + (r ? 1 : 0), 3),
                          (function (e, t, n, r) {
                            var s;
                            for (
                              l(e, t - 257, 5),
                                l(e, n - 1, 5),
                                l(e, r - 4, 4),
                                s = 0;
                              s < r;
                              s++
                            )
                              l(e, e.bl_tree[2 * F[s] + 1], 3);
                            _(e, e.dyn_ltree, t - 1), _(e, e.dyn_dtree, n - 1);
                          })(
                            e,
                            e.l_desc.max_code + 1,
                            e.d_desc.max_code + 1,
                            o + 1
                          ),
                          m(e, e.dyn_ltree, e.dyn_dtree)),
                      d(e),
                      r && h(e);
                  }),
                  (n._tr_tally = function (e, t, n) {
                    return (
                      (e.pending_buf[e.d_buf + 2 * e.last_lit] =
                        (t >>> 8) & 255),
                      (e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & t),
                      (e.pending_buf[e.l_buf + e.last_lit] = 255 & n),
                      e.last_lit++,
                      0 === t
                        ? e.dyn_ltree[2 * n]++
                        : (e.matches++,
                          t--,
                          e.dyn_ltree[2 * (L[n] + k + 1)]++,
                          e.dyn_dtree[2 * o(t)]++),
                      e.last_lit === e.lit_bufsize - 1
                    );
                  }),
                  (n._tr_align = function (e) {
                    l(e, 2, 3),
                      c(e, I, D),
                      (function (e) {
                        16 === e.bi_valid
                          ? (a(e, e.bi_buf), (e.bi_buf = 0), (e.bi_valid = 0))
                          : e.bi_valid >= 8 &&
                            ((e.pending_buf[e.pending++] = 255 & e.bi_buf),
                            (e.bi_buf >>= 8),
                            (e.bi_valid -= 8));
                      })(e);
                  });
              },
              { "../utils/common": 41 },
            ],
            53: [
              function (e, t) {
                "use strict";
                t.exports = function () {
                  (this.input = null),
                    (this.next_in = 0),
                    (this.avail_in = 0),
                    (this.total_in = 0),
                    (this.output = null),
                    (this.next_out = 0),
                    (this.avail_out = 0),
                    (this.total_out = 0),
                    (this.msg = ""),
                    (this.state = null),
                    (this.data_type = 2),
                    (this.adler = 0);
                };
              },
              {},
            ],
            54: [
              function (e, t) {
                "use strict";
                t.exports =
                  "function" == typeof setImmediate
                    ? setImmediate
                    : function () {
                        var e = [].slice.apply(arguments);
                        e.splice(1, 0, 0), setTimeout.apply(null, e);
                      };
              },
              {},
            ],
          },
          {},
          [10]
        )(10);
      },
    },
    n = {};
  (e.n = (t) => {
    var n = t && t.__esModule ? () => t.default : () => t;
    return e.d(n, { a: n }), n;
  }),
    (e.d = (t, n) => {
      for (var r in n)
        e.o(n, r) &&
          !e.o(t, r) &&
          Object.defineProperty(t, r, { enumerable: !0, get: n[r] });
    }),
    (e.g = (function () {
      if ("object" == typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (e) {
        if ("object" == typeof window) return window;
      }
    })()),
    (e.o = (e, t) => ({}.hasOwnProperty.call(e, t))),
    (() => {
      "use strict";
      function t(e) {
        if (((this.data = ""), (this.read = 0), "string" == typeof e))
          this.data = e;
        else if (Gi.isArrayBuffer(e) || Gi.isArrayBufferView(e)) {
          var n = new Uint8Array(e);
          try {
            this.data = String.fromCharCode.apply(null, n);
          } catch (e) {
            for (var r = 0; r < n.length; ++r) this.putByte(n[r]);
          }
        } else
          (e instanceof t ||
            ("object" == typeof e &&
              "string" == typeof e.data &&
              "number" == typeof e.read)) &&
            ((this.data = e.data), (this.read = e.read));
        this._constructedStringLength = 0;
      }
      function n(e, t, n) {
        for (
          var r, s, i, o, a, l, c, u, A, d, h, p, f, m = n.length();
          m >= 64;

        ) {
          for (a = 0; a < 16; ++a) t[a] = n.getInt32();
          for (; a < 64; ++a)
            (r =
              (((r = t[a - 2]) >>> 17) | (r << 15)) ^
              ((r >>> 19) | (r << 13)) ^
              (r >>> 10)),
              (s =
                (((s = t[a - 15]) >>> 7) | (s << 25)) ^
                ((s >>> 18) | (s << 14)) ^
                (s >>> 3)),
              (t[a] = (r + t[a - 7] + s + t[a - 16]) | 0);
          for (
            l = e.h0,
              c = e.h1,
              u = e.h2,
              A = e.h3,
              d = e.h4,
              h = e.h5,
              p = e.h6,
              f = e.h7,
              a = 0;
            a < 64;
            ++a
          )
            (i =
              ((l >>> 2) | (l << 30)) ^
              ((l >>> 13) | (l << 19)) ^
              ((l >>> 22) | (l << 10))),
              (o = (l & c) | (u & (l ^ c))),
              (r =
                f +
                (((d >>> 6) | (d << 26)) ^
                  ((d >>> 11) | (d << 21)) ^
                  ((d >>> 25) | (d << 7))) +
                (p ^ (d & (h ^ p))) +
                Bi[a] +
                t[a]),
              (f = p),
              (p = h),
              (h = d),
              (d = (A + r) | 0),
              (A = u),
              (u = c),
              (c = l),
              (l = (r + (s = i + o)) | 0);
          (e.h0 = (e.h0 + l) | 0),
            (e.h1 = (e.h1 + c) | 0),
            (e.h2 = (e.h2 + u) | 0),
            (e.h3 = (e.h3 + A) | 0),
            (e.h4 = (e.h4 + d) | 0),
            (e.h5 = (e.h5 + h) | 0),
            (e.h6 = (e.h6 + p) | 0),
            (e.h7 = (e.h7 + f) | 0),
            (m -= 64);
        }
      }
      function r(e, t) {
        return e.toLowerCase() === t.toLowerCase();
      }
      function s(e) {
        let t = "";
        const n = (e) =>
          l(e)
            ? parseInt(e, 10)
            : e >= "A" && e <= "F"
            ? e.charCodeAt(0) - "A".charCodeAt(0) + 10
            : e.charCodeAt(0) - "a".charCodeAt(0) + 10;
        let r = 0;
        for (; r < e.length; ) {
          if ("%" !== e[r]) {
            (t += e[r]), r++;
            continue;
          }
          const s = e[r + 1],
            i = e[r + 2];
          r + 2 >= e.length || !c(s) || !c(i)
            ? ((t += "%"), r++)
            : ((t += String.fromCharCode((n(s) << 4) + n(i))), (r += 3));
        }
        return t;
      }
      function i(e) {
        return e.replace(
          /([^\x20-\x7E]|[,;])/g,
          (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`
        );
      }
      function o(e) {
        return (
          "\t" === e || "\n" === e || "\f" === e || "\r" === e || " " === e
        );
      }
      function a(e) {
        return (e >= "a" && e <= "z") || (e >= "A" && e <= "Z");
      }
      function l(e) {
        return e >= "0" && e <= "9";
      }
      function c(e) {
        return (
          void 0 !== e &&
          (l(e) || (e >= "A" && e <= "F") || (e >= "a" && e <= "f"))
        );
      }
      function u(e) {
        if (
          (e.endsWith("=") && (e = e.substring(0, e.length - 1)),
          e.endsWith("=") && (e = e.substring(0, e.length - 1)),
          0 === e.length)
        )
          return !1;
        for (const t of e)
          if (!a(t) && !l(t) && "+" !== t && t !== wu && t !== bu && "_" !== t)
            return !1;
        return !0;
      }
      function A(e, t) {
        const n = e.GetCspNonce();
        if (!n) return !1;
        for (const e of t) if (e.isNonce() && e.getNonce() === n) return !0;
        return !1;
      }
      function d(e, t) {
        return e.toLowerCase() === t;
      }
      function h(e, t, n, r, s) {
        const i = t.scheme;
        if (!e) return !0;
        if (e === i) return !0;
        if ("http" === e) {
          if ("https" === i) return !0;
          if (("ws" === i || "wss" === i) && s) return !0;
        }
        return (
          !("https" !== e || "wss" !== i || !s) ||
          ("ws" === e && "wss" === i) ||
          (r &&
            !n &&
            (("http" === i && "https" === e) || ("ws" === i && "wss" === e)))
        );
      }
      let p;
      Object.fromEntries
        ? (p = Object.fromEntries)
        : ((p = (e) => [...e].reduce((e, [t, n]) => ((e[t] = n), e), {})),
          (Object.fromEntries = p)),
        Object.defineProperties(Promise.prototype, {
          done: {
            value: function (e) {
              return this.then((...t) => e.apply(this, t));
            },
            configurable: !0,
            enumerable: !0,
            writable: !1,
          },
          fail: {
            value: function (e) {
              return this.then(
                () => {},
                (...t) => e.apply(this, t)
              );
            },
            configurable: !0,
            enumerable: !0,
            writable: !1,
          },
          always: {
            value: function (e) {
              return this.then(
                (...t) => e.apply(this, t),
                (...t) => e.apply(this, t)
              );
            },
            configurable: !0,
            enumerable: !0,
            writable: !1,
          },
        });
      const f = Promise,
        m = !1;
      let g = 0;
      const v = [],
        _ = () => {
          const e = ["debug"],
            t = ["log"],
            n = ["warn", "info"],
            r = ["error"],
            s = [...e, ...t, ...n, ...r],
            i = r;
          g >= 80 && i.push(...e),
            g >= 60 && i.push(...t),
            g >= 30 && i.push(...n),
            s.forEach(
              (e) =>
                (w[e] = i.includes(e) ? console[e].bind(console) : () => {})
            );
        },
        w = {
          set: (e) => {
            (g = e),
              v.forEach((e) => {
                e(w, g);
              }),
              _();
          },
          get: () => g,
          get verbose() {
            return (w.debug || (() => {})).bind(console);
          },
          debug: () => {},
          log: () => {},
          warn: () => {},
          info: () => {},
          error: () => {},
          addChangeListener: (e) => {
            v.push(e);
          },
        };
      _();
      let b = [];
      const y = {
          late: !1,
          init: () => {},
          registerLateCallback: (e) => {
            w.debug("toea: register callback"), b.push(e);
          },
          ensureLate: (e) => {
            y.late ? e() : y.registerLateCallback(e);
          },
          setReady: () => {
            w.debug("toea: run " + b.length + " callbacks"), (y.late = !0);
            for (let e = 0; e < b.length; e++) b[e]();
            b = [];
          },
        },
        k = y,
        R = (e) => {
          const t = (() => {
              let e, t;
              const n = [],
                r = [],
                s = (e) => {
                  r.push(e), i();
                },
                i = () => {
                  if (void 0 !== e) {
                    let n;
                    for (; r.length; )
                      (n = r.shift()),
                        (void 0 !== n.state && n.state !== e) ||
                          ("function" == typeof n.f && n.f.call(o, t));
                  }
                },
                o = {
                  promise: () => o,
                  done: (e) => (s({ state: !0, f: e }), o),
                  fail: (e) => (s({ state: !1, f: e }), o),
                  always: (e) => (s({ f: e }), o),
                  progress: (e) => (e && n.push(e), o),
                  then: (e, n, r) =>
                    R((s) => {
                      const i =
                        (e, n) =>
                        (...r) => {
                          const i = e ? e(t) : void 0,
                            o =
                              i && "function" == typeof i.promise
                                ? i.promise()
                                : null,
                            a = i && "function" == typeof i.then ? i : null;
                          if (o)
                            o.done((e) => s.resolve(e))
                              .fail((...e) => s.reject(e[0]))
                              .progress((...e) => s.notify(...e));
                          else if (a)
                            a.then(
                              (...e) => s.resolve(...e),
                              (e) => s.reject(e)
                            );
                          else {
                            const t = e ? [i] : r;
                            s[n](t[0]);
                          }
                        };
                      o.done(i(e, "resolve")),
                        o.fail(i(n, "reject")),
                        o.progress(i(r, "notify"));
                    }).promise(),
                  each: (e) => {
                    const t = R();
                    return (
                      o.then((n) => {
                        const r = Array.isArray(n) ? n : [n];
                        R.when(r.map((t) => e(t))).then(t.resolve);
                      }),
                      t.promise()
                    );
                  },
                  iterate: (e) => {
                    const t = R();
                    return (
                      o.then((n) => {
                        const r = (Array.isArray(n) ? n : [n]).map(
                          (t) => () => e(t)
                        );
                        R.onebyone(r, !0)
                          .done((e) => {
                            t.resolve(e);
                          })
                          .fail(t.reject);
                      }),
                      t.promise()
                    );
                  },
                };
              return {
                get: () => o,
                try_resolve: (n) => (
                  void 0 === e && ((e = !0), (t = n)), i(), o
                ),
                try_reject: (n) => (
                  void 0 === e && ((e = !1), (t = n)), i(), o
                ),
                do_notify: (e) => (
                  ((e) => {
                    n.forEach((t) => t(e));
                  })(e),
                  o
                ),
              };
            })(),
            n = {
              promise: () => t.get(),
              resolve: (e) => t.try_resolve(e),
              reject: (e) => t.try_reject(e),
              notify: (e) => t.do_notify(e),
              consume: (e) => (
                e && e.promise
                  ? e
                      .promise()
                      .done((e) => n.resolve(e))
                      .fail((...e) => n.reject(e[0]))
                      .progress((e) => n.notify(e))
                  : e && e.then
                  ? e.then(
                      (e) => n.resolve(e),
                      (...e) => n.reject(e[0])
                    )
                  : w.warn(
                      "promise: incompatible object given to consume()",
                      e
                    ),
                n.promise()
              ),
            };
          return e && e(n), n;
        };
      (R.Pledge = (...e) => {
        const t = R();
        return t.resolve(...e), t.promise();
      }),
        (R.Breach = (...e) => {
          const t = R();
          return t.reject(e[0]), t.promise();
        }),
        (R.onebyone = (e, t = !0) => {
          const n = [],
            r = R();
          let s = 0;
          const i = () => {
            if (s < e.length) {
              const o = (0, e[s++])();
              o && o.promise
                ? o
                    .promise()
                    .done((e) => {
                      n.push(e), i();
                    })
                    .fail(() => {
                      if ((n.push(null), t)) return r.reject();
                      i();
                    })
                : o && o.then
                ? o.then(
                    (e) => {
                      n.push(e), i();
                    },
                    () => {
                      if ((n.push(null), t)) return r.reject();
                      i();
                    }
                  )
                : (n.push(o), i());
            } else r.resolve(n);
          };
          return i(), r.promise();
        }),
        (R.or = (e) => {
          let t;
          const n = R(),
            r = () => {
              e.length
                ? ((t = e.shift()),
                  t && R.Pledge().then(t).done(n.resolve).fail(r))
                : n.reject();
            };
          return r(), n.promise();
        }),
        (R.sidebyside = (e) => {
          e = Array.isArray(e) ? e : [e];
          const t = R();
          let n = e.length;
          return (
            n
              ? e.forEach((e) => {
                  e &&
                    e.promise &&
                    e.promise().always(() => {
                      0 == --n && t.resolve();
                    });
                })
              : t.resolve(),
            t.promise()
          );
        }),
        (R.when = (e) => {
          e = Array.isArray(e) ? e : [e];
          const t = R();
          let n = e.length;
          const r = [];
          return (
            n
              ? e.forEach((e) => {
                  let s;
                  if (e && e.promise) s = e.promise();
                  else {
                    if (!e.then)
                      return void w.warn(
                        "promise: incompatible object given to when()",
                        e
                      );
                    s = e;
                  }
                  s.fail(() => {
                    t.reject(), (n = -1);
                  }).done((e) => {
                    r.push(e), 0 == --n && t.resolve(r);
                  });
                })
              : t.resolve(r),
            t.promise()
          );
        });
      const x = (e) => new f((t) => M(t, e));
      let E = 0;
      const S = (e, t) => {
          const n = Date.now();
          if (E + e < n)
            return new f((e) =>
              X(() => {
                (E = Date.now()), e();
              }, t || 0)
            );
        },
        C = async function (e, ...t) {
          await S(1e3), e.apply(this, t);
        },
        M = function (e, t) {
          return t ? X.apply(this, [e, t]) : (C.apply(this, [e]), 0);
        },
        I = (e) => {
          const t = [],
            n = [],
            r = () => {
              let s;
              if (n.length < e.threads && t.length && (s = t.shift())) {
                const e = s.fn();
                let t;
                if (void 0 !== e.catch) {
                  const n = R();
                  e.then(n.resolve).catch(n.reject), (t = n.promise());
                } else t = e;
                n.push(t),
                  t.always(() => {
                    let e;
                    (e = n.indexOf(t)) > -1 && n.splice(e, 1), r();
                  }),
                  s.p.consume(t);
              }
            },
            s = {
              add: function (e) {
                const n = R();
                return t.push({ fn: e, p: n }), r(), n.promise();
              },
            };
          return s;
        },
        G = (e) => {
          const t = {},
            {
              retimeout_on_get: n,
              timeout: r,
              check_interval: s,
              auto_remove_mutex: i,
            } = Object.assign(
              { retimeout_on_get: !1, timeout: 300, check_interval: 120 },
              e || {}
            );
          let o;
          const a = () => {
              l(), (o = X(u, 1e3 * s));
            },
            l = () => {
              o && L(o), (o = null);
            },
            c = (e) => {
              const n = t[e];
              return delete t[e], n ? n.value : void 0;
            },
            u = () => {
              o = null;
              const e = Date.now() - 1e3 * r,
                n = Object.entries(t).filter(([t, n]) => n.ts < e);
              n.length
                ? (i ? i.acquire() : R.Pledge()).then(() => {
                    n.forEach(([e, t]) => {
                      const n = t && t.d;
                      n && n.resolve([e, t.value]), c(e);
                    }),
                      i && i.release(),
                      a();
                  })
                : a();
            };
          r && a();
          const A = {
            set: (e, n) => {
              const r = R();
              return (t[e] = { value: n, ts: Date.now(), d: r }), r.promise();
            },
            get: (e, r) => {
              const s = t[e];
              return s ? (n && (s.ts = Date.now()), s.value) : r;
            },
            remove: c,
            removeAll: () => {
              Object.keys(t).map((e) => c(e));
            },
          };
          return A;
        },
        U = () => (oe && oe.cookie) || "",
        Z = (e) => {
          oe && (oe.cookie = e);
        },
        {
          AbortController: T,
          FileReader: B,
          TextDecoder: O,
          addEventListener: F,
          atob: D,
          btoa: j,
          clearInterval: P,
          clearTimeout: L,
          crypto: N,
          decodeURIComponent: V,
          encodeURIComponent: z,
          escape: q,
          location: H,
          removeEventListener: Q,
          setInterval: W,
          setTimeout: X,
          unescape: Y,
        } = self;
      let { fetch: J } = self;
      const K = self,
        $ = H.origin,
        {
          DOMParser: ee,
          Notification: te,
          Image: ne,
          Worker: re,
          alert: se,
          confirm: ie,
          document: oe,
          localStorage: ae,
          screen: le,
          webkitNotifications: ce,
        } = (H.host, self);
      let { XMLHttpRequest: ue } = self;
      const Ae = (e) => Y(z(e)),
        de = (e) => V(q(e)),
        he = (e) => {
          let t = "";
          for (let n = 0; n < e.length; n++)
            t += String.fromCharCode(255 & e.charCodeAt(n));
          return j(t);
        },
        pe = (e) => D(e),
        fe = (e, t) => {
          try {
            let n, r;
            if (
              ("object" == typeof t
                ? ((n = t.encoding), (r = t.array))
                : (n = t),
              !r && n)
            )
              return new O(n).decode(e);
            {
              let t = 0;
              const r = [],
                s = e.byteLength;
              for (; t < s; t += 16384)
                r.push(
                  String.fromCharCode.apply(
                    null,
                    new Uint8Array(e, t, Math.min(16384, s - t))
                  )
                );
              let i = r.join("");
              return n && "utf-8" == n.toLowerCase() && (i = de(i)), i;
            }
          } catch (e) {
            w.warn(e);
          }
          return null;
        },
        me = (e, t) => {
          try {
            let n;
            (n = "object" == typeof t ? t.encoding : t),
              n && "utf-8" == n.toLowerCase() && (e = Ae(e));
            const r = new Uint8Array(e.length);
            for (let t = 0; t < e.length; t++) r[t] = 255 & e.charCodeAt(t);
            return r.buffer;
          } catch (e) {
            w.warn(e);
          }
          return new Uint8Array(0).buffer;
        },
        ge = (e, t) =>
          new Promise((n, r) => {
            const s = t && t.encoding ? "text/plain" : "binary/octet-stream",
              i = new Blob([e], { type: s }),
              o = new B();
            (o.onload = (e) => {
              e.target
                ? n(e.target.result)
                : r(new Error("Could not convert array to string!"));
            }),
              t && t.encoding
                ? o.readAsText(i, t.encoding)
                : o.readAsBinaryString(i);
          }),
        ve = (e, t) => {
          const n = (e, t) => (e << t) | (e >>> (32 - t)),
            r = (e, t) => {
              const n = 2147483648 & e,
                r = 2147483648 & t,
                s = 1073741824 & e,
                i = 1073741824 & t,
                o = (1073741823 & e) + (1073741823 & t);
              return s & i
                ? 2147483648 ^ o ^ n ^ r
                : s | i
                ? 1073741824 & o
                  ? 3221225472 ^ o ^ n ^ r
                  : 1073741824 ^ o ^ n ^ r
                : o ^ n ^ r;
            },
            s = (e, t, s, i, o, a, l) => (
              (e = r(
                e,
                r(r(((e, t, n) => (e & t) | (~e & n))(t, s, i), o), l)
              )),
              r(n(e, a), t)
            ),
            i = (e, t, s, i, o, a, l) => (
              (e = r(
                e,
                r(r(((e, t, n) => (e & n) | (t & ~n))(t, s, i), o), l)
              )),
              r(n(e, a), t)
            ),
            o = (e, t, s, i, o, a, l) => (
              (e = r(e, r(r(((e, t, n) => e ^ t ^ n)(t, s, i), o), l))),
              r(n(e, a), t)
            ),
            a = (e, t, s, i, o, a, l) => (
              (e = r(e, r(r(((e, t, n) => t ^ (e | ~n))(t, s, i), o), l))),
              r(n(e, a), t)
            ),
            l = (e) => {
              let t,
                n,
                r = "",
                s = "";
              for (n = 0; n <= 3; n++)
                (t = (e >>> (8 * n)) & 255),
                  (s = "0" + t.toString(16)),
                  (r += s.substr(s.length - 2, 2));
              return r;
            };
          let c,
            u,
            A,
            d,
            h,
            p,
            f,
            m,
            g,
            v = [];
          for (
            t && "utf-8" == t.toLowerCase() && (e = Ae(e)),
              v = ((e) => {
                let t;
                const n = e.length,
                  r = n + 8,
                  s = 16 * ((r - (r % 64)) / 64 + 1),
                  i = Array(s - 1);
                let o = 0,
                  a = 0;
                for (; a < n; )
                  (t = (a - (a % 4)) / 4),
                    (o = (a % 4) * 8),
                    (i[t] = i[t] | (e.charCodeAt(a) << o)),
                    a++;
                return (
                  (t = (a - (a % 4)) / 4),
                  (o = (a % 4) * 8),
                  (i[t] = i[t] | (128 << o)),
                  (i[s - 2] = n << 3),
                  (i[s - 1] = n >>> 29),
                  i
                );
              })(e),
              p = 1732584193,
              f = 4023233417,
              m = 2562383102,
              g = 271733878,
              c = 0;
            c < v.length;
            c += 16
          )
            (u = p),
              (A = f),
              (d = m),
              (h = g),
              (p = s(p, f, m, g, v[c + 0], 7, 3614090360)),
              (g = s(g, p, f, m, v[c + 1], 12, 3905402710)),
              (m = s(m, g, p, f, v[c + 2], 17, 606105819)),
              (f = s(f, m, g, p, v[c + 3], 22, 3250441966)),
              (p = s(p, f, m, g, v[c + 4], 7, 4118548399)),
              (g = s(g, p, f, m, v[c + 5], 12, 1200080426)),
              (m = s(m, g, p, f, v[c + 6], 17, 2821735955)),
              (f = s(f, m, g, p, v[c + 7], 22, 4249261313)),
              (p = s(p, f, m, g, v[c + 8], 7, 1770035416)),
              (g = s(g, p, f, m, v[c + 9], 12, 2336552879)),
              (m = s(m, g, p, f, v[c + 10], 17, 4294925233)),
              (f = s(f, m, g, p, v[c + 11], 22, 2304563134)),
              (p = s(p, f, m, g, v[c + 12], 7, 1804603682)),
              (g = s(g, p, f, m, v[c + 13], 12, 4254626195)),
              (m = s(m, g, p, f, v[c + 14], 17, 2792965006)),
              (f = s(f, m, g, p, v[c + 15], 22, 1236535329)),
              (p = i(p, f, m, g, v[c + 1], 5, 4129170786)),
              (g = i(g, p, f, m, v[c + 6], 9, 3225465664)),
              (m = i(m, g, p, f, v[c + 11], 14, 643717713)),
              (f = i(f, m, g, p, v[c + 0], 20, 3921069994)),
              (p = i(p, f, m, g, v[c + 5], 5, 3593408605)),
              (g = i(g, p, f, m, v[c + 10], 9, 38016083)),
              (m = i(m, g, p, f, v[c + 15], 14, 3634488961)),
              (f = i(f, m, g, p, v[c + 4], 20, 3889429448)),
              (p = i(p, f, m, g, v[c + 9], 5, 568446438)),
              (g = i(g, p, f, m, v[c + 14], 9, 3275163606)),
              (m = i(m, g, p, f, v[c + 3], 14, 4107603335)),
              (f = i(f, m, g, p, v[c + 8], 20, 1163531501)),
              (p = i(p, f, m, g, v[c + 13], 5, 2850285829)),
              (g = i(g, p, f, m, v[c + 2], 9, 4243563512)),
              (m = i(m, g, p, f, v[c + 7], 14, 1735328473)),
              (f = i(f, m, g, p, v[c + 12], 20, 2368359562)),
              (p = o(p, f, m, g, v[c + 5], 4, 4294588738)),
              (g = o(g, p, f, m, v[c + 8], 11, 2272392833)),
              (m = o(m, g, p, f, v[c + 11], 16, 1839030562)),
              (f = o(f, m, g, p, v[c + 14], 23, 4259657740)),
              (p = o(p, f, m, g, v[c + 1], 4, 2763975236)),
              (g = o(g, p, f, m, v[c + 4], 11, 1272893353)),
              (m = o(m, g, p, f, v[c + 7], 16, 4139469664)),
              (f = o(f, m, g, p, v[c + 10], 23, 3200236656)),
              (p = o(p, f, m, g, v[c + 13], 4, 681279174)),
              (g = o(g, p, f, m, v[c + 0], 11, 3936430074)),
              (m = o(m, g, p, f, v[c + 3], 16, 3572445317)),
              (f = o(f, m, g, p, v[c + 6], 23, 76029189)),
              (p = o(p, f, m, g, v[c + 9], 4, 3654602809)),
              (g = o(g, p, f, m, v[c + 12], 11, 3873151461)),
              (m = o(m, g, p, f, v[c + 15], 16, 530742520)),
              (f = o(f, m, g, p, v[c + 2], 23, 3299628645)),
              (p = a(p, f, m, g, v[c + 0], 6, 4096336452)),
              (g = a(g, p, f, m, v[c + 7], 10, 1126891415)),
              (m = a(m, g, p, f, v[c + 14], 15, 2878612391)),
              (f = a(f, m, g, p, v[c + 5], 21, 4237533241)),
              (p = a(p, f, m, g, v[c + 12], 6, 1700485571)),
              (g = a(g, p, f, m, v[c + 3], 10, 2399980690)),
              (m = a(m, g, p, f, v[c + 10], 15, 4293915773)),
              (f = a(f, m, g, p, v[c + 1], 21, 2240044497)),
              (p = a(p, f, m, g, v[c + 8], 6, 1873313359)),
              (g = a(g, p, f, m, v[c + 15], 10, 4264355552)),
              (m = a(m, g, p, f, v[c + 6], 15, 2734768916)),
              (f = a(f, m, g, p, v[c + 13], 21, 1309151649)),
              (p = a(p, f, m, g, v[c + 4], 6, 4149444226)),
              (g = a(g, p, f, m, v[c + 11], 10, 3174756917)),
              (m = a(m, g, p, f, v[c + 2], 15, 718787259)),
              (f = a(f, m, g, p, v[c + 9], 21, 3951481745)),
              (p = r(p, u)),
              (f = r(f, A)),
              (m = r(m, d)),
              (g = r(g, h));
          return (l(p) + l(f) + l(m) + l(g)).toLowerCase();
        },
        _e = (e) => {
          let t;
          t = e.split(",")[0].includes("base64")
            ? D(e.split(",")[1])
            : Y(e.split(",")[1]);
          const n = e.split(",")[0].split(":")[1].split(";")[0],
            r = new Uint8Array(t.length);
          for (let e = 0; e < t.length; e++) r[e] = t.charCodeAt(e);
          return new Blob([r], { type: n });
        },
        we = (e) =>
          new Promise((t) => {
            const n = new B();
            (n.onload = (e) => {
              var n;
              t(
                (null === (n = e.target) || void 0 === n ? void 0 : n.result) ||
                  void 0
              );
            }),
              n.readAsDataURL(e);
          }),
        be = async (e, t) =>
          new Promise((n) => {
            const r = new B();
            (r.onload = () => {
              n(r.result || "");
            }),
              (r.onerror = (e) => {
                w.warn(`unable to decode data ${e}`), n("");
              }),
              t ? r.readAsText(e, t) : r.readAsBinaryString(e);
          }),
        ye = (e) => j(Ae(e)),
        ke = (e) => de(D(e)),
        Re = (e, t) => {
          if (!e) return t;
          const n = e[0];
          switch (((e = e.substring(1)), n)) {
            case "b":
              return "true" == e;
            case "n":
              return Number(e);
            case "o":
              try {
                return JSON.parse(e);
              } catch (e) {
                console.error("Storage: getValue ERROR: " + e.message);
              }
              return t;
            case "x":
              try {
                return de(pe(e));
              } catch (t) {
                return e;
              }
            default:
              return e;
          }
        },
        xe = (e) => {
          const t = (typeof e)[0];
          if ("o" === t)
            try {
              e = t + JSON.stringify(e);
            } catch (n) {
              console.error("Storage: setValue ERROR: " + n.message),
                (e = t + JSON.stringify({}));
            }
          else e = t + e;
          return e;
        },
        Ee = globalThis,
        { chrome: Se, browser: Ce } = Ee;
      let Me, Ie, Ge, Ue;
      (Ge = () => {
        if (void 0 !== Me) return Me;
        try {
          const e = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
          e && (Me = parseInt(e[2]));
        } catch (e) {}
        return Me;
      }),
        (Ue = () => {
          if (void 0 !== Ie) return Ie;
          try {
            Ie = -1 != navigator.userAgent.search(/Android|Mobile/);
          } catch (e) {}
          return Ie;
        });
      const Ze = {
          STORAGE: {
            SCHEMA: "#schema",
            TYPE: "#storage",
            CONFIG: "#config",
            SESSION: "#session",
            VERSION: "#version",
            LEGACY_VERSION: "TM_version",
            LAST_START: "#laststart",
            UPDATE: "#update",
            BEGGING: "#begging",
          },
          PREFIX: {
            SCRIPT_UID: "@uid#",
            COND: "@re#",
            STORE: "@st#",
            SCRIPT: "@source#",
            EXTERNAL: "@ext#",
            META: "@meta#",
            STATE_DB: "@state#",
            MISC_CONFIG: "#misc_config",
          },
        },
        Te = {
          FAST_EXEC_SUPPORT: !0,
          DETECT_CONSTRUCTORS_BY_KEYS: Ge() >= 60,
          ALLOWS_FILE_SCHEME_ACCESS: !1,
          MAX_SCRIPTS: 1e3,
          WEBREQUEST_XHR_SUPPORT: !0,
          WEBREQUEST_WEBSOCKET: !1,
          CAN_SAVEAS_ZIP: !0,
          SHARED_OBJECT_URLS: !0,
          SHARED_BLOBS: !1,
          CONTEXT_MENU: !0,
          INCOGNITO_MODE: !0,
          FPI: !1,
          CLIPBOARD_API: !1,
        },
        Be = {
          USE: null,
          DEFAULT: "chromeStorage",
          SECURE: !1,
          NO_WARNING: !1,
        },
        Oe = { RETRIES: 0, PARTIAL_SIZE: 1 << 23, COOKIE_PASSTHROUGH: !1 },
        Fe = {
          HAS_SENDER_ID: !0,
          INTERNAL_PAGE_PROTOCOLS: ["chrome-extension:"],
          SENDS_ORIGIN: !0,
        },
        De = !0;
      [].concat(["chrome"]);
      const je = (e, t) => {
          t
            ? (Se.runtime.reload || location.reload)()
            : window.setTimeout(() => location.reload(), e || 0);
        },
        Pe = (() => {
          const e = {
            getInternalPathRegexp: function (e, t) {
              const n = new RegExp(
                  "(\\" +
                    [
                      "/",
                      ".",
                      "+",
                      "?",
                      "|",
                      "(",
                      ")",
                      "[",
                      "]",
                      "{",
                      "}",
                      "\\",
                    ].join("|\\") +
                    ")",
                  "g"
                ),
                r = Fe.INTERNAL_PAGE_PROTOCOLS[0] + "//" + Pe.id + "/";
              return new RegExp(
                r.replace(n, "\\$1") +
                  "([a-zA-Z" +
                  (e ? "\\/" : "") +
                  "]*)" +
                  (t || "").replace(n, "\\$1")
              );
            },
            getInternalPageRegexp: function () {
              return Pe.getInternalPathRegexp(!1, ".html");
            },
            getPlatformInfo: (e) => Se.runtime.getPlatformInfo(e),
            getBrowserInfo: (e) => {
              e({ name: "Chrome", version: `${Ge()}`, vendor: "unknown" });
            },
          };
          return (
            Object.defineProperty(e, "lastError", {
              get: () => Se.runtime.lastError,
              enumerable: !0,
            }),
            Object.defineProperty(e, "id", {
              get: () => Se.runtime.id,
              enumerable: !0,
            }),
            Object.defineProperty(e, "short_id", {
              get: () => e.id.replace(/[^0-9a-zA-Z]/g, "").substr(0, 4),
              enumerable: !0,
            }),
            e
          );
        })(),
        Le = (() => {
          const e = {
            getURL: function (e) {
              return Se.runtime.getURL(e);
            },
            sendMessage: function (e, t) {
              return Se.runtime.sendMessage(e, t);
            },
            onMessage: {
              addListener: function (e) {
                return Se.runtime.onMessage.addListener(e);
              },
            },
            connect: function (e) {
              return Se.runtime.connect({ name: e });
            },
          };
          let t;
          return (
            Object.defineProperty(e, "inIncognitoContext", {
              get: () => (
                void 0 === t && (t = Se.extension.inIncognitoContext), t
              ),
              set: (e) => {
                t = e;
              },
              enumerable: !0,
            }),
            e
          );
        })(),
        Ne = { isDefaultStoreId: (e) => !(void 0 !== e) };
      let Ve = !0;
      (async () => {
        await null, (Ve = !1);
      })();
      const ze = Object.defineProperties(
          {},
          {
            ...Object.getOwnPropertyDescriptors(Le),
            ...Object.getOwnPropertyDescriptors({
              onConnect: {
                addListener: function (e) {
                  return Se.runtime.onConnect.addListener(e);
                },
              },
              onConnectExternal: {
                addListener: function (e) {
                  return Se.runtime.onConnectExternal.addListener(e);
                },
              },
              onMessageExternal: {
                addListener: function (e) {
                  return Se.runtime.onMessageExternal.addListener(e);
                },
              },
              onMessage: {
                ...Le.onMessage,
                addListener: (e) => {
                  Le.onMessage.addListener((t, n, r) => e(t, n, r));
                },
              },
              manifest: Se.runtime.getManifest(),
              inIncognitoContext: Le.inIncognitoContext,
              getViews: function (e) {
                return Se.extension.getViews(e);
              },
              urls: {
                prepareForReport: function (e) {
                  return e;
                },
              },
            }),
          }
        ),
        qe = Object.defineProperties(
          {},
          {
            ...Object.getOwnPropertyDescriptors(Pe),
            ...Object.getOwnPropertyDescriptors({
              onInstalled: {
                addListener: function (e) {
                  Se.runtime.onInstalled &&
                    Se.runtime.onInstalled.addListener(e);
                },
              },
              onUpdateAvailable: {
                addListener: function (e) {
                  Se.runtime.onUpdateAvailable &&
                    Se.runtime.onUpdateAvailable.addListener(e);
                },
              },
              setUninstallURL: (e) => {
                Se.runtime.setUninstallURL && Se.runtime.setUninstallURL(e);
              },
              isDarkMode: () =>
                !!window.matchMedia("(prefers-color-scheme: dark)").matches,
            }),
          }
        ),
        He = function (e) {
          return Se.tabs.onActivated.addListener(e);
        },
        Qe = function (e) {
          return Se.tabs.onUpdated.addListener(e);
        },
        We = function (e) {
          if (Se.tabs.onReplaced) return Se.tabs.onReplaced.addListener(e);
        },
        Xe = function (e) {
          return Se.tabs.onRemoved.addListener(e);
        },
        Ye = function (e, t) {
          let {
            url: n,
            active: r,
            index: s,
            openerTabId: i,
            windowId: o,
            parent: a,
            incognito: l,
          } = e;
          const c = {
            url: n,
            active: r,
            index: s,
            openerTabId: i,
            windowId: o,
          };
          a &&
            (void 0 !== (i = a.id) &&
              (i < 0
                ? console.warn(
                    `tabs.create: openerTabId lower than 0 is not supported -> ${i}!`
                  )
                : (c.openerTabId = i)),
            void 0 !== (o = a.windowId) && (c.windowId = o)),
            l && nt.supported
              ? nt.getAll({ windowTypes: ["normal"] }, (e) => {
                  let n;
                  return (
                    e.some((e) => (e.incognito ? (n = e.id) : null)),
                    void 0 === n
                      ? Se.windows.create({ url: c.url, incognito: !0 }, t)
                      : ((c.windowId = n), Se.tabs.create(c, t))
                  );
                })
              : Se.tabs.create(c, t);
        },
        Je = function (e, t, n) {
          return Se.tabs.update(e, t, n);
        },
        Ke = function (e, t) {
          return Se.tabs.remove(e, t);
        },
        $e = function (e, t) {
          let n = 1;
          const r = () => {
            if (!(Ge() >= 55))
              return Se.tabs.getSelected(e, (e) => {
                Se.runtime.lastError && n-- > 0 ? X(() => r(), 1) : t && t(e);
              });
            Se.tabs.query({ active: !0, currentWindow: !0 }, function (e) {
              Se.runtime.lastError && n-- > 0 ? X(r, 1) : t && t(e[0]);
            });
          };
          return r();
        },
        et = function (e, t) {
          return Se.tabs.get(e, t);
        },
        tt = function (e, t, n, r) {
          return (
            "function" == typeof n && ((r = n), (n = {})),
            Se.tabs.sendMessage(e, t, n, r)
          );
        },
        nt =
          Se.windows && Se.windows.getAll
            ? {
                supported: !0,
                getAll: function (e, t) {
                  Se.windows.getAll ? Se.windows.getAll(e, t) : t([]);
                },
              }
            : { supported: !1 },
        rt = {
          headerModificationSupported: !0,
          extraHeaderNeeded:
            Se.webRequest &&
            Se.webRequest.OnBeforeSendHeadersOptions &&
            Se.webRequest.OnBeforeSendHeadersOptions.hasOwnProperty(
              "EXTRA_HEADERS"
            ),
          onBeforeRequest: {
            addListener: (e, t, n) =>
              Se.webRequest.onBeforeRequest.addListener(e, t, n),
            addDynamicListener: (e, t, n) =>
              Se.webRequest.onBeforeRequest.addListener(e, t, n),
            removeListener: (e) =>
              Se.webRequest.onBeforeRequest.removeListener(e),
            hasListener: (e) => Se.webRequest.onBeforeRequest.hasListener(e),
          },
          onBeforeSendHeaders: {
            addListener: (e, t, n) =>
              Se.webRequest.onBeforeSendHeaders.addListener(e, t, n),
            addDynamicListener: (e, t, n) =>
              Se.webRequest.onBeforeSendHeaders.addListener(e, t, n),
            removeListener: (e) =>
              Se.webRequest.onBeforeSendHeaders.removeListener(e),
            hasListener: (e) =>
              Se.webRequest.onBeforeSendHeaders.hasListener(e),
          },
          onHeadersReceived: {
            addListener: (e, t, n) =>
              Se.webRequest.onHeadersReceived.addListener(e, t, n),
            addDynamicListener: (e, t, n) =>
              Se.webRequest.onHeadersReceived.addListener(e, t, n),
            removeListener: (e) =>
              Se.webRequest.onHeadersReceived.removeListener(e),
            hasListener: (e) => Se.webRequest.onHeadersReceived.hasListener(e),
          },
          onBeforeRedirect: {
            addListener: (e, t, n) =>
              Se.webRequest.onBeforeRedirect.addListener(e, t, n),
            addDynamicListener: (e, t, n) =>
              Se.webRequest.onBeforeRedirect.addListener(e, t, n),
            removeListener: (e) =>
              Se.webRequest.onBeforeRedirect.removeListener(e),
            hasListener: (e) => Se.webRequest.onBeforeRedirect.hasListener(e),
          },
          onResponseStarted: {
            addListener: (e, t, n) =>
              Se.webRequest.onResponseStarted.addListener(e, t, n),
            addDynamicListener: (e, t, n) =>
              Se.webRequest.onResponseStarted.addListener(e, t, n),
            removeListener: (e) =>
              Se.webRequest.onResponseStarted.removeListener(e),
            hasListener: (e) => Se.webRequest.onResponseStarted.hasListener(e),
          },
          onErrorOccurred: {
            addListener: (e) => Se.webRequest.onErrorOccurred.addListener(e),
            addDynamicListener: (e) =>
              Se.webRequest.onErrorOccurred.addListener(e),
            removeListener: (e) =>
              Se.webRequest.onErrorOccurred.removeListener(e),
            hasListener: (e) => Se.webRequest.onErrorOccurred.hasListener(e),
          },
          handlerBehaviorChanged: () => Se.webRequest.handlerBehaviorChanged(),
        },
        st = !!Se.webNavigation,
        it = {
          addListener: function (e) {
            return Se.webNavigation.onHistoryStateUpdated
              ? Se.webNavigation.onHistoryStateUpdated.addListener(e)
              : Se.webNavigation.onReferenceFragmentUpdated
              ? Se.webNavigation.onReferenceFragmentUpdated.addListener(e)
              : void 0;
          },
          addDynamicListener: function (e) {
            return Se.webNavigation.onHistoryStateUpdated
              ? Se.webNavigation.onHistoryStateUpdated.addListener(e)
              : Se.webNavigation.onReferenceFragmentUpdated
              ? Se.webNavigation.onReferenceFragmentUpdated.addListener(e)
              : void 0;
          },
        },
        ot = Se.browserAction,
        at = function (e, t) {
          const { path: n, ...r } = e;
          let s = {};
          return (
            n &&
              (s =
                Ge() >= 53
                  ? {
                      19: n.replace(/\.png$/, "19.png"),
                      38: n.replace(/\.png$/, "38.png"),
                      16: n.replace(/\.png$/, "16.png"),
                      24: n.replace(/\.png$/, "24.png"),
                      32: n.replace(/\.png$/, "32.png"),
                    }
                  : {
                      19: n.replace(/\.png$/, "19.png"),
                      38: n.replace(/\.png$/, "38.png"),
                    }),
            ot.setIcon({ path: s, ...r }, t)
          );
        },
        lt = function (e) {
          if (ot.setTitle) return ot.setTitle(e);
        },
        ct =
          Se.declarativeContent && Se.declarativeContent.onPageChanged
            ? {
                supported: !0,
                onPageChanged: {
                  addRules: (e, t) =>
                    Se.declarativeContent.onPageChanged.addRules(e, t),
                  getRules: (e, t) =>
                    Se.declarativeContent.onPageChanged.getRules(e, t),
                  removeRules: (e, t) =>
                    Se.declarativeContent.onPageChanged.removeRules(e, t),
                },
                PageStateMatcher: Se.declarativeContent.PageStateMatcher,
                RequestContentScript:
                  Se.declarativeContent.RequestContentScript,
              }
            : { supported: !1 },
        ut =
          (Se.contentScripts && Se.contentScripts.register,
          Ce && Ce.userScripts && Ce.userScripts.register,
          (() => {
            const e = Se;
            e.scripting && e.scripting.executeScript;
          })(),
          Se.declarativeNetRequest &&
            Se.declarativeNetRequest.updateDynamicRules &&
            Se.declarativeNetRequest.getDynamicRules,
          {
            onChanged: {
              addListener: function (e) {
                return Se.storage.onChanged.addListener(e);
              },
            },
            local: (() => {
              let e = {},
                t = {},
                n = null,
                r = !1,
                s = [];
              const i = (e) => {
                  r ? s.push(e) : e();
                },
                o = (i, o) => {
                  n && L(n);
                  const a = () => {
                    r = !0;
                    let i = 1;
                    const a = () => {
                        let n;
                        if (
                          ((n = Se.runtime.lastError) && console.warn(n),
                          0 == --i)
                        ) {
                          r = !1;
                          const n = s;
                          (s = []),
                            (e = {}),
                            (t = {}),
                            n.forEach((e) => e()),
                            o && o();
                        }
                      },
                      l = () => {
                        Object.keys(e).length &&
                          (i++, Se.storage.local.set(e, a));
                      };
                    let c;
                    (c = Object.keys(t)).length
                      ? (i++,
                        Se.storage.local.remove(c, () => {
                          l(), a();
                        }))
                      : l(),
                      a(),
                      (n = null);
                  };
                  i ? a() : (n = X(a, 500));
                },
                a = (t, n) => {
                  if (t instanceof Array) {
                    let e = 1;
                    const r = {},
                      s = () => {
                        0 == --e && n(r);
                      };
                    t.forEach((t) => {
                      e++,
                        a(t, (e) => {
                          (r[t] = e[t]), s();
                        });
                    }),
                      s();
                  } else if (void 0 !== e[t]) {
                    const r = {};
                    (r[t] = e[t]), n(r);
                  } else Se.storage.local.get(t, n);
                },
                l = (n) => {
                  n instanceof Array
                    ? n.forEach((e) => l(e))
                    : ((t[n] = !0), delete e[n]);
                },
                c = {
                  set: function (n, r) {
                    i(() => {
                      r && s.push(r),
                        Object.keys(n).forEach((r) => {
                          var s, i;
                          (s = r), (i = n[r]), (e[s] = i), delete t[s];
                        }),
                        o();
                    });
                  },
                  get: (e, t) => {
                    null === e
                      ? o(!0, () => {
                          Se.storage.local.get(null, t);
                        })
                      : i(() => {
                          const n =
                            "string" == typeof e || e instanceof Array
                              ? e
                              : Object.keys(e);
                          a(n, (e) => t(e));
                        });
                  },
                  remove: function (e, t) {
                    i(() => {
                      t && s.push(t), l(e), o();
                    });
                  },
                  clear: function (r) {
                    i(() => {
                      n && L(n),
                        (s = []),
                        (e = {}),
                        (t = {}),
                        Se.storage.local.clear(r);
                    });
                  },
                };
              return c;
            })(),
            session: (() => {
              const e = Ce || Se;
              return {
                supported: !!e.storage.session,
                set: (t) => e.storage.session.set(t),
                get: (t) => e.storage.session.get(t),
                remove: (t) => e.storage.session.remove(t),
                clear: () => e.storage.session.clear(),
              };
            })(),
            sync: {
              supported: !0,
              set: function (e, t) {
                return Se.storage.sync.set(e, t);
              },
              get: function (e, t) {
                return Se.storage.sync.get(e, t);
              },
              remove: function (e, t) {
                return Se.storage.sync.remove(e, t);
              },
              clear: function (e) {
                return Se.storage.sync.clear(e);
              },
            },
          }),
        At = function (e) {
          return Se.downloads.onChanged.addListener(e);
        },
        dt = function (e, t, n) {
          try {
            const r = new XMLHttpRequest();
            r.open("GET", e, !0),
              (r.responseType = "arraybuffer"),
              (r.onload = () => {
                t(r.response);
              }),
              (r.onerror = () => {
                n(r.statusText);
              }),
              r.send();
          } catch (e) {
            n(e.message);
          }
        },
        ht = Object.defineProperties(
          {},
          {
            ...Object.getOwnPropertyDescriptors(Ne),
            ...Object.getOwnPropertyDescriptors({
              getAll: function (e, t) {
                return Se.cookies.getAll(e, t);
              },
              remove: function (e, t) {
                return Se.cookies.remove(e, t);
              },
              set: function (e, t) {
                return Se.cookies.set(e, t);
              },
            }),
          }
        ),
        pt = { is_supported: !1, set: () => {} },
        ft = !(!Se.commands || !Se.commands.onCommand),
        mt = function (e) {
          return Se.notifications.onPermissionLevelChanged.addListener(e);
        },
        gt = function (e) {
          return Se.notifications.onClicked.addListener(e);
        },
        vt = function (e) {
          return Se.notifications.onClosed.addListener(e);
        },
        _t = !!(
          Se.notifications &&
          Se.notifications.getPermissionLevel &&
          Se.notifications.onPermissionLevelChanged &&
          Se.notifications.onClicked
        ),
        wt =
          Te.CONTEXT_MENU &&
          Se.contextMenus &&
          Se.contextMenus.create &&
          Se.contextMenus.update &&
          Se.contextMenus.remove
            ? {
                supported: !0,
                create: function (e, t) {
                  return Se.contextMenus.create(e, t);
                },
                update: function (e, t, n) {
                  return Se.contextMenus.update(e, t, n);
                },
                remove: function (e, t) {
                  return Se.contextMenus.remove(e, t);
                },
                removeAll: function (e) {
                  return Se.contextMenus.removeAll(e);
                },
                onClicked: {
                  addListener: function (e) {
                    return Se.contextMenus.onClicked.addListener(e);
                  },
                },
              }
            : { supported: !1 },
        bt = (() => {
          const e = Se.permissions && !!Se.permissions.getAll;
          return {
            supported: e,
            getAll: (t) => {
              if (e) return Se.permissions.getAll(t);
              t && t({ permissions: [], origins: [] });
            },
            contains: (t, n) => {
              if (e) return Se.permissions.contains(t, n);
              n && n(!1);
            },
            request: (t, n) => {
              if (e) return Se.permissions.request(t, n);
              n && n(!1);
            },
            remove: (t, n) => {
              if (e) return Se.permissions.remove(t, n);
              n && n(!1);
            },
            onAdded: {
              addListener: (t) => {
                if (e && Se.permissions.onAdded)
                  return Se.permissions.onAdded.addListener(t);
              },
            },
            onRemoved: {
              addListener: (t) => {
                if (e && Se.permissions.onRemoved)
                  return Se.permissions.onRemoved.addListener(t);
              },
            },
          };
        })(),
        yt = {
          native_support: !0,
          getMessage: function (...e) {
            return Se.i18n.getMessage.apply(this, e);
          },
          getUILanguage: function () {
            return Se.i18n.getUILanguage
              ? Se.i18n.getUILanguage()
              : navigator.language;
          },
          getAcceptLanguages: function (e) {
            return Se.i18n.getAcceptLanguages
              ? Se.i18n.getAcceptLanguages(e)
              : e([]);
          },
        },
        kt = function (e, t) {
          return Se.idle ? Se.idle.queryState(e, t) : t("unknown");
        },
        Rt = (() => {
          if (!Se.alarms || !Se.alarms.create) return { supported: !1 };
          const e = {
            supported: !0,
            create: (e, t) =>
              new Promise((n) => {
                (Se.alarms.create(e, t) || Promise.resolve()).then(() => n());
              }),
            get: (e) => new Promise((t) => Se.alarms.get(e, (e) => t(e))),
            getAll: () => new Promise((e) => Se.alarms.getAll((t) => e(t))),
            clear: (e) => new Promise((t) => Se.alarms.clear(e, (e) => t(e))),
            clearAll: () => new Promise((e) => Se.alarms.clearAll((t) => e(t))),
            onAlarm: {
              addListener: (e) => Se.alarms.onAlarm.addListener(e),
            },
          };
          return e;
        })();
      (() => {
        Be.USE = Be.DEFAULT;
        try {
          ae &&
            ((Be.NO_WARNING = "nowarning" === ae.getItem("#brokenprofile")),
            (Be.USE = ae.getItem(Ze.STORAGE.TYPE) || Be.DEFAULT));
        } catch (e) {
          console.warn("prep: error at storage type detection", e);
        }
        var e;
        (e = (e) => {
          Te.ALLOWS_FILE_SCHEME_ACCESS = e;
        }),
          Se.extension.isAllowedFileSchemeAccess
            ? Se.extension.isAllowedFileSchemeAccess(e)
            : e(!1);
      })();
      const xt = [];
      let Et = !0;
      const St = (() => {
          const e = [Ze.STORAGE.VERSION, Ze.STORAGE.TYPE],
            t = {};
          return (
            e.forEach((e) => {
              t[e] = !0;
            }),
            {
              keys: e,
              has: function (e) {
                return !!t[e];
              },
            }
          );
        })(),
        Ct = function (e, t) {
          const n = R();
          let r;
          return (
            e == Be.USE && "clean" == t
              ? w.warn("Storage: can't clean currently active storage")
              : (r = Zt[e][t]),
            r
              ? r().then(
                  () => {
                    n.resolve();
                  },
                  () => {
                    n.reject();
                  }
                )
              : n.resolve(),
            n.promise()
          );
        },
        Mt = (() => {
          const e = "s_",
            t = (t) => {
              Z(e + t + "=;expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/");
            },
            n = {
              setValue: (t, n) => {
                const r = R();
                return (
                  ((t, n) => {
                    const r = new Date();
                    r.setTime(r.getTime() + 47304e7);
                    const s = "expires=" + r.toUTCString();
                    Z(e + t + "=" + n + ";" + s + ";path=/");
                  })(t, xe(n)),
                  r.resolve(),
                  r.promise()
                );
              },
              setValues: (e) => {
                const t = [];
                return (
                  Object.keys(e).forEach((r) => {
                    t.push(n.setValue(r, e[r]));
                  }),
                  R.sidebyside(t)
                );
              },
              getValue: (t, n) =>
                Re(
                  ((t) => {
                    const n = e + t + "=",
                      r = U().split(";");
                    for (let e = 0; e < r.length; e++) {
                      let t = r[e];
                      for (; " " == t.charAt(0); ) t = t.substring(1);
                      if (0 == t.indexOf(n))
                        return t.substring(n.length, t.length);
                    }
                    return null;
                  })(t),
                  n
                ),
              deleteAll: () => {
                const e = R();
                return (
                  n.listValues().forEach((e) => {
                    t(e);
                  }),
                  e.resolve(),
                  e.promise()
                );
              },
              deleteValue: (e) => {
                const n = R();
                return t(e), n.resolve(), n.promise();
              },
              listValues: () =>
                (() => {
                  const t = U().split(";"),
                    n = [];
                  for (let r = 0; r < t.length; r++) {
                    const s = t[r].trim(),
                      i = s.indexOf("="),
                      o = s.substr(0, i);
                    o.substr(0, 2) == e && n.push(o.substr(2));
                  }
                  return n;
                })().map((e) => e),
            };
          return n;
        })(),
        It = (() => {
          const e = ae,
            t = {
              setValue: (t, n) => {
                const r = R(),
                  s = t,
                  i = xe(n);
                return (
                  Et && void 0 !== i && e.setItem(s, i),
                  r.resolve(),
                  r.promise()
                );
              },
              setValues: (e) => {
                const n = [];
                return (
                  Object.keys(e).forEach((r) => {
                    n.push(t.setValue(r, e[r]));
                  }),
                  R.sidebyside(n)
                );
              },
              getValue: (t, n) => {
                const r = t;
                return Re(e.getItem(r), n);
              },
              deleteAll: () => {
                const n = R();
                return (
                  Et &&
                    t.listValues().forEach((t) => {
                      St.has(t) || e.removeItem(t);
                    }),
                  n.resolve(),
                  n.promise()
                );
              },
              deleteValue: (t) => {
                const n = R(),
                  r = t;
                return Et && e.removeItem(r), n.resolve(), n.promise();
              },
              listValues: () => {
                const t = [];
                for (let n = 0; n < e.length; n++) {
                  const r = e.key(n);
                  null !== r && t.push(r);
                }
                return t;
              },
            };
          return { options: {}, methods: t };
        })(),
        Gt = (() => {
          let e = !1,
            t = {},
            n = !1,
            r = !1;
          const s = ze.inIncognitoContext ? "incognito" : "normal",
            i = (e, n) => {
              Et &&
                r &&
                "local" == n &&
                e &&
                Object.keys(e).forEach((n) => {
                  const r = e[n],
                    i = r.newValue,
                    o = r.oldValue;
                  i
                    ? "object" == typeof i &&
                      "origin" in i &&
                      i.origin !== s &&
                      (i.value && (t[n] = i.value),
                      Bt.notifyDifferentOriginChangeListeners(n, i.value))
                    : o &&
                      "object" == typeof o &&
                      "origin" in o &&
                      o.origin !== s &&
                      delete t[n];
                });
            },
            o = {
              setValue: (e, n) => {
                const r = R(),
                  i = e;
                if (((t[i] = n), Et)) {
                  const e = {};
                  (e[i] = { origin: s, value: n }), ut.local.set(e, r.resolve);
                } else r.resolve();
                return r.promise();
              },
              setValues: (e) => {
                const n = R(),
                  r = {};
                return (
                  Object.keys(e).forEach((n) => {
                    const i = n,
                      o = e[n];
                    (t[i] = o), Et && (r[i] = { origin: s, value: o });
                  }),
                  Et ? ut.local.set(r, n.resolve) : n.resolve(),
                  n.promise()
                );
              },
              getValue: (e, n) => {
                const r = e;
                return void 0 === t[r] ? n : t[r];
              },
              deleteAll: () => {
                const e = R(),
                  n = ((e, t) => {
                    const n = {};
                    for (const r of t) {
                      const t = e.getValue(r);
                      void 0 !== t && (n[r] = t);
                    }
                    return n;
                  })(o, St.keys);
                return (
                  (t = n),
                  Et
                    ? ut.local.clear(() => {
                        ((e, t) => {
                          const n = R(),
                            r = [];
                          return (
                            Object.getOwnPropertyNames(t).forEach((n) => {
                              void 0 !== t[n] && r.push(e.setValue(n, t[n]));
                            }),
                            R.when(r).done(() => {
                              n.resolve();
                            }),
                            n.promise()
                          );
                        })(o, n).done(e.resolve);
                      })
                    : e.resolve(),
                  e.promise()
                );
              },
              deleteValue: (e) => {
                const n = R(),
                  r = e;
                return (
                  delete t[r],
                  Et ? ut.local.remove(r, n.resolve) : n.resolve(),
                  n.promise()
                );
              },
              listValues: () => {
                const e = [];
                return (
                  Object.getOwnPropertyNames(t).forEach((t) => {
                    e.push(t);
                  }),
                  e
                );
              },
              setTemporary: (e) => {
                (Et = !e), (r = !0);
              },
              isWorking: () => {
                const e = R();
                let t = 0;
                const n = Date.now(),
                  r = "foo",
                  s = {};
                s[r] = { origin: "normal", value: n };
                const i = () => {
                    l && L(l), (l = null);
                  },
                  o = (e) => {
                    ++t <= 5
                      ? (w.warn(
                          "storage:",
                          e || "storage set/get test failed!"
                        ),
                        X(c, t * t * 100))
                      : (w.warn(
                          "storage: storage set/get test finally failed!"
                        ),
                        a());
                  },
                  a = () => {
                    l && (i(), e.reject());
                  };
                let l = X(() => {
                  (l = null), a();
                }, 18e4);
                const c = () => {
                  w.log("Storage: test -> start");
                  const t = Date.now();
                  ut.local.set(s, () => {
                    w.log(
                      "Storage: test -> set after " + (Date.now() - t) + "ms"
                    ),
                      ut.local.get(
                        r,
                        (s) => (
                          w.log(
                            "Storage: test -> get after " +
                              (Date.now() - t) +
                              "ms"
                          ),
                          s && s[r]
                            ? s[r].value !== n
                              ? o(
                                  "read value is different " +
                                    JSON.stringify(s[r]) +
                                    " != " +
                                    JSON.stringify(n)
                                )
                              : qe.lastError
                              ? o(
                                  (qe.lastError && qe.lastError.message) ||
                                    "lastError is set"
                                )
                              : void ut.local.remove(r, () => {
                                  w.log(
                                    "Storage: test -> remove after " +
                                      (Date.now() - t) +
                                      "ms"
                                  ),
                                    l && (i(), e.resolve());
                                })
                            : o("read value is" + JSON.stringify(s))
                        )
                      );
                  });
                };
                return c(), e.promise();
              },
            };
          return {
            init: () => {
              const r = R();
              if (e) r.resolve();
              else {
                e = !0;
                const s = (e) => {
                  (t = {}),
                    e &&
                      Object.keys(e).forEach((n) => {
                        const r = e[n];
                        r &&
                        r.hasOwnProperty("origin") &&
                        r.hasOwnProperty("value")
                          ? (t[n] = r.value)
                          : (t[n] = r);
                      }),
                    n || (ut.onChanged.addListener(i), (n = !0)),
                    r.resolve();
                };
                ut.local.get(null, s);
              }
              return r.promise();
            },
            clean: () => {
              const n = R();
              return (e = !1), (t = {}), n.resolve(), n.promise();
            },
            options: {},
            methods: o,
          };
        })();
      let Ut;
      const Zt = { localStorage: It, chromeStorage: Gt },
        Tt = () => {
          if (Ut) return (Ut.isWorking || R.Pledge)();
          {
            const e = R();
            return (
              X(() => {
                e.consume(Tt());
              }, 1e3),
              e.promise()
            );
          }
        },
        Bt = {
          secure: { cookie: Mt },
          setValue: (e, t) => Ut.setValue(e, t),
          setValues: (e) => Ut.setValues(e),
          getValue: (e, t) => Ut.getValue(e, t),
          deleteAll: () => Ut.deleteAll(),
          deleteValue: (e) => Ut.deleteValue(e),
          listValues: () => Ut.listValues(),
          isWorking: Tt,
          migrate: (e, t, n) => {
            const r = R(),
              s = Zt[e],
              i = Zt[t],
              o = n || {};
            return (
              s && i
                ? Ct(e, "init")
                    .then(() => Ct(t, "init"))
                    .then(() => {
                      const e = R(),
                        t = [];
                      return (
                        s.methods.listValues().forEach((e) => {
                          const n = s.methods.getValue(e);
                          o.drop && t.push(s.methods.deleteValue(e)),
                            void 0 !== n && t.push(i.methods.setValue(e, n));
                        }),
                        R.when(t).done(() => {
                          e.resolve();
                        }),
                        e.promise()
                      );
                    })
                    .then(() => Ct(t, "clean"))
                    .then(() => Ct(e, "clean"))
                    .done(() => {
                      r.resolve();
                    })
                    .fail(() => {
                      r.reject();
                    })
                : (w.error(
                    "Migration: unknown storage implementation(s) ",
                    e,
                    t
                  ),
                  r.reject()),
              r.promise()
            );
          },
          setTemporary: (e) => {
            Et = !e;
          },
          init: () => {
            w.debug("Storage: use " + Be.USE);
            const e = Zt[Be.USE];
            return (Ut = e.methods), e.init ? e.init() : R.Pledge();
          },
          factoryReset: () => (
            ae && ae.removeItem(Ze.STORAGE.LEGACY_VERSION), Bt.deleteAll()
          ),
          isWiped: () => {
            if ("localStorage" === Be.USE || !ae) return R.Pledge(!1);
            const e = R(),
              t = Bt.getValue(Ze.STORAGE.VERSION);
            let n = !1;
            return (
              ae.getItem(Ze.STORAGE.LEGACY_VERSION) &&
                !t &&
                (Bt.listValues().length
                  ? w.warn("storage: unable to find version information")
                  : (n = !0)),
              e.resolve(n),
              e.promise()
            );
          },
          setVersion: (e, t) => {
            const n = R();
            return (
              Et
                ? (ae && ae.setItem(Ze.STORAGE.LEGACY_VERSION, e),
                  Bt.setValue(Ze.STORAGE.VERSION, e)
                    .then(() =>
                      t ? Bt.setValue(Ze.STORAGE.SCHEMA, t) : R.Pledge()
                    )
                    .always(n.resolve))
                : n.resolve(),
              n.promise()
            );
          },
          getVersion: (e) => {
            const t = R(),
              n =
                Bt.getValue(Ze.STORAGE.VERSION) ||
                Bt.getValue(Ze.STORAGE.LEGACY_VERSION) ||
                (ae ? ae.getItem(Ze.STORAGE.LEGACY_VERSION) : null);
            return t.resolve(n || e), t.promise();
          },
          getSchemaVersion: () => Bt.getValue(Ze.STORAGE.SCHEMA, "3.5"),
          addDifferentOriginChangeListener: (e, t) => {
            xt.push({ prefix: e, cb: t });
          },
          notifyDifferentOriginChangeListeners: (e, t) => {
            xt.forEach((n) => {
              e.startsWith(n.prefix) && n.cb(e, t);
            });
          },
          recover: (e) => {
            const t = R();
            "string" == typeof e &&
              (e = { method: e, storages: ["chromeStorage"] });
            const n = {};
            if (
              (e.storages.forEach((e) => {
                n[e] = !0;
              }),
              "log" == e.method)
            ) {
              let e, r;
              const s = [
                  {
                    method: "chromeStorage",
                    fn: (e) => {
                      w.debug("check chromeStorage for data..."),
                        ut.local.get(null, (t) => {
                          (r = t), e();
                        });
                    },
                  },
                  {
                    method: "chromeStorage",
                    fn: (e) => {
                      const t = r ? Object.getOwnPropertyNames(r) : [];
                      r && t.length
                        ? (w.debug("found values:"),
                          t.forEach((e) => {
                            var t;
                            const n =
                              null === (t = r[e]) || void 0 === t
                                ? void 0
                                : t.toString();
                            w.debug(
                              "    ",
                              e,
                              n && n.length > 30 ? n.substr(0, 30) : n
                            );
                          }))
                        : (w.warn("no data found"),
                          (n.chromeStorage = !1),
                          X(e, 1));
                    },
                  },
                ],
                i = () => {
                  if (e) return w.warn("error:", e), void t.resolve();
                  for (const e of s) if (n[e.method]) return void e.fn(i);
                  t.resolve();
                };
              i();
            } else t.resolve();
            return t.promise();
          },
        },
        Ot = Bt,
        Ft = (e) => [...new Set(e)],
        Dt = (e, t, n) => {
          const r = e.indexOf(t);
          if (-1 == r) return "";
          if (!n) return e.substr(r + t.length);
          const s = e.substr(r + t.length).indexOf(n);
          return -1 == s ? "" : e.substr(r + t.length, s);
        },
        jt = (e, t) => {
          null == t && (t = []);
          const n = new RegExp(
            "(\\" +
              ["/", ".", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\"]
                .concat(t)
                .join("|\\") +
              ")",
            "g"
          );
          return e.replace(n, "\\$1");
        },
        Pt = (e) => jt(e, ["*"]),
        Lt = (e) => (({}.toString.apply(e).match(/\s([a-z|A-Z]+)/) || [])[1]),
        Nt = (e, t) => {
          const n = Lt(e);
          if ("Array" === n || "NodeList" === n) {
            for (let n = 0; n < e.length; n++) if (!1 === t(e[n], n)) return;
          } else if ("XPathResult" === n) {
            let n = e.iterateNext(),
              r = 0;
            for (; n; ) {
              if (!1 === t(n, r++)) return;
              n = e.iterateNext();
            }
          } else
            for (const n in e)
              if (e.hasOwnProperty(n) && !1 === t(e[n], n)) return;
        },
        Vt = (e, t, n, r) => e.slice(0, t) + r + e.slice(t + Math.abs(n)),
        zt = (e, t, n, r) => {
          let s;
          if (Array.isArray(n)) {
            const e = {};
            n.forEach((t) => {
              e[t] = !0;
            }),
              (s = e);
          } else s = n;
          return (
            Nt(s || e, (n, i) => {
              if (!s || s.hasOwnProperty(i)) {
                let n;
                const o = e[i],
                  a = Lt(o);
                if ("Undefined" == a) return;
                if (
                  s &&
                  r &&
                  (n = Lt(s[i])) &&
                  n !== a &&
                  ("Array" === n || "Object" === n)
                )
                  return;
                "Object" == a
                  ? ((t[i] = {}), zt(o, t[i], s ? s[i] : null))
                  : "Array" == a
                  ? ((t[i] = []), zt(o, t[i]))
                  : (t[i] = o);
              }
            }),
            t
          );
        },
        qt = (e, t) => {
          let n = !0;
          if (
            "object" != typeof e ||
            "object" != typeof t ||
            null === e ||
            null === t
          )
            return e === t;
          for (const [r, s] of Object.entries(t))
            if (
              void 0 !== s &&
              ((n =
                void 0 !== e[r] &&
                (null === s
                  ? null === e[r]
                  : "object" == typeof s
                  ? qt(e[r], s)
                  : e[r] === s)),
              !n)
            )
              break;
          return n;
        },
        Ht = (e) =>
          (() => {
            let t = {};
            const n = e || 1e3,
              r = {
                clear: () => {
                  Nt(t, (e) => L(e)), (t = {});
                },
                is: (e, n) => {
                  const s = void 0 !== t[e];
                  return n && r.add(e), s;
                },
                add: (e, s) => {
                  r.is(e) && L(t[e]),
                    (t[e] = X(() => {
                      delete t[e];
                    }, s || n));
                },
              };
            return r;
          })(),
        Qt = (e) => (Array.isArray(e) ? e : [e]),
        Wt = (e, t, n = "both") =>
          "notinfirst" == n
            ? t.filter((t) => !e.includes(t))
            : e.concat(t).filter((n) => !e.includes(n) || !t.includes(n)),
        Xt = () =>
          "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e) => {
            const t = (16 * Math.random()) | 0;
            return ("x" == e ? t : (3 & t) | 8).toString(16);
          }),
        Yt = (e, t) => {
          const n = [];
          for (let r = 0, s = e.length; r < s; r += t)
            n.push(e.slice(r, t + r));
          return n;
        },
        Jt = (e) => ({
          utm_source: "ext",
          utm_medium: e.substr(0, 3),
          utm_campaign: Pe.short_id,
        }),
        Kt = {
          protocol: "https:",
          www: "www",
          api: "api",
          domain: "userscript.zone",
        },
        $t = [
          {
            name: "ECMAScript 5",
            value: [
              "// ==UserScript==",
              "// @name         New Userscript",
              "// @namespace    http://tampermonkey.net/",
              "// @version      <$DATE$>",
              "// @description  try to take over the world!",
              "// @author       You",
              "// @match        <$URL$>",
              "// @icon         <$ICON$>",
              "// @grant        none",
              "// ==/UserScript==",
              "",
              "(function() {",
              "    'use strict';",
              "",
              "    // Your code here...",
              "})();",
            ].join("\n"),
          },
          {
            name: "ECMAScript 6",
            value: [
              "// ==UserScript==",
              "// @name         New ES6-Userscript",
              "// @namespace    http://tampermonkey.net/",
              "// @version      <$DATE$>",
              "// @description  shows how to use babel compiler",
              "// @author       You",
              "// @require      https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.18.2/babel.js",
              "// @require      https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/6.16.0/polyfill.js",
              "// @match        <$URL$>",
              "// @icon         <$ICON$>",
              "// ==/UserScript==",
              "",
              "var inline_src = (<><![CDATA[",
              "",
              "    // Your code here...",
              "",
              "]]></>).toString();",
              'var c = Babel.transform(inline_src, { presets: [ "es2015", "es2016" ] });',
              "eval(c.code);",
            ].join("\n"),
          },
          {
            name: "CoffeeScript",
            value: [
              "// ==UserScript==",
              "// @name         New Coffee-Userscript",
              "// @namespace    http://tampermonkey.net/",
              "// @version      <$DATE$>",
              "// @description  shows how to use coffeescript compiler",
              "// @author       You",
              "// @require      http://coffeescript.org/browser-compiler/coffeescript.js",
              "// @match        <$URL$>",
              "// @icon         <$ICON$>",
              "// ==/UserScript==",
              "",
              "var inline_src = (<><![CDATA[",
              "",
              "    // Your code here",
              "",
              "]]></>).toString();",
              "var compiled = this.CoffeeScript.compile(inline_src);",
              "eval(compiled);",
            ].join("\n"),
          },
        ],
        en = {},
        tn = {
          enabled: !0,
          configMode: 0,
          debug: !1,
          logLevel: 0,
          showFixedSrc: !1,
          webrequest_modHeaders: "yes",
          webrequest_fixCSP: "auto",
          webrequest_fixContentCSP: "no",
          notification_showUpdate: "changelog",
          notification_silentScriptUpdate: !0,
          script_templates: $t,
          scriptUpdateCheckPeriod: 864e5,
          scriptUpdateHideNotificationAfter: 15e3,
          scriptUpdateCheckDisabled: !1,
          scriptUrlDetection: "auto",
          script_file_access: "externals",
          trash_mode: "on",
          trash_cleanup_after: 6048e5,
          runtime_strict_mode: "byscript",
          runtime_top_level_await: "default",
          runtime_inject_mode: "default",
          runtime_content_mode: "content",
          autoReload: !1,
          appearance_badges: "running",
          appearance_badge_color: ["gcal", "fcmf", "firb", "heif"].includes(
            qe.short_id
          )
            ? "#444"
            : "#ee3131",
          appearance_badge_text_color: "#ffffff",
          context_menu_enabled: !0,
          context_menu_scripts: !0,
          context_menu_commands: !0,
          editor_enabled: !0,
          editor_fontSize: 100,
          editor_theme: "default",
          editor_keyMap: "windows",
          editor_indentUnit: 4,
          editor_tabSize: 4,
          editor_indentWithTabs: "spaces",
          editor_tabMode: "indent",
          editor_electricChars: !0,
          editor_autoSave: !1,
          editor_easySave: !0,
          editor_autoLint: !0,
          editor_autoLintMaxLen: 1e6,
          editor_lineWrapping: !1,
          userscript_search_url: Kt,
          userscript_search_mode: "off",
          editor_highlightTrailingWhitespace: !0,
          editor_trimTrailingSpacesFromModifiedLines: !0,
          editor_highlightSelectionMatches: "cursor",
          editor_linter_config: null,
          favicon_service: "google",
          i18n: null,
          action_menu_columns: 1,
          action_menu_scripts_hide_disabled: !1,
          action_menu_scripts_sort: "auto",
          incognito_mode: "temporary",
          layout: "default",
          layout_user_css: "",
          sync_enabled: !1,
          sync_type: 2,
          statistics_enabled: !0,
          default_tab_types: "incognito+normal",
          downloads_mode: "default",
          downloads_extension_whitelist: [
            "/^[^\\.]*$/",
            "/\\.(mp[34a]|m4[ab]|m3u|wma|wav|aac|og[ag]|cda|flac)$/",
            "/\\.(avi|mkv|flv|divx|mpe?g|webm)$/",
            "/\\.(ico|gif|png|jpe?g|webp|svg)/",
            "/\\.(srt|sub|idx)$/",
            "/\\.(ttf|otf|woff)$/",
            "/\\.(txt|pdf|yml)$/",
            ".iso",
            ".zip",
            "/\\.r(ar|[0-9]{2,2})$/",
            ".rss",
          ],
          external_update_interval: 0,
          external_connect: "all",
          require_timeout: 2e4,
          require_blacklist: ["/^https?:\\/\\/example.com(:[0-9]{1,5})?\\/.*/"],
          require_sri_mode: "supported",
          sandbox_mode: "default",
          script_include_mode: "default",
          script_blacklist_server: [],
          script_blacklist_type: "server",
          script_blacklist_severity: 4,
          background_control: !1,
          connect_mode: "ask",
          page_filter_mode: "black",
          page_whitelist: [
            "/https?:\\/\\/greasyfork\\.org\\/.*/",
            "http://xkcd.com/970/",
          ],
          forbiddenPages: [
            "*example.org/*",
            "*paypal.tld/*",
            "*stripe.com/*",
            "https://*deutsche-bank-24.tld/*",
            "https://*bankofamerica.tld/*",
            "/^.*:\\/\\/apis\\.google\\.com\\/((?!render)([^\\/]+)\\/)+([^\\/]+)?$/",
            "*://www.facebook.com/plugins/*",
            "*://platform.twitter.com/widgets/*",
            "https://vscode.dev/?connectTo=tampermonkey",
          ],
        },
        nn = { cloud_url: null, cloud_user: null, cloud_pass: null },
        rn = (e) => {
          let t,
            n = Ot.getValue(Ze.STORAGE.CONFIG, {});
          return (
            n instanceof Object || (n = {}),
            void 0 !== (t = n[e])
              ? t
              : "function" == typeof (t = tn[e])
              ? t()
              : t
          );
        },
        sn = (e, t) => {
          let n = Ot.getValue(Ze.STORAGE.CONFIG, {});
          n instanceof Object || (n = {});
          const r = rn(e);
          n[e] = t;
          const s = Ot.setValue(Ze.STORAGE.CONFIG, n),
            i = en[e];
          return (
            i &&
              JSON.stringify(r) != JSON.stringify(t) &&
              i.forEach((n) => {
                try {
                  n(e, r, t, s);
                } catch (e) {
                  w.warn("config: changeListener error", e);
                }
              }),
            s
          );
        };
      let on = {};
      (() => {
        let e;
        if (ae && (e = ae.getItem(Ze.STORAGE.SESSION)))
          try {
            on = JSON.parse(pe(e));
          } catch (e) {}
      })();
      const an = (e) => {
          let t;
          return void 0 !== (t = on[e]) ? t : nn[e];
        },
        ln = (e, t) => {
          const n = an(e);
          void 0 === t ? delete on[e] : (on[e] = t),
            ae && ae.setItem(Ze.STORAGE.SESSION, he(JSON.stringify(on)));
          const r = en[e];
          return (
            r &&
              JSON.stringify(n) != JSON.stringify(t) &&
              r.forEach((r) => {
                try {
                  r(e, n, t);
                } catch (e) {
                  w.warn("config: changeListener error", e);
                }
              }),
            R.Pledge()
          );
        },
        cn = {
          initialized: !1,
          values: {},
          snapshot: {},
          init: () => {
            const e = {};
            return (
              Object.defineProperty(cn, "snapshot", {
                get: function () {
                  return { ...cn.values };
                },
                enumerable: !0,
              }),
              Object.keys(tn).forEach((t) => {
                Object.defineProperty(e, t, {
                  get: function () {
                    return rn(t);
                  },
                  set: function (e) {
                    sn(t, e);
                  },
                  enumerable: !0,
                });
              }),
              Object.keys(nn).forEach((t) => {
                Object.defineProperty(e, t, {
                  get: function () {
                    return an(t);
                  },
                  set: function (e) {
                    ln(t, e);
                  },
                  enumerable: !0,
                });
              }),
              (cn.values = e),
              (cn.initialized = !0),
              R.Pledge()
            );
          },
          defaultScripts: async () => [],
          getValue: (e) => (nn.hasOwnProperty(e) ? an(e) : rn(e)),
          setValue: (e, t) => (nn.hasOwnProperty(e) ? ln(e, t) : sn(e, t)),
          getDefaults: () => tn,
          addChangeListener: (e, t) => {
            Qt(e).forEach((e) => {
              let n = en[e];
              n || (n = en[e] = []), n.push(t);
            });
          },
        },
        un = cn,
        An = ".tld",
        dn =
          "aaa\naarp\nabb\nabbott\nabogado\nac\nacademy\naccenture\naccountant\naccountants\naco\nactive\nactor\nad\nadac\nads\nadult\nae\naeg\naero\naf\nafl\nag\nagency\nai\naig\nairforce\nairtel\nal\nalibaba\nalipay\nallfinanz\nalsace\nam\namica\namsterdam\nan\nanalytics\nandroid\nao\napartments\napp\napple\naq\naquarelle\nar\naramco\narchi\narmy\narpa\narte\nas\nasia\nassociates\nat\nattorney\nau\nauction\naudi\naudio\nauthor\nauto\nautos\naw\nax\naxa\naz\nazure\nba\nbaidu\nband\nbank\nbar\nbarcelona\nbarclaycard\nbarclays\nbargains\nbauhaus\nbayern\nbb\nbbc\nbbva\nbcn\nbd\nbe\nbeats\nbeer\nbentley\nberlin\nbest\nbet\nbf\nbg\nbh\nbharti\nbi\nbible\nbid\nbike\nbing\nbingo\nbio\nbiz\nbj\nbl\nblack\nblackfriday\nbloomberg\nblue\nbm\nbms\nbmw\nbn\nbnl\nbnpparibas\nbo\nboats\nboehringer\nbom\nbond\nboo\nbook\nboots\nbosch\nbostik\nbot\nboutique\nbq\nbr\nbradesco\nbridgestone\nbroadway\nbroker\nbrother\nbrussels\nbs\nbt\nbudapest\nbugatti\nbuild\nbuilders\nbusiness\nbuy\nbuzz\nbv\nbw\nby\nbz\nbzh\nca\ncab\ncafe\ncal\ncall\ncamera\ncamp\ncancerresearch\ncanon\ncapetown\ncapital\ncar\ncaravan\ncards\ncare\ncareer\ncareers\ncars\ncartier\ncasa\ncash\ncasino\ncat\ncatering\ncba\ncbn\ncc\ncd\nceb\ncenter\nceo\ncern\ncf\ncfa\ncfd\ncg\nch\nchanel\nchannel\nchat\ncheap\nchloe\nchristmas\nchrome\nchurch\nci\ncipriani\ncircle\ncisco\ncitic\ncity\ncityeats\nck\ncl\nclaims\ncleaning\nclick\nclinic\nclinique\nclothing\ncloud\nclub\nclubmed\ncm\ncn\nco\ncoach\ncodes\ncoffee\ncollege\ncologne\ncom\ncommbank\ncommunity\ncompany\ncompare\ncomputer\ncomsec\ncondos\nconstruction\nconsulting\ncontact\ncontractors\ncooking\ncool\ncoop\ncorsica\ncountry\ncoupons\ncourses\ncr\ncredit\ncreditcard\ncreditunion\ncricket\ncrown\ncrs\ncruises\ncsc\ncu\ncuisinella\ncv\ncw\ncx\ncy\ncymru\ncyou\ncz\ndabur\ndad\ndance\ndate\ndating\ndatsun\nday\ndclk\nde\ndealer\ndeals\ndegree\ndelivery\ndell\ndeloitte\ndelta\ndemocrat\ndental\ndentist\ndesi\ndesign\ndev\ndiamonds\ndiet\ndigital\ndirect\ndirectory\ndiscount\ndj\ndk\ndm\ndnp\ndo\ndocs\ndog\ndoha\ndomains\ndoosan\ndownload\ndrive\ndubai\ndurban\ndvag\ndz\nearth\neat\nec\nedeka\nedu\neducation\nee\neg\neh\nemail\nemerck\nenergy\nengineer\nengineering\nenterprises\nepson\nequipment\ner\nerni\nes\nesq\nestate\net\neu\neurovision\neus\nevents\neverbank\nexchange\nexpert\nexposed\nexpress\nfage\nfail\nfairwinds\nfaith\nfamily\nfan\nfans\nfarm\nfashion\nfast\nfeedback\nferrero\nfi\nfilm\nfinal\nfinance\nfinancial\nfirestone\nfirmdale\nfish\nfishing\nfit\nfitness\nfj\nfk\nflickr\nflights\nflorist\nflowers\nflsmidth\nfly\nfm\nfo\nfoo\nfootball\nford\nforex\nforsale\nforum\nfoundation\nfox\nfr\nfresenius\nfrl\nfrogans\nfrontier\nfund\nfurniture\nfutbol\nfyi\nga\ngal\ngallery\ngallup\ngame\ngarden\ngb\ngbiz\ngd\ngdn\nge\ngea\ngent\ngenting\ngf\ngg\nggee\ngh\ngi\ngift\ngifts\ngives\ngiving\ngl\nglass\ngle\nglobal\nglobo\ngm\ngmail\ngmo\ngmx\ngn\ngold\ngoldpoint\ngolf\ngoo\ngoog\ngoogle\ngop\ngot\ngov\ngp\ngq\ngr\ngrainger\ngraphics\ngratis\ngreen\ngripe\ngroup\ngs\ngt\ngu\ngucci\nguge\nguide\nguitars\nguru\ngw\ngy\nhamburg\nhangout\nhaus\nhdfcbank\nhealth\nhealthcare\nhelp\nhelsinki\nhere\nhermes\nhiphop\nhitachi\nhiv\nhk\nhm\nhn\nhockey\nholdings\nholiday\nhomedepot\nhomes\nhonda\nhorse\nhost\nhosting\nhoteles\nhotmail\nhouse\nhow\nhr\nhsbc\nht\nhu\nhyundai\nibm\nicbc\nice\nicu\nid\nie\nifm\niinet\nil\nim\nimmo\nimmobilien\nin\nindustries\ninfiniti\ninfo\ning\nink\ninstitute\ninsurance\ninsure\nint\ninternational\ninvestments\nio\nipiranga\niq\nir\nirish\nis\niselect\nist\nistanbul\nit\nitau\niwc\njaguar\njava\njcb\nje\njetzt\njewelry\njlc\njll\njm\njmp\njo\njobs\njoburg\njot\njoy\njp\njprs\njuegos\nkaufen\nkddi\nke\nkfh\nkg\nkh\nki\nkia\nkim\nkinder\nkitchen\nkiwi\nkm\nkn\nkoeln\nkomatsu\nkp\nkpn\nkr\nkrd\nkred\nkw\nky\nkyoto\nkz\nla\nlacaixa\nlamborghini\nlamer\nlancaster\nland\nlandrover\nlanxess\nlasalle\nlat\nlatrobe\nlaw\nlawyer\nlb\nlc\nlds\nlease\nleclerc\nlegal\nlexus\nlgbt\nli\nliaison\nlidl\nlife\nlifeinsurance\nlifestyle\nlighting\nlike\nlimited\nlimo\nlincoln\nlinde\nlink\nlive\nliving\nlixil\nlk\nloan\nloans\nlol\nlondon\nlotte\nlotto\nlove\nlr\nls\nlt\nltd\nltda\nlu\nlupin\nluxe\nluxury\nlv\nly\nma\nmadrid\nmaif\nmaison\nmakeup\nman\nmanagement\nmango\nmarket\nmarketing\nmarkets\nmarriott\nmba\nmc\nmd\nme\nmed\nmedia\nmeet\nmelbourne\nmeme\nmemorial\nmen\nmenu\nmeo\nmf\nmg\nmh\nmiami\nmicrosoft\nmil\nmini\nmk\nml\nmm\nmma\nmn\nmo\nmobi\nmobily\nmoda\nmoe\nmoi\nmom\nmonash\nmoney\nmontblanc\nmormon\nmortgage\nmoscow\nmotorcycles\nmov\nmovie\nmovistar\nmp\nmq\nmr\nms\nmt\nmtn\nmtpc\nmtr\nmu\nmuseum\nmutuelle\nmv\nmw\nmx\nmy\nmz\nna\nnadex\nnagoya\nname\nnatura\nnavy\nnc\nne\nnec\nnet\nnetbank\nnetwork\nneustar\nnew\nnews\nnexus\nnf\nng\nngo\nnhk\nni\nnico\nnikon\nninja\nnissan\nnl\nno\nnokia\nnorton\nnowruz\nnp\nnr\nnra\nnrw\nntt\nnu\nnyc\nnz\nobi\noffice\nokinawa\nom\nomega\none\nong\nonl\nonline\nooo\noracle\norange\norg\norganic\norigins\nosaka\notsuka\novh\npa\npage\npamperedchef\npanerai\nparis\npars\npartners\nparts\nparty\npe\npet\npf\npg\nph\npharmacy\nphilips\nphoto\nphotography\nphotos\nphysio\npiaget\npics\npictet\npictures\npid\npin\nping\npink\npizza\npk\npl\nplace\nplay\nplaystation\nplumbing\nplus\npm\npn\npohl\npoker\nporn\npost\npr\npraxi\npress\npro\nprod\nproductions\nprof\npromo\nproperties\nproperty\nprotection\nps\npt\npub\npw\npwc\npy\nqa\nqpon\nquebec\nquest\nracing\nre\nread\nrealtor\nrealty\nrecipes\nred\nredstone\nredumbrella\nrehab\nreise\nreisen\nreit\nren\nrent\nrentals\nrepair\nreport\nrepublican\nrest\nrestaurant\nreview\nreviews\nrexroth\nrich\nricoh\nrio\nrip\nro\nrocher\nrocks\nrodeo\nroom\nrs\nrsvp\nru\nruhr\nrun\nrw\nrwe\nryukyu\nsa\nsaarland\nsafe\nsafety\nsakura\nsale\nsalon\nsamsung\nsandvik\nsandvikcoromant\nsanofi\nsap\nsapo\nsarl\nsas\nsaxo\nsb\nsbs\nsc\nsca\nscb\nschaeffler\nschmidt\nscholarships\nschool\nschule\nschwarz\nscience\nscor\nscot\nsd\nse\nseat\nsecurity\nseek\nselect\nsener\nservices\nseven\nsew\nsex\nsexy\nsfr\nsg\nsh\nsharp\nshell\nshia\nshiksha\nshoes\nshow\nshriram\nsi\nsingles\nsite\nsj\nsk\nski\nskin\nsky\nskype\nsl\nsm\nsmile\nsn\nsncf\nso\nsoccer\nsocial\nsoftbank\nsoftware\nsohu\nsolar\nsolutions\nsony\nsoy\nspace\nspiegel\nspreadbetting\nsr\nsrl\nss\nst\nstada\nstar\nstarhub\nstatefarm\nstatoil\nstc\nstcgroup\nstockholm\nstorage\nstudio\nstudy\nstyle\nsu\nsucks\nsupplies\nsupply\nsupport\nsurf\nsurgery\nsuzuki\nsv\nswatch\nswiss\nsx\nsy\nsydney\nsymantec\nsystems\nsz\ntab\ntaipei\ntaobao\ntatamotors\ntatar\ntattoo\ntax\ntaxi\ntc\ntci\ntd\nteam\ntech\ntechnology\ntel\ntelefonica\ntemasek\ntennis\ntf\ntg\nth\nthd\ntheater\ntheatre\ntickets\ntienda\ntiffany\ntips\ntires\ntirol\ntj\ntk\ntl\ntm\ntmall\ntn\nto\ntoday\ntokyo\ntools\ntop\ntoray\ntoshiba\ntours\ntown\ntoyota\ntoys\ntp\ntr\ntrade\ntrading\ntraining\ntravel\ntravelers\ntravelersinsurance\ntrust\ntrv\ntt\ntube\ntui\ntushu\ntv\ntvs\ntw\ntz\nua\nubs\nug\nuk\num\nunicom\nuniversity\nuno\nuol\nus\nuy\nuz\nva\nvacations\nvana\nvc\nve\nvegas\nventures\nverisign\nversicherung\nvet\nvg\nvi\nviajes\nvideo\nvillas\nvin\nvip\nvirgin\nvision\nvista\nvistaprint\nviva\nvlaanderen\nvn\nvodka\nvolkswagen\nvote\nvoting\nvoto\nvoyage\nvu\nwales\nwalter\nwang\nwanggou\nwatch\nwatches\nweather\nweatherchannel\nwebcam\nweber\nwebsite\nwed\nwedding\nweir\nwf\nwhoswho\nwien\nwiki\nwilliamhill\nwin\nwindows\nwine\nwme\nwolterskluwer\nwork\nworks\nworld\nws\nwtc\nwtf\nxbox\nxerox\nxin\n测试\nकॉम\nपरीक्षा\n佛山\n慈善\n集团\n在线\n한국\n点看\nคอม\nভারত\n八卦\n‏موقع‎\nবাংলা\n公益\n公司\n移动\n我爱你\nмосква\nиспытание\nқаз\nонлайн\nсайт\n联通\nсрб\nбел\n‏קום‎\n时尚\n테스트\n淡马锡\nорг\nनेट\n삼성\nசிங்கப்பூர்\n商标\n商店\n商城\nдети\nмкд\n‏טעסט‎\nею\nポイント\n新闻\n工行\n‏كوم‎\n中文网\n中信\n中国\n中國\n娱乐\n谷歌\nభారత్\nලංකා\n购物\n測試\nભારત\nभारत\n‏آزمایشی‎\nபரிட்சை\n网店\nसंगठन\n餐厅\n网络\nком\nукр\n香港\n诺基亚\nδοκιμή\n飞利浦\n‏إختبار‎\n台湾\n台灣\n手表\n手机\nмон\n‏الجزائر‎\n‏عمان‎\n‏ارامكو‎\n‏ایران‎\n‏امارات‎\n‏بازار‎\n‏پاکستان‎\n‏الاردن‎\n‏موبايلي‎\n‏بھارت‎\n‏المغرب‎\n‏السعودية‎\n‏سودان‎\n‏همراه‎\n‏عراق‎\n‏مليسيا‎\n澳門\n닷컴\n政府\n‏شبكة‎\n‏بيتك‎\nგე\n机构\n组织机构\n健康\nไทย\n‏سورية‎\nрус\nрф\n珠宝\n‏تونس‎\n大拿\nみんな\nグーグル\nελ\n世界\nਭਾਰਤ\n网址\n닷넷\nコム\n游戏\nvermögensberater\nvermögensberatung\n企业\n信息\n‏مصر‎\n‏قطر‎\n广东\nஇலங்கை\nஇந்தியா\nհայ\n新加坡\n‏فلسطين‎\nテスト\n政务\nxperia\nxxx\nxyz\nyachts\nyahoo\nyamaxun\nyandex\nye\nyodobashi\nyoga\nyokohama\nyoutube\nyt\nza\nzara\nzero\nzip\nzm\nzone\nzuerich\nzw"
            .split("\n")
            .join("|"),
        hn =
          "ac.cn\nac.jp\nac.uk\nad.jp\nah.cn\naichi.jp\nakita.jp\naomori.jp\nasn.au\nbj.cn\nchiba.jp\nco.cc\nco.ck\nco.fk\nco.gg\nco.im\nco.in\nco.ir\nco.je\nco.jp\nco.kr\nco.ma\ncom.ac\ncom.af\ncom.ag\ncom.ai\ncom.al\ncom.ar\ncom.au\ncom.aw\ncom.az\ncom.ba\ncom.bb\ncom.bh\ncom.bi\ncom.bm\ncom.bo\ncom.br\ncom.bs\ncom.bt\ncom.by\ncom.bz\ncom.ci\ncom.cm\ncom.cn\ncom.co\ncom.cu\ncom.cw\ncom.cy\ncom.de\ncom.dm\ncom.do\ncom.dz\ncom.ec\ncom.ee\ncom.eg\ncom.es\ncom.et\ncom.fr\ncom.ge\ncom.gh\ncom.gi\ncom.gl\ncom.gn\ncom.gp\ncom.gr\ncom.gt\ncom.gu\ncom.gy\ncom.hk\ncom.hn\ncom.hr\ncom.ht\ncom.im\ncom.io\ncom.iq\ncom.is\ncom.jo\ncom.kg\ncom.ki\ncom.km\ncom.kp\ncom.ky\ncom.kz\ncom.la\ncom.lb\ncom.lc\ncom.lk\ncom.lr\ncom.lv\ncom.ly\ncom.mg\ncom.mk\ncom.ml\ncom.mo\ncom.ms\ncom.mt\ncom.mu\ncom.mv\ncom.mw\ncom.mx\ncom.my\ncom.na\ncom.nf\ncom.ng\ncom.ni\ncom.nr\ncom.om\ncom.pa\ncom.pe\ncom.pf\ncom.ph\ncom.pk\ncom.pl\ncom.pr\ncom.ps\ncom.pt\ncom.py\ncom.qa\ncom.re\ncom.ro\ncom.ru\ncom.rw\ncom.sa\ncom.sb\ncom.sc\ncom.sd\ncom.se\ncom.sg\ncom.sh\ncom.sl\ncom.sn\ncom.so\ncom.st\ncom.sv\ncom.sy\ncom.tj\ncom.tm\ncom.tn\ncom.to\ncom.tr\ncom.tt\ncom.tw\nco.mu\ncom.ua\ncom.ug\ncom.uy\ncom.uz\ncom.vc\ncom.ve\ncom.vi\ncom.vn\ncom.vu\ncom.ws\ncom.zm\nconf.au\nco.nz\nco.rw\nco.th\nco.tj\nco.tt\nco.tv\nco.tz\nco.ug\nco.uk\nco.us\nco.ve\nco.yu\nco.za\nco.zm\nco.zw\ncq.cn\ncsiro.au\nde.net\ndk.org\ned.jp\nedu.au\nedu.cn\nedu.uk\nehime.jp\neu.org\nfukui.jp\nfukuoka.jp\nfukushima.jp\ngb.net\ngd.cn\ngifu.jp\ngo.jp\ngov.au\ngov.cn\ngov.jp\ngov.uk\ngr.jp\ngs.cn\ngunma.jp\ngx.cn\ngz.cn\nhb.cn\nhe.cn\nhi.cn\nhiroshima.jp\nhk.cn\nhl.cn\nhn.cn\nhokkaido.jp\nhyogo.jp\nibaraki.jp\nid.au\ninfo.au\nishikawa.jp\niwate.jp\njl.cn\njs.cn\nkagawa.jp\nkagoshima.jp\nkanagawa.jp\nkanazawa.jp\nkawasaki.jp\nkitakyushu.jp\nkobe.jp\nkochi.jp\nkumamoto.jp\nkyoto.jp\nlg.jp\nln.cn\nltd.uk\nmatsuyama.jp\nme.uk\nmie.jp\nmiyagi.jp\nmiyazaki.jp\nmo.cn\nmod.uk\nnagano.jp\nnagasaki.jp\nnagoya.jp\nnara.jp\nne.jp\nnet.au\nnet.cn\nnet.jp\nnet.uk\nnhs.uk\nnic.uk\nniigata.jp\nnm.cn\nnx.cn\noita.jp\nokayama.jp\nokinawa.jp\norg.au\norg.cn\norg.jp\norg.uk\nor.jp\nosaka.jp\notc.au\noz.au\nplc.uk\npolice.uk\nqh.cn\nsaga.jp\nsaitama.jp\nsapporo.jp\nsc.cn\nsch.uk\nsendai.jp\nsh.cn\nshiga.jp\nshimane.jp\nshizuoka.jp\nsn.cn\nsx.cn\ntakamatsu.jp\ntelememo.au\ntj.cn\ntochigi.jp\ntokushima.jp\ntokyo.jp\ntottori.jp\ntoyama.jp\ntw.cn\nuk.net\nutsunomiya.jp\nwakayama.jp\nxj.cn\nxz.cn\nyamagata.jp\nyamaguchi.jp\nyamanashi.jp\nyn.cn\nyokohama.jp\nzj.cn"
            .split("\n")
            .join("|"),
        pn = (".(" + [dn, hn].join("|") + ")").replace(/\./gi, "\\."),
        fn = G({
          timeout: 180,
          check_interval: 120,
          retimeout_on_get: !0,
        }),
        mn = /^([^:]+:\/\/)([^/]+)(.*)?/,
        gn = (e) =>
          e
            .split("")
            .map((e) => {
              const t = e.toLowerCase(),
                n = e.toUpperCase();
              return t != n ? "[" + t + n + "]" : e;
            })
            .join(""),
        vn = "://",
        _n = (e, t) => {
          let {
            scheme: n,
            host: r,
            path: s,
          } = ((e) => {
            let t, n, r, s;
            const i = "/",
              o = e.replace(/\$$/, "").split(vn);
            o.length < 2
              ? ((t = ""), (n = e))
              : ((t = o[0].replace(/^\^/, "")), (n = o.slice(1).join(vn)));
            const a = n.split(i);
            if (
              ((s = a.length < 2 ? "/" : i + a.slice(1).join(i)),
              (r = a[0]),
              "http*" === t
                ? (t = "https<1>")
                : t.match(/\*|http|https|file|ftp/) ||
                  (w.warn('uri: override scheme "' + t + '" with "*"'),
                  (t = "*")),
              "file" === t)
            )
              r = "";
            else {
              const e = r,
                t = r.match(/\*$|(\*\.)?[^/*]+/);
              (r = (t ? t[0] : "").replace(/:[0-9]*$/, "")),
                r !== e &&
                  w.warn('uri: override host "' + e + '" with "' + r + '"');
            }
            return (
              (s && s.substr(0, 1) === i) ||
                (w.warn('uri: prefix path "' + s + '" with "/"'), (s = i + s)),
              { scheme: t, host: r, path: s }
            );
          })(e);
          return (
            (n = jt(n).replace(/\*/gi, "[^:/#?]*")),
            (r = jt(r)
              .replace(/\*\\\./gi, "(*\\.)?")
              .replace(/\*/gi, "[^#?/]*")),
            (s = jt(s).replace(/\*/gi, ".*")),
            (n = n.replace(/<1>/g, "?")),
            (r = r.replace(new RegExp(jt(An) + "$"), pn)),
            t
              ? ((n = n.toLowerCase()), (r = r.toLowerCase()))
              : ((n = gn(n)), (r = gn(r))),
            (r += "(:[0-9]{1,5})?"),
            "^" + n + jt(vn) + r + s + "$"
          );
        },
        wn = ["protocol", "hostname", "origin"],
        bn = ["port"],
        yn = ["pathname"],
        kn = ["search", "hash"];
      let Rn;
      const xn = {
          protocol: "",
          scheme: "",
          origin: "",
          pathname: "",
          hostname: "",
          port: void 0,
          search: "",
          hash: "",
        },
        En = (e, t) => {
          let n = Object.assign({}, xn);
          if (null == e);
          else if (["data:", "view-source:"].some((t) => e.startsWith(t))) {
            n.origin = "null";
            const t = e.indexOf(":");
            (n.protocol = e.substr(0, t + 1)), (n.pathname = e.substr(t + 1));
          } else {
            let r, s;
            try {
              r = new URL(e);
            } catch (t) {
              try {
                const t = "http:";
                (s = Xt()), (r = new URL(e || "/", `${t}//${s}/${s}`));
              } catch (e) {
                s = void 0;
              }
            }
            if (r) {
              let {
                protocol: i,
                origin: o,
                pathname: a,
                hostname: l,
                port: c,
                search: u,
                hash: A,
                username: d,
                password: h,
              } = r;
              if (
                (s && ((i = l = o = ""), (a = a.replace(`/${s}`, ""))),
                (n = {
                  protocol: i,
                  origin: o,
                  pathname: a,
                  hostname: l,
                  port: parseInt(c) || void 0,
                  search: u,
                  hash: A,
                  username: d,
                  password: h,
                }),
                !t && i)
              ) {
                if (0 !== e.toLowerCase().indexOf(i))
                  if (e.startsWith("//")) (n.origin = ""), (n.protocol = "");
                  else {
                    if (!["/", "?", "#"].includes(e[0])) return En("/" + e);
                    (Rn = Rn || En("", !0)),
                      [...kn, ...yn].forEach((e) => {
                        Rn[e] === n[e] && (n[e] = "");
                      }),
                      wn.forEach((e) => {
                        n[e] = "";
                      }),
                      bn.forEach((e) => {
                        n[e] = void 0;
                      });
                  }
                ["tampermonkey:"].includes(n.protocol) &&
                  ((n.pathname = (
                    (n.hostname ? "/" + n.hostname : "") + (n.pathname || "")
                  ).replace(/^\/+/, "/")),
                  (n.hostname = ""));
              }
            }
          }
          return (
            0 === n.port && (n.port = void 0),
            Object.defineProperties(n, {
              domain: {
                get: function () {
                  const e = n.hostname.split("."),
                    t = e.pop();
                  let r = `${e.pop()}.${t}`;
                  return Gn(r) && (r = `${e.pop()}.${r}`), r;
                },
              },
              scheme: {
                get: function () {
                  return n.protocol.replace(/:$/, "");
                },
              },
            }),
            n
          );
        },
        Sn =
          /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
        Cn =
          /((^\s*((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))\s*$)|(^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$))/;
      let Mn;
      const In = (e) => {
          return !(!(t = e).match(Sn) && !t.match(Cn) && e.includes("."));
          var t;
        },
        Gn = (e) => (
          (Mn = Mn || new RegExp("^(" + hn.replace(/\./g, "\\.") + ")$")),
          !!e.match(Mn)
        ),
        Un = (e, t, n) => {
          let r = !1;
          const s = Zn(e);
          let i = e;
          if (s)
            return (
              "tampermonkey:" == s.protocol
                ? s.pathname.includes("..")
                  ? (r = !0)
                  : (i = Le.getURL(e.replace(/^tampermonkey:\/\//, "")))
                : s.protocol ||
                  (t && (i = Tn(e, t, n || ["http:", "https:"]))) ||
                  (r = !0),
              r ? null : i
            );
        },
        Zn = (e) => {
          if (null == e) return;
          let t = fn.get(e);
          return t || ((t = En(e)), fn.set(e, t), t);
        },
        Tn = (e, t, n) => {
          let r, s, i;
          if (
            e &&
            t &&
            (r = Zn(e)) &&
            (s = "string" == typeof t ? Zn(t) : t) &&
            s.protocol &&
            (!n || n.includes(s.protocol) || !e.includes(".."))
          ) {
            if (e.startsWith("//"))
              return (
                s.protocol +
                "//" +
                r.hostname +
                (r.port ? ":" + r.port : "") +
                r.pathname +
                r.search
              );
            if ("/" === e[0]) i = r.pathname;
            else {
              if (
                ((t = On(s)),
                !(s = Zn(t + ("/" === t[t.length - 1] ? "" : "/") + e)))
              )
                return;
              i = s.pathname;
            }
            return (
              s.protocol +
              "//" +
              s.hostname +
              (s.port ? ":" + s.port : "") +
              i +
              r.search
            );
          }
        },
        Bn = (e, t) =>
          ((t = t || {}).noprotocol
            ? ""
            : ["about:"].includes(e.protocol)
            ? e.protocol
            : e.protocol + "//") +
          e.hostname +
          (!t.noport && e.port && e.port > 0 ? ":" + e.port : "") +
          (t.nopath ? "" : e.pathname + (t.nosearch ? "" : e.search)),
        On = (e) => {
          const t = "string" == typeof e ? Zn(e) : e;
          if (!t) throw new Error("invalid url");
          return Bn(t, { nosearch: !0 });
        },
        Fn = (e) => {
          const t = "string" == typeof e ? Zn(e) : e;
          if (!t) throw new Error("invalid url");
          return Bn(t);
        },
        Dn = (e) =>
          Object.entries(e)
            .map(([e, t]) => (void 0 === t ? null : z(e) + "=" + z(t)))
            .filter((e) => e)
            .join("&"),
        jn = "mtm_visitor",
        Pn = "default",
        Ln = "pageview",
        Nn = "script_update",
        Vn = "script",
        zn = "cloud",
        qn = "event",
        Hn = "pageview",
        Qn = "ping",
        Wn = "https://a.tampermonkey.net/matomo.php",
        Xn = ae;
      let Yn,
        Jn,
        Kn,
        $n = null;
      const er = () => ({
          url: Wn,
          siteId: 4,
          tracker: {
            [Pn]: { enabled: Ar(4, 1) },
            [Vn]: { enabled: !0 },
            [Nn]: { enabled: Ar(4, 10) },
            [zn]: { enabled: Ar(4, 5e-4) },
          },
        }),
        tr = () => ({
          url: Wn,
          siteId: 5,
          tracker: {
            [Pn]: { enabled: Ar(5, 10) },
            [Vn]: { enabled: !0 },
            [Nn]: { enabled: Ar(5, 10) },
            [zn]: { enabled: Ar(5, 0.001) },
          },
        }),
        nr = () => ({
          url: Wn,
          siteId: 6,
          tracker: {
            [Pn]: { enabled: Ar(6, 50) },
            [Vn]: { enabled: !0 },
            [Nn]: { enabled: Ar(6, 10) },
            [zn]: { enabled: Ar(6, 0.01) },
          },
        }),
        rr = {
          default: tr,
          gcal: tr,
          iikm: er,
          fcmf: er,
          saap: () => ({
            url: Wn,
            siteId: 7,
            tracker: {
              [Pn]: { enabled: !0 },
              [Vn]: { enabled: !0 },
              [Nn]: { enabled: Ar(7, 10) },
              [zn]: { enabled: Ar(7, 0.01) },
            },
          }),
          fire: nr,
          firb: nr,
          dhdg: () => ({
            url: Wn,
            siteId: 3,
            tracker: {
              [Pn]: { enabled: Ar(3, 1) },
              [Vn]: { enabled: !0 },
              [Nn]: { enabled: Ar(3, 10) },
              [zn]: { enabled: Ar(3, 5e-4) },
            },
          }),
          mfdh: tr,
          heif: () => ({
            url: "http://a.userscript.grobilan:8081/matomo.php",
            siteId: 2,
            tracker: { [Pn]: { enabled: !0 } },
          }),
        };
      let sr;
      const ir = [
          { msg: "a disconnected port" },
          {
            msg: "Function.prototype.apply: Arguments list has wrong type",
            url: "event_bindings",
          },
          { msg: "Script error." },
        ],
        or = (e) =>
          [...Array(e)]
            .map(() => Math.floor(16 * Math.random()).toString(16))
            .join(""),
        ar = (e) => {
          if (!Xn) return;
          const t = [
            e.uuid,
            e.createTs,
            e.visitCount,
            e.currentVisitTs,
            e.lastVisitTs,
          ].join(".");
          Xn.setItem(jn, t);
        },
        lr = (e) => {
          const t = e || Pn,
            n = sr.tracker[t] || sr.tracker[Pn];
          return n.enabled
            ? { url: sr.url, siteId: sr.siteId, options: n }
            : null;
        },
        cr = or(6),
        ur = async (e, t, n) => {
          if (!e) return;
          const r =
            (() => {
              if (!Xn) return;
              const e = Xn.getItem(jn);
              if (!e) return;
              const t = e.split(".");
              if (t.length >= 5) {
                t.unshift("0");
                const [e, n, r, s, i, o] = t;
                return {
                  createdNow: !1,
                  newVisitor: e,
                  uuid: n,
                  createTs: r,
                  visitCount: s,
                  currentVisitTs: i,
                  lastVisitTs: o,
                };
              }
            })() ||
            (() => {
              const e = Math.floor(Date.now() / 1e3).toString(),
                t = {
                  createdNow: !0,
                  newVisitor: "1",
                  uuid: or(16),
                  createTs: e,
                  visitCount: "0",
                  currentVisitTs: e,
                  lastVisitTs: "",
                };
              return ar(t), t;
            })();
          let s;
          const i = new Date(),
            o = {
              idsite: e.siteId,
              rec: 1,
              action_name: oe ? oe.title : H.href || qe.short_id,
              url: H.href,
              _id: r.uuid,
              rand: or(4),
              apiv: 1,
              h: i.getHours(),
              m: i.getMinutes(),
              s: i.getSeconds(),
              cookie: 1,
              pv_id: cr,
            },
            a = {
              ...o,
              _idts: Number(r.createTs),
              _idvc: Number(r.visitCount),
              _viewts: Number(r.lastVisitTs),
              res: le ? `${le.width}x${le.height}` : "0x0",
            };
          if (t == Hn) {
            const e = Jn ? { gt_ms: Jn } : {},
              t = { ...o, ...a, ...e, new_visit: 1 };
            ar(
              ((e) => {
                const t = Math.floor(Date.now() / 1e3).toString();
                return (
                  (e.newVisitor = "0"),
                  (e.visitCount = (Number(e.visitCount) + 1).toString()),
                  (e.lastVisitTs = e.currentVisitTs),
                  (e.currentVisitTs = t),
                  e
                );
              })(r)
            ),
              (s = t);
          } else if (t == qn) {
            if (!n) return;
            s = {
              ...o,
              ca: 1,
              e_c: n.category,
              e_a: n.action,
              e_n: n.name,
              e_v: n.value,
            };
          } else {
            if (t != Qn) return;
            s = { ...o, ...a, ping: 1 };
          }
          s = Object.assign(o, s);
          const l = `${e.url}?${Dn(s)}`;
          if (oe) {
            const e = oe.createElement("img");
            (e.src = l),
              (e.onload = () => {
                var t;
                null === (t = e.parentNode) || void 0 === t || t.removeChild(e);
              }),
              (e.onerror = () => {
                var t;
                null === (t = e.parentNode) || void 0 === t || t.removeChild(e);
              }),
              (oe.body || oe.head || oe.documentElement).appendChild(e);
          } else
            try {
              await J(l);
            } catch (e) {
              w.warn("stats:", e);
            }
        },
        Ar = (e, t) => {
          let n = 100 * Math.random() < t;
          if (Xn)
            try {
              let r, s;
              const i = ["wsr", e, t].join("_"),
                o = Date.now(),
                a = 864e7;
              if ((r = Xn.getItem(i))) {
                try {
                  s = JSON.parse(r);
                } catch (e) {}
                (!s || s.ts + a < o) && (s = { ts: o, w: n });
              } else s = { ts: o, w: n };
              (n = s.w), Xn.setItem(i, JSON.stringify(s));
            } catch (e) {}
          return n;
        };
      let dr = R();
      const hr = () => (null === $n && dr ? dr.promise() : R.Pledge(!!$n)),
        pr = (e) => {
          ($n = e),
            dr && (dr.resolve($n), (dr = void 0)),
            $n ? fr() : Kn && (P(Kn), (Kn = void 0));
        },
        fr = () => {
          Yn && (ur(lr(Ln), Hn), (Yn = !1)),
            (Kn = W(() => ur(lr(Ln), Qn), 864e5));
        },
        mr = async (e, t, n) => {
          if (!(await hr())) return;
          const r = `${e}${n ? ` <${n}> ` : ""}`;
          let s = "",
            i = null;
          if ("i" === t) s = "Installed";
          else if ("u" === t) (s = "Updated"), (i = lr(Nn));
          else if ("m" === t) s = "Revealed";
          else {
            if ("r" !== t) return;
            s = "Removed";
          }
          ur(i || lr(Vn), qn, { category: "Script", action: s, name: r });
        },
        gr = async (e, t, n) => {
          if (!(await hr())) return;
          let r = "",
            s = "";
          "init" === t
            ? ((s = "Initialized"), (r = e))
            : "error" === t && ((s = "Error"), (r = e + " -> " + n)),
            ur(lr(zn), qn, { category: "Cloud", action: s, name: r });
        },
        vr = async (e, t, n) => {
          if (!(await hr())) return;
          void 0 === n && ((t += " " + H.href), (n = ""));
          let r = !1;
          for (const n of ir) {
            if (!n.msg && !n.url) return;
            (n.msg && -1 == e.indexOf(n.msg)) ||
              (n.url && -1 == t.indexOf(n.url)) ||
              (r = !0);
          }
          r ||
            ur(lr("error"), qn, {
              category: "Error",
              action: e,
              name: t + ":" + n,
            });
        },
        _r = async (e, t, n) => {
          if (!(await hr())) return;
          let r = "",
            s = "";
          "clicked" === e
            ? ((s = "Click"), (r = t + ":" + n))
            : "button" === e
            ? ((s = "Button"), (r = t || "?"))
            : "dialog" === e && (s = "Dialog"),
            ur(lr("begging"), qn, { category: "Begging", action: s, name: r });
        };
      let wr = [];
      const br = {},
        yr = {},
        kr = {},
        Rr = {},
        xr = "en";
      let Er = {},
        Sr = {},
        Cr = null;
      const Mr = [],
        Ir = (e, ...t) => {
          const n = [],
            r = (e) => {
              for (let t = 0; t < e.length; t++)
                Array.isArray(e[t]) ? r(e[t]) : n.push(String(e[t]));
            };
          return r(t), yt.getMessage(e, n);
        },
        Gr = (e) =>
          new Promise((t, n) => {
            ((e, t) => {
              let n;
              if (void 0 !== (n = Rr[e])) t && t(n);
              else if (ue) {
                const r = Le.getURL(e);
                try {
                  const s = new ue();
                  if (ue.onlyasync) {
                    if (!t)
                      return void w.warn(
                        "registry: async xhr without a callback!"
                      );
                    s.open("GET", r),
                      (s.onload = () => {
                        t(s.responseText);
                      }),
                      (s.onerror = () => {
                        t();
                      }),
                      s.send(null);
                  } else
                    s.open("GET", r, !1),
                      s.send(null),
                      (n = s.responseText),
                      n || w.warn("registry: content of " + e + " is null!"),
                      t && t(n);
                } catch (e) {
                  w.log("getRawContent " + e);
                }
              }
            })(`_locales/${e}/messages.json`, (r) => {
              try {
                if (r) return t(JSON.parse(r));
              } catch (t) {
                w.log("i18n: parsing locale " + e + " failed!");
              }
              n();
            });
          }),
        Ur = async (e) => {
          e = e.concat(xr);
          let t = -1,
            n = null;
          const r = async () => {
            if ((t++, t < e.length)) {
              const s = e[t];
              if (!s || !Or.includes(s)) return r();
              try {
                const e = await Gr(s);
                (n = s), (Er = e);
              } catch (e) {
                return r();
              }
              if (!Fr && s != xr)
                try {
                  const e = await Gr(xr);
                  Sr = e || {};
                } catch (e) {}
            }
          };
          return await r(), n;
        },
        Zr = (e) =>
          e
            ? e
                .replace(/-/g, "_")
                .split("_")
                .map((e, t) => (t ? e.toUpperCase() : e.toLowerCase()))
                .join("_")
            : e,
        Tr = (e, t) => {
          let n, r;
          return (
            (t =
              t ||
              (Cr ? [Cr, Cr.split("_")[0]].concat(Mr).filter((e) => e) : Mr)),
            Nt(t, (t, s) => {
              const i = Number(s);
              if (
                (Nt(e, (e, s) => {
                  const o = Number(s),
                    a = Zr(e),
                    l = a.split(/_/)[0];
                  if (a == t) return (r = o), !1;
                  l == t && (void 0 === n || i < n) && ((r = o), (n = i));
                }),
                void 0 !== r)
              )
                return !1;
            }),
            void 0 === r ? r : e[r]
          );
        },
        Br = [
          { value: "ar", name: "Arabic - ‎‫العربية‬‎" },
          { value: "be", name: "Belarusian - беларуская" },
          { value: "cs", name: "Czech - čeština" },
          { value: "da", name: "Danish - dansk" },
          { value: "de", name: "German - Deutsch" },
          { value: "el", name: "Hellenic (Greek) - Ελληνικά" },
          { value: "en", name: "English" },
          { value: "es", name: "Spanish - español" },
          { value: "fr", name: "French - français" },
          { value: "hi", name: "Hindi - हिन्दी" },
          { value: "hr", name: "Croatian - hrvatski" },
          { value: "hu", name: "Hungarian - magyar" },
          { value: "id", name: "Indonesian - Indonesia" },
          { value: "it", name: "Italian - italiano" },
          { value: "ja", name: "Japanese - 日本語" },
          { value: "ko", name: "Korean - 한국어" },
          { value: "mk", name: "Macedonian - македонски" },
          { value: "nb", name: "Norwegian - norsk" },
          { value: "nl", name: "Dutch - Nederlands" },
          { value: "pl", name: "Polish - polski" },
          { value: "pt_BR", name: "Portuguese (Brazil) - português (Brasil)" },
          {
            value: "pt_PT",
            name: "Portuguese (Portugal) - português (Portugal)",
          },
          { value: "ru", name: "Russian - русский" },
          { value: "sk", name: "Slovak - slovenčina" },
          { value: "sr", name: "Serbian - српски" },
          { value: "tr", name: "Turkish - Türkçe" },
          { value: "uk", name: "Ukrainian - українська" },
          { value: "vi", name: "Vietnamese - Tiếng Việt" },
          { value: "zh_CN", name: "Chinese (Simplified) - 中文（简体中文）" },
          { value: "zh_TW", name: "Chinese (Traditional) - 中文（繁體）" },
        ],
        Or = Br.map((e) => e.value),
        Fr = !(void 0 === yt) && yt.native_support,
        Dr = {
          init: async () => {
            const e = async () => {
                Cr || Fr || (Cr = await Ur(Mr));
              },
              t = Zr(Fr ? yt.getUILanguage() : navigator.language);
            if (t) {
              const e = [t],
                n = t.split(/_/);
              n[0] !== t && e.push(n[0]),
                e.forEach((e) => {
                  Mr.unshift(e);
                });
            }
            await e(),
              Fr &&
                (await new Promise((e) => {
                  yt.getAcceptLanguages((t) => {
                    t.forEach((e) => {
                      Mr.push(Zr(e));
                    }),
                      e();
                  });
                }),
                await e());
          },
          getMessage: (e, ...t) => {
            let n;
            return Cr && (n = Er[e] || Sr[e])
              ? ((e, t) => {
                  let n,
                    r = e.message;
                  return (
                    (n = 1 == t.length && Array.isArray(t[0]) ? t[0] : t),
                    e.placeholders &&
                      Object.entries(e.placeholders).forEach(([e, t]) => {
                        try {
                          const s = Number(t.content.replace(/^\$/, "")) - 1;
                          let i;
                          s < n.length
                            ? ((i = n[s]), (r = r.replace("$" + e + "$", i)))
                            : w.log(
                                'i18n: invalid argument count on processing "' +
                                  r +
                                  '" with args ' +
                                  JSON.stringify(n)
                              );
                        } catch (e) {
                          w.log(
                            'i18n: error processing "' +
                              r +
                              '" with args ' +
                              JSON.stringify(n)
                          );
                        }
                      }),
                    r
                  );
                })(n, t)
              : ((Fr && (n = Ir(e, ...t))) ||
                  ((n = (function (e, ...t) {
                    let n = e;
                    1 == t.length && Array.isArray(t[0]) && (t = t[0]);
                    const r = new RegExp("(^|_)0[a-zA-Z]+0(_|$)");
                    for (let e = 0; e < t.length; e++) {
                      const s = n.match(r);
                      if (!s) {
                        w.log("i18n: getMessage(): wrong argument count!!!");
                        break;
                      }
                      n = n.replace(
                        r,
                        (s[1] ? " " : "") + t[e] + (s[2] ? " " : "")
                      );
                    }
                    return n.replace(/_/g, " ");
                  })(e, ...t)),
                  w.warn("i18n: missing translation" + n)),
                n);
          },
          getOriginalMessage: Ir,
          normalizeLocale: Zr,
          getTranslation: (e, t) => {
            let n;
            const r = e[t];
            if (e) {
              let s = e[t + "_i18n"] || {};
              r && (s = { en: r, ...s });
              const i = Tr(Object.keys(s));
              void 0 !== i && (n = s[i]);
            }
            return n || r;
          },
          setLocale: async (e) => {
            let t = e;
            if (("null" === e && (t = null), t && (t = Zr(t)), !t && Fr))
              Cr = t;
            else if (t !== Cr)
              return Ur([t, ...Mr, Cr].filter((e) => e)).then((t) => {
                (Cr = t),
                  Cr != e && w.log("i18n: retrieving locale " + t + " failed!");
              });
          },
          getLocale: () => Cr,
          getUiLocale: () =>
            Zr(
              Cr || Fr ? yt.getUILanguage() : Mr[0] || navigator.language || xr
            ),
          getBestLocale: Tr,
          supported: Br,
        };
      let jr;
      const Pr = ["DOM", "JavaScript", "raw"],
        Lr = {},
        Nr = (e) => {
          const t = null == e ? void 0 : e.keys,
            n = { keys: t, default: () => [], set: (e, t) => (e.push(t), e) };
          return (
            (null == t ? void 0 : t.length) && t.forEach((e) => (Lr[e] = n)), n
          );
        },
        Vr = (e) => {
          const t = null == e ? void 0 : e.keys,
            n = {
              keys: t,
              default: () => null,
              set: (t, n, r) => {
                const s = (null == e ? void 0 : e.convert)
                  ? e.convert(n, r)
                  : n;
                return null === t ? s : t;
              },
            };
          return (
            (null == t ? void 0 : t.length) && t.forEach((e) => (Lr[e] = n)), n
          );
        },
        zr = (e) => {
          const t = null == e ? void 0 : e.keys,
            n = { default: () => null, set: () => !0 };
          return (
            (null == t ? void 0 : t.length) && t.forEach((e) => (Lr[e] = n)), n
          );
        },
        qr = (e) => {
          const t = null == e ? void 0 : e.keys,
            n = {
              keys: t,
              default: () => ({}),
              set: (t, n, r, s) => {
                s = s ? Zr(s) : "default";
                const i = (null == e ? void 0 : e.convert)
                  ? e.convert(n, r)
                  : n;
                return (t[s] = t[s] || i), t;
              },
            };
          return (
            (null == t ? void 0 : t.length) && t.forEach((e) => (Lr[e] = n)), n
          );
        },
        Hr = {
          name: qr({
            convert: (e) => (null == e ? void 0 : e.replace(/\s\s+/g, " ")),
          }),
          version: Vr({
            convert: (e) => (null == e ? void 0 : e.replace(/\s/g, "")) || e,
          }),
          grants: Nr({ keys: ["grant"] }),
          icon: Vr({ keys: ["icon", "iconURL", "iconUrl", "defaulticon"] }),
          icon64: Vr({ keys: ["icon64", "iconURL64"] }),
          supportURL: Vr({ keys: ["supportURL", "supportUrl"] }),
          fileURL: Vr(),
          downloadURL: Vr({ keys: ["downloadURL", "downloadUrl"] }),
          updateURL: Vr({ keys: ["updateURL", "updateUrl"] }),
          namespace: Vr({
            convert: (e) => ("" === e ? null : e),
          }),
          author: Vr(),
          copyright: Vr(),
          homepage: Vr({
            keys: [
              "homepage",
              "homepageURL",
              "homepageUrl",
              "website",
              "source",
            ],
          }),
          description: qr(),
          includes: Nr({ keys: ["include"] }),
          excludes: Nr({ keys: ["exclude"] }),
          matches: Nr({ keys: ["match"] }),
          requires: Nr({ keys: ["require"] }),
          resources: ((e) => {
            const t = null == e ? void 0 : e.keys,
              n = {
                keys: t,
                default: () => ({}),
                set: (t, n, r) => {
                  const s = n.match(/^(\S*)\s+(.*)/);
                  if (s && void 0 === t[s[1]]) {
                    const n = (null == e ? void 0 : e.convert)
                      ? e.convert(s[2], r)
                      : s[2];
                    t[s[1]] = n;
                  }
                  return t;
                },
              };
            return (
              (null == t ? void 0 : t.length) && t.forEach((e) => (Lr[e] = n)),
              n
            );
          })({ keys: ["resource"] }),
          sandbox: Vr({
            keys: ["sandbox", "inject-into"],
            convert: (e, t) =>
              null !== e && "inject-into" === t
                ? { auto: "DOM", content: "DOM", page: null }[e] || null
                : e,
          }),
          noframes: zr(),
          unwrap: zr(),
          connects: Nr({ keys: ["connect", "connect-src", "domain"] }),
          webRequest: Nr(),
          "run-at": Vr(),
          antifeatures: ((e) => {
            const t = null == e ? void 0 : e.keys,
              n = {
                keys: t,
                default: () => ({}),
                set: (t, n, r, s) => {
                  var i;
                  s = s ? Zr(s) : "default";
                  const o = n.match(/^(\S*)\s+(.*)/);
                  if (o) {
                    const n = t[(i = o[1])] || (t[i] = {}),
                      a = (null == e ? void 0 : e.convert)
                        ? e.convert(o[2], r)
                        : o[2];
                    n[s] = a;
                  }
                  return t;
                },
              };
            return (
              (null == t ? void 0 : t.length) && t.forEach((e) => (Lr[e] = n)),
              n
            );
          })({ keys: ["antifeature"] }),
        },
        Qr = {};
      Object.entries(Hr).forEach(([e, t]) => {
        t.keys
          ? t.keys.forEach((t) => {
              Qr[t] = e;
            })
          : (Qr[e] = e);
      });
      const Wr = "==UserScript==",
        Xr = "==/UserScript==",
        Yr =
          /(?:^|\n)\s*\/\/\x20*==UserScript==([\s\S]*?\n)\s*\/\/\x20*==\/UserScript==|$/,
        Jr = () => {
          const e = {
            ...Object.fromEntries(
              Object.keys(Hr).map((e) => [e, Hr[e].default()])
            ),
          };
          return { ...e };
        },
        Kr = (e) => {
          const t = e.match(Yr),
            n = (t ? t[1] : "") || "",
            r = {};
          return (
            n.replace(/(?:^|\n)\s*\/\/\s*(@\S+)(.*)/g, (e, t, n) => {
              const [s, i] = t.slice(1).split(":"),
                o = Qr[s];
              let a;
              if (o && (a = Lr[o] || Hr[o] || void 0)) {
                const e = n.trim();
                let t = r[o];
                void 0 === t && (t = a.default()), (r[o] = a.set(t, e, s, i));
              }
              return "";
            }),
            { ...Jr(), ...r }
          );
        },
        $r = (e) => {
          const {
            name: t,
            description: n,
            version: r,
            grants: s,
            fileURL: i,
            requires: o,
            resources: a,
            webRequest: l,
            namespace: c,
            sandbox: u,
            noframes: A,
            unwrap: d,
            author: h,
            copyright: p,
            antifeatures: f,
          } = e;
          let {
            icon: m,
            icon64: g,
            updateURL: v,
            downloadURL: _,
            supportURL: w,
            homepage: b,
            includes: y,
            matches: k,
            excludes: R,
            connects: x,
          } = e;
          const E = e["run-at"] || null,
            S = (e, { [e]: t, ...n }) => n,
            C = s.includes("none") ? ["none"] : s.filter((e) => e),
            M = u && Pr.includes(u) ? u : null;
          (m = m || null),
            (g = g || null),
            (v = v || null),
            (_ = _ || null),
            (w = w || null),
            (b = b || null);
          const I = t.default,
            G = n.default || "",
            U = S("default", t),
            Z = S("default", n);
          (y = y.filter((e) => e)),
            (k = k.filter((e) => e)),
            (R = R.filter((e) => e)),
            (x = x.filter((e) => e));
          const T = Object.entries(a)
              .map(([e, t]) => ({ name: e, url: t, loaded: !1 }))
              .filter((e) => e.url),
            B = o
              .filter((e) => e)
              .map((e) => ({ url: e, loaded: !1, textContent: "" })),
            O = l.length
              ? l
                  .map((e) => {
                    const t = JSON.parse(e);
                    return Array.isArray(t) ? t : [t];
                  })
                  .reduce((e, t) => e.concat(t), [])
              : null;
          return {
            name: I,
            description: G,
            version: r || "0.0",
            grant: C,
            icon: m,
            icon64: g,
            supportURL: w,
            fileURL: i,
            downloadURL: _,
            updateURL: v,
            namespace: c,
            requires: B,
            includes: y,
            matches: k,
            excludes: R,
            homepage: b,
            resources: T,
            connects: x,
            webRequest: O,
            author: h,
            copyright: p,
            antifeatures: f,
            name_i18n: U,
            description_i18n: Z,
            uuid: null,
            system: !1,
            enabled: !0,
            position: 0,
            blockers: [],
            lastModified: 0,
            sync: {},
            options: {
              check_for_updates: !0,
              user_modified: null,
              comment: null,
              compatopts_for_requires: !0,
              compat_wrappedjsobject: !1,
              compat_metadata: !1,
              compat_foreach: !1,
              compat_powerful_this: null,
              sandbox: M,
              noframes: A,
              unwrap: d,
              run_at: E,
              tab_types: null,
              override: {
                use_includes: [],
                orig_includes: [],
                merge_includes: !0,
                use_matches: [],
                orig_matches: [],
                merge_matches: !0,
                use_excludes: [],
                orig_excludes: [],
                merge_excludes: !0,
                use_connects: [],
                orig_connects: [],
                merge_connects: !0,
                use_blockers: [],
                orig_run_at: null,
                orig_noframes: null,
              },
            },
            textContent: null,
            header: null,
          };
        },
        es = (() => {
          const e = (e) => {
              const t = e.split(".");
              return t
                .slice(0, 3)
                .concat([t.slice(3).join(".")])
                .concat([0, 0, 0, 0])
                .slice(0, 4)
                .map((e) => {
                  const t = e
                    .toString()
                    .match(/((?:-?[0-9]+)?)([^0-9]*)((?:[0-9]+)?)(.*)/);
                  return t ? [Number(t[1]), t[2], Number(t[3]), t[4]] : [];
                })
                .reduce((e, t) => e.concat(t));
            },
            t = (n, r) => {
              const s = Array.isArray(n) ? n : e(n),
                i = Array.isArray(r) ? r : e(r);
              for (let e = 0; e < 16; e++) {
                const n = s[e],
                  r = i[e];
                if (e % 2 == 1) {
                  if (!n && r) return t.eNEWER;
                  if (n && !r) return t.eOLDER;
                  const e = n.match(/\w/g) || [],
                    s = r.match(/\w/g) || [];
                  for (let n = 0; n < Math.min(e.length, s.length); n++) {
                    if (e[n].charCodeAt(0) > s[n].charCodeAt(0))
                      return t.eNEWER;
                    if (e[n].charCodeAt(0) < s[n].charCodeAt(0))
                      return t.eOLDER;
                  }
                  if (e.length > s.length) return t.eNEWER;
                  if (e.length < s.length) return t.eOLDER;
                } else {
                  if (Number(n) > Number(r)) return t.eNEWER;
                  if (Number(n) < Number(r)) return t.eOLDER;
                }
              }
              return t.eEQUAL;
            };
          return (
            (t.eERROR = -2), (t.eOLDER = -1), (t.eEQUAL = 0), (t.eNEWER = 1), t
          );
        })(),
        ts = (e) => {
          const t = ((e) => {
            const t = Dt(e, Wr, Xr);
            if (!t) return null;
            const n = e.indexOf(Wr),
              r = e.indexOf("<html>"),
              s = e.indexOf("<body>");
            return (r > 0 && r < n) || (s > 0 && s < n)
              ? null
              : ["// ", Wr, t, Xr].join("");
          })(e);
          if (!t) return null;
          const n = ns(t);
          return n
            ? ((n.textContent = e),
              (n.header = t),
              (n.options.compat_metadata = e != jr.unMetaDataify(e)),
              n)
            : null;
        },
        ns = (e) => {
          const t = ((e) => Kr(e))(
            (e = (e = (e = (e = (e || "").replace(
              /(\r\n|\n|\r)/gm,
              "\n"
            )).replace(/\t/g, "    ")).replace(/\n\n+/g, "\n")).replace(
              /[^|\n][ \t]+\/\//g,
              "//"
            ))
          );
          if (t) return $r(t);
        },
        rs = () => $r(Jr()),
        ss = "try to take over the world!",
        is =
          "This script was deleted from Greasy Fork, and due to its negative effects, it has been automatically removed from your browser.",
        os = {
          uso: {
            test: (e) => {
              const t =
                e.match(
                  new RegExp(
                    "https?://userscripts\\.org/scripts/(source|version)/([0-9]{1,9})\\.user\\.js"
                  )
                ) ||
                e.match(
                  new RegExp(
                    "https?://userscripts-mirror\\.org/scripts/(source|version)/([0-9]{1,9})\\.user\\.js"
                  )
                );
              if (t && 3 == t.length)
                return {
                  id: t[2],
                  token: "uso",
                  meta_url: !0,
                  url: "http://userscripts-mirror.org/scripts/show/" + t[2],
                  code_url:
                    "http://userscripts-mirror.org/scripts/review/" + t[2],
                  issue_url: "http://contactbyweb.com/userscripts-mirror",
                };
            },
            updates: () => !1,
          },
          gf: {
            test: (e) => {
              const t = new RegExp(
                  "https?://greasyfork\\.org/(?:[^/]+/)?scripts/([^/-]+).*/code.*\\.user\\.js"
                ),
                n = new RegExp(
                  "https?://update.greasyfork\\.org/(?:[^/]+/)?scripts/([^/-]+).*/.*\\.user\\.js"
                ),
                r = e.match(n) || e.match(t);
              if (r && 2 == r.length) {
                const e = r[1];
                return {
                  id: e,
                  token: "gf",
                  meta_url: !0,
                  url: "https://greasyfork.org/scripts/" + e,
                  issue_url:
                    "https://greasyfork.org/scripts/" + e + "/feedback",
                  code_url: "https://greasyfork.org/scripts/" + e + "/code",
                };
              }
            },
            convert: async (e) => {
              let t,
                n = e;
              if (n) {
                const e = n.description.trim();
                e === ss
                  ? (n.description = "")
                  : e === is && ((n = null), (t = "deleted by hoster"));
              }
              return { script: n, warning: t };
            },
            updates: (e) => {
              const t = new RegExp(
                  "https?://greasyfork\\.org/scripts/[^/]+/code/.*\\.user\\.js.*version=[0-9]+.*"
                ),
                n = new RegExp(
                  "https?://update\\.greasyfork\\.org/scripts/[^/]+/[^/]+/[^/]+\\.user\\.js"
                );
              return !e.match(n) && !e.match(t);
            },
          },
          sf: {
            test: (e) => {
              const t = new RegExp(
                  "https?://sleazyfork\\.org/(?:[^/]+/)?scripts/([^/-]+).*/code.*\\.user\\.js"
                ),
                n = new RegExp(
                  "https?://update.sleazyfork\\.org/(?:[^/]+/)?scripts/([^/-]+).*/.*\\.user\\.js"
                ),
                r = e.match(n) || e.match(t);
              if (r && 2 == r.length) {
                const e = r[1];
                return {
                  id: e,
                  token: "sf",
                  meta_url: !0,
                  url: "https://sleazyfork.org/scripts/" + e,
                  issue_url:
                    "https://sleazyfork.org/scripts/" + e + "/feedback",
                  code_url: "https://sleazyfork.org/scripts/" + e + "/code",
                };
              }
            },
            convert: async (e) => {
              let t,
                n = e;
              if (n) {
                const e = n.description.trim();
                e === ss
                  ? (n.description = "")
                  : e === is && ((n = null), (t = "deleted by hoster"));
              }
              return { script: n, warning: t };
            },
            updates: (e) => {
              const t = new RegExp(
                  "https?://sleazyfork\\.org/scripts/([^/]+)/code/.*\\.user\\.js.*version=[0-9]+.*"
                ),
                n = new RegExp(
                  "https?://update\\.sleazyfork\\.org/scripts/[^/]+/[^/]+/[^/]+\\.user\\.js"
                );
              return !e.match(n) && !e.match(t);
            },
          },
          ouj: {
            test: (e) => {
              const t = e.match(
                new RegExp(
                  "https?://openuserjs\\.org/install/([^/]+)+/(.+?)(?:\\.min)?\\.user\\.js"
                )
              );
              if (t && 3 == t.length)
                return (
                  t.shift(),
                  {
                    id: t.join("/"),
                    token: "ouj",
                    meta_header: !0,
                    url: "https://openuserjs.org/scripts/" + t[0] + "/" + t[1],
                    issue_url:
                      "https://openuserjs.org/scripts/" +
                      t[0] +
                      "/" +
                      t[1] +
                      "/issues",
                    code_url:
                      "https://openuserjs.org/scripts/" +
                      t[0] +
                      "/" +
                      t[1] +
                      "/source",
                  }
                );
            },
            convert: async (e) => {
              const t = e;
              return (
                t && t.description.trim() === ss && (t.description = ""),
                { script: t, warning: void 0 }
              );
            },
            updates: () => !0,
          },
          gh: {
            test: (e) => {
              let t;
              const n =
                  e.match(
                    new RegExp(
                      "https?://raw\\.githubusercontent\\.com/([^/]+)/([^/]+)/[^/]+/(.*)\\.user\\.js"
                    )
                  ) ||
                  e.match(
                    new RegExp(
                      "https?://github\\.com/([^/]+)/([^/]+)/raw/[^/]+/(.*)\\.user\\.js"
                    )
                  ) ||
                  e.match(
                    new RegExp(
                      "https?://raw.github\\.com/([^/]+)/([^/]+)/[^/]+/(.*)\\.user\\.js"
                    )
                  ) ||
                  e.match(
                    new RegExp(
                      "https?://github\\.com/([^/]+)/([^/]+)/releases/download/[^/]+/(.*)\\.user\\.js"
                    )
                  ),
                r = e.match(
                  new RegExp(
                    "https?://(([^\\.]+).github\\.io)/(.*)\\.user\\.js"
                  )
                );
              if ((n && 4 == n.length) || (r && 4 == r.length)) {
                let e;
                if (n) {
                  n.shift();
                  const [r, s, i] = n;
                  (e = [r, s].join("/")),
                    (t = [r, s].concat(s == i ? [] : i).join("/"));
                } else {
                  if (!r) throw new Error("Should never happen!");
                  {
                    r.shift();
                    const [n, s, i] = r;
                    (e = [s, n].join("/")),
                      (t = [s, n].concat(n == i ? [] : i).join("/"));
                  }
                }
                return {
                  id: t,
                  token: "gh",
                  url: "https://github.com/" + e,
                  issue_url: "https://github.com/" + e + "/issues",
                };
              }
            },
            updates: () => !0,
          },
          gst: (() => {
            const e = (e) => {
              const t =
                e.match(
                  new RegExp(
                    "https?://gist\\.github\\.com/([^/]+)/([^/]+)/raw/(.*/)?.*\\.user\\.js"
                  )
                ) ||
                e.match(
                  new RegExp(
                    "https?://gist\\.githubusercontent\\.com/([^/]+)/([^/]+)/raw/(.*/)?.*\\.user\\.js"
                  )
                );
              if (t && (3 == t.length || 4 == t.length)) {
                const e = t[1],
                  n = t[2];
                return {
                  user: e,
                  gistId: n,
                  id: `${e}/${n}`,
                  updates: 4 == t.length,
                };
              }
              return {};
            };
            return {
              test: (t) => {
                const { gistId: n, id: r, updates: s } = e(t);
                if (n && r && void 0 !== s)
                  return {
                    id: r,
                    token: "gst",
                    url: `https://gist.github.com/${r}`,
                    issue_url: `https://gist.github.com/${r}#new_comment_field`,
                    code_url: `https://gist.github.com/${r}`,
                  };
              },
              updates: (t) => {
                const { updates: n } = e(t);
                return !!n;
              },
            };
          })(),
          gl: {
            test: (e) => {
              const t = new RegExp(
                  "https?://gitlab\\.com/([^/]+)(?:/([^/]+))?/(?!-)([^/]+)/?(?:-/)?(snippets/[^/]+/)?(raw|wikis)/(?:[^/]+/)?(.*?)\\.user\\.js"
                ),
                n = e.match(t);
              if (n && 7 == n.length) {
                const [, e, t, r, , , s] = n,
                  i = [e].concat([t, r].filter((e) => e)).join("/");
                return {
                  id: [i].concat(r == s ? [] : s).join("/"),
                  token: "gl",
                  url: "https://gitlab.com/" + i,
                  issue_url: "https://gitlab.com/" + i + "/issues",
                };
              }
            },
            updates: () => !0,
          },
          bb: {
            test: (e) => {
              const t =
                e.match(
                  new RegExp(
                    "https?://bitbucket\\.org/([^/]+)/([^/]+)/raw/[^/]+/(.*)\\.user\\.js"
                  )
                ) ||
                e.match(
                  new RegExp(
                    "https?://bitbucket\\.org/([^/]+)/([^/]+)/downloads/(.*)\\.user\\.js"
                  )
                );
              if (t && 4 == t.length) {
                t.shift();
                const [e, n, r] = t,
                  s = [e, n].concat(n == r ? [] : r).join("/"),
                  i = [e, n].join("/");
                return {
                  id: s,
                  token: "bb",
                  url: "https://bitbucket.org/" + i,
                  issue_url: "https://bitbucket.org/" + i + "/issues",
                };
              }
            },
            updates: () => !0,
          },
          usty: {
            test: (e) => {
              const t = e.match(
                new RegExp(
                  "https?://userstyles\\.org/styles/userjs/([^/]+)/.*\\.user\\.js"
                )
              );
              if (t && 2 == t.length)
                return (
                  t.shift(),
                  {
                    id: t[0],
                    token: "usty",
                    url: "https://userstyles.org/styles/" + t[0],
                    issue_url:
                      "https://forum.userstyles.org/post/discussion?Discussion/StyleID=" +
                      t[0],
                  }
                );
            },
            convert: async (e) => {
              let t, n, r, s;
              const i = [
                  {
                    tag: "includes",
                    re: /(?: \|\| \(new RegExp\("\^)([^$]+)(?:\$"\)\)\.test\(document\.location\.href\))/g,
                    idx: 1,
                    value: (e) => "/^" + e.replace(/\\\\(.)/g, "\\$1") + "$/",
                  },
                  {
                    tag: "includes",
                    re: /(?: \|\| \(document\.location\.href\.indexOf\(")([^"]+)"(?:\) == 0\))/g,
                    idx: 1,
                    value: (e) => e + "*",
                  },
                  {
                    tag: "matches",
                    re: /(?: \|\| \(document\.domain == ")([^"]+)"(?: \|\| document\.domain\.substring\(document\.domain\.indexOf\("[^"]+"\) \+ 1\) == "[^"]+"\))/g,
                    idx: 1,
                    value: (e) => "*." + e,
                  },
                ],
                o = new RegExp(
                  "(?:if \\(false)(" +
                    i.map((e) => "(?:" + e.re.source + ")").join("|") +
                    ")+",
                  "g"
                );
              return (
                e.textContent &&
                  0 === e.includes.length &&
                  0 === e.matches.length &&
                  0 === e.excludes.length &&
                  e.options &&
                  e.options.override &&
                  e.options.override.orig_includes &&
                  0 === e.options.override.orig_includes.length &&
                  e.options.override.orig_matches &&
                  0 === e.options.override.orig_matches.length &&
                  (n = e.textContent.match(o)) &&
                  (n.forEach((t) => {
                    i.forEach((n) => {
                      for (; (r = n.re.exec(t)); )
                        if (r.length > n.idx) {
                          const t = n.value(r[n.idx]);
                          e.options.override["orig_" + n.tag].push(t),
                            e[n.tag].push(t),
                            (s = !0);
                        }
                    });
                  }),
                  s && (t = "includes added")),
                0 === e.grant.length &&
                  (e.grant.push("GM_addStyle"), (t = "includes added")),
                { script: e, info: t }
              );
            },
            updates: () => !0,
          },
          web: {
            test: (e) => {
              const t = e.match(
                new RegExp(
                  "https://static\\.iitc\\.me/build/release/(plugins/)?(.*)\\.user\\.js"
                )
              );
              if (t && 3 === t.length) {
                t.shift();
                const [e, n] = t,
                  r = "iitc-project/ingress-intel-total-conversion";
                return {
                  id: [r]
                    .concat(e ? [e, n] : [])
                    .join("/")
                    .replace(/\/\//g, "/"),
                  token: "gh",
                  url: "https://github.com/" + r,
                  issue_url: "https://github.com/" + r + "/issues",
                };
              }
              const n = e.match(
                new RegExp(
                  "https://iitc\\.app/build/release/(plugins/)?(.*)\\.user\\.js"
                )
              );
              if (n && 3 === n.length) {
                n.shift();
                const [e, t] = n,
                  r = "IITC-CE/ingress-intel-total-conversion";
                return {
                  id: [r]
                    .concat(e ? [e, t] : [])
                    .join("/")
                    .replace(/\/\//g, "/"),
                  token: "gh",
                  url: "https://github.com/" + r,
                  issue_url: "https://github.com/" + r + "/issues",
                };
              }
              return e.match(
                new RegExp("https?://socialfixer\\.com/socialfixer\\.user\\.js")
              )
                ? {
                    id: "socialfixer",
                    token: "web",
                    url: "http://socialfixer.com",
                    issue_url:
                      "https://www.facebook.com/groups/SocialFixerUsersSupport/",
                  }
                : e.match(
                    new RegExp("https?://www\\.fbpurity\\.com/.*\\.user\\.js")
                  )
                ? {
                    id: "fbpurity",
                    token: "web",
                    url: "https://www.fbpurity.com/",
                    issue_url: "https://www.facebook.com/fluffbustingpurity",
                  }
                : void 0;
            },
            updates: () => !0,
          },
        },
        as = (e) => {
          if (e)
            for (const t of Object.values(os)) {
              const n = t.test(e);
              if (n) return n;
            }
        },
        ls = [],
        cs = (e, t, n) => {
          const r = { title: e.join("\n\n") },
            s = t ? "_" + t : "",
            i = ze.getURL("images/icon" + s + ".png");
          w.warn(e.join("\n")),
            at({ path: i }),
            lt(r),
            n ||
              ze.onMessage.addListener((t, n, r) => {
                const s = {
                  name: "1",
                  id: "1",
                  sub_menu_item: !0,
                  pos: "left",
                  items: [],
                };
                s.items.push({ name: e[0], image: "info" }),
                  e.length > 1 && s.items.push({ name: e[1] }),
                  r({ items: [s], options: { enabled: !1 } });
              });
        },
        us = () => {
          const e = R();
          if ("chromeStorage" != Be.USE || Be.NO_WARNING) e.resolve(!0);
          else {
            const t = () => {
              if (!Ot) return X(t, 2e3);
              Ot.isWorking
                ? Ot.isWorking()
                    .done(() => e.resolve(!0))
                    .fail(() => {
                      ie &&
                        ie(
                          "Tampermonkey detected that the extension storage is unreliable!\n\nUnfortunately this means that all your settings and userscripts are inaccessible at the moment.\n\nDo you want to visit the FAQ entry that explains how to recover from that?"
                        ) &&
                        Ye(
                          { url: "https://www.tampermonkey.net/faq#Q206" },
                          () => {}
                        );
                      const t = [
                        "Tampermonkey detected that the extension storage is unreliable!",
                      ];
                      cs(t, "paused", !0), e.reject(t[0]);
                    })
                : e.resolve(!0);
            };
            X(t, 1e3);
          }
          return e.promise();
        },
        As = cs,
        ds = (e, t, n) => {
          ls.push({
            text: e,
            description: t,
            url: n,
          });
        },
        hs = () => ls,
        ps = [
          {
            name: Dr.getMessage("Default"),
            layout: "default",
            value: "default",
          },
          {
            name: Dr.getMessage("Default_Light"),
            layout: "default",
            theme: "light",
            value: "default#light",
          },
          {
            name: Dr.getMessage("Default_Dark"),
            layout: "default",
            theme: "dark",
            value: "default#dark",
          },
          {
            name: Dr.getMessage("Default_Darker"),
            layout: "default",
            theme: "darker",
            footer:
              'Theme by <a href="https://github.com/narcolepticinsomniac" target="blank">narcolepticinsomniac</a> from the <a href="https://github.com/openstyles/stylus" target="blank">Stylus</a> project.',
            value: "default#darker",
          },
        ],
        fs = {
          default: Dr.getMessage("Default"),
          monokai: "Monokai",
          solarized: "Solarized",
          "mdn-like": "MDN-like",
          eclipse: "Eclipse",
          railscasts: "RailsCasts",
          zenburn: "ZenBurn",
        },
        ms = {
          unknown:
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKDBcWHLi+jYAAACAASURBVHja7X13nBRV9v15r6p7egIgElUkioCCIqBgxEVEBRMyiJJBUbKAuKvwVUQJKoqooCAGoiKiElVkBRPq7sqKGUHSkNOQplOFd39/vNDVQxB/MiO49n5mB3uqq6vq3ffeveeeey7w1+uv11+vv15/vf5HX+x4nEQIwT3PywGQDSCbMWYTkQAgjtd3/GkHgDEIIcAYO9rfmHqOHoAYgKht2wWcc/F7v98+Hjfh+35OIpGoK4SoZ1lWXcZYaSKKA3D/MgD5IqLf83GLMZYhhMgXQvxkWdb3kUjkewAHTggDEEKEPc+rLIS4gHN+Kef8dAAFRPSHGMDhZtMfOHjHdE2/8h02gAwA2z3PixDRASJaczzuzT5Oz8gmolKc87LhcLhsKBQ6VQhRAoD/19z/fYZGRGCMWZxz2/M83/f9ckRUCoB1whgAEXHGWAZjLNOyrAjnHJzzEIDQX8P622Z84feVAYBzDiFENmMsE0AGEfETxgAYYyAiwRgTyvmDEOI3n+NoD+t4L+uFzxf8Dj0I6r6OeUCD5zza54518Au/T0Q+EQn1rHHCGEDgQkl5/r95NhztgR3vwdcGqs/LGDMeNwBwzg855ljP+WvXfbhz6vs/hu8SAOh4PgeOE+ClB6DwgByrgRSlo6i/+1i+n3P+qyuZNq7C5yu8+hTXy/4jHuqxnkcvwYdbio/0AI+2rB/p+vSsDM784EpwLMv64Yy38GwPHhO8pqNtRyeVARxPB6nwwyr8QBhnhyyGRzOCI50naGBF8dCPdN4jGeavvf8/YwBEAkTps04PZHBJPuzSyQAm/0/+1ueU/0j7rF62g6tM4ZUguMQfq28QXO6PhvQdbTUpfD3/EwagnTHP8+D7PnwhQEKAcQ6Lc1iWDH9d1wURYNsWwBh8z1ODTOCMy+MtDs4tcMZABAjhw3VdM7CWbSOSkQHbtv8wH+NIq0Rx+QTHOwo4TucREEL++J6n3wRTs4GI4PvSISbBASZXDPkeQIzA9QxnJLFIInk+IeD7PkAAY/yo93EkH0Bfw7Hu20d6X61Jh5zvSL7B/8wWwBhXD0XAsm1ACECCS+AWBwiwLGkA3NKeN5kBZQCYZcFSn2GMgXECJ4JtWWBgYCBYFj+sw3kss/pIM/ZwBnNEw1Db1OGNQ91HERvBCRkFBA2BwQc4B2PS8dN7uhxzHT6qY5lQM5sh9T+1AICBq1nFdXKNAOH7KQMAgfz0kE8bEAnllxzhnvUsFkKkrRTBiEBfODtCiGmMUd/nyb4C/F7POviA5EATwAO4gHESGUj5CqRmlkVqQANLLQEgQRAkzGcdB7BsAcu2QILguo70PwTB4hyRSAScMbiuC9/3IYQ8K5EcKItz2JYFy7YgBCERT0injzPYto2MjAwAQNJJQggBy7KkYYCn+STaIeU2h23ZsO2Q2rnoEJzkf8YAwAAOBsEC8TVLLZ/EAnul+mFm6ZRHkVkHKBUhpIWEBChjkjNVzmLhCzMApLYHoYwnZXwMHAzElRGSgCCCL3xwFNrXRWC2U8qI9KrBGZOXIDjAU8v/SeUEHk8j4HLNh2/JtBdjckmVD4qBWxwEgHNpAJZlpQZUzyautwe1p6YdlwoD9Q8RIRQKyX8LAuMctm1J3yIUArcsuZqQWgHSPi/PG4mEIYQtv4tbxpEMhUIQRLAtrrarFBFEpU8AHekEnM+idgaLxQD+v/wDlpqtZGau2fyR8p/0geoXMYDMOhDwBNIhZ6b2Wq58Au2QccYBThBchZNM+x88gJsrA4B6XxkbEQe3bID5YGDgAWPjnIERMyGqNHIOyyIIoXwDxgLfefjZf7xXhSLPBTDG4Ps+Pv30UwDABx98cIyGI5djnwSE78u9W0iDWvTuIrmcqmX1k08+gfCFOkaDSMohg1p61SogBCk/QB77wZIl+L8HH8TnX3wh/45UCKqXe30tQgj861//gu8LCCExCiHS/RHf8yH81DkM3KyuRwT8GkEyJJXXLq9feSrFMvuLxQCICO+88w5KliwJIsLcuXN/mwPoi4AzKP89b+48NdgCRALLli0zA64fsi/8AAKolm11vFADt2jRQhw4cADDhw/HSy9NVriCkEaXZgQAqf/WS7ceNJBvrmvixInmOnzfV9+n9vs0g1IGSGScUl8IEKShQ8/wIxBETjoc4OOPP0bbtm2xe/du1KxZ88hTPmjtlJYHlw8/YBhCOVNmRgnCmDFjsG3bNriui+taXodIRgSzZs1CLBbD7Ddmg0C4+OKLcdlll6Fhw4bYf+AAOnboACLCSy+9ZODie/rfA08hiy+//DLOr38e/tasGerVrYcd27fj/PPPx4Tx43FK6dL48ssv4Dgupk+fjsmTX8L333+Peuedh44d2qeMRw+4EBBMKGeVAGWsQhAYJwifg1kCjBgYkdkqTmonMBgHv/zyy+jVq1fa0vjuu+/inXfeSfvMtddeh5tuuhHdunZDJDNi4v5EIonp06ebnR863le+wZdffok5c+bIvdTi6N+vP6ZOnQrGGYY9NAzDHnoIGRkZeOyxx8y1DRo0COFwCKeffgb+8Y+/4+233kLfvn1Ro3oNBTIBGRkZGPPEGAjhY/z48WCMISMjA5decgm6dO2Cffv24cEHH0T37t1xR/fu8IQPxhi6dOmKEiVKAAB830cymcSUKVPw1X/+jZdeejktzG3UqBG639EdCPgrIIlqMpzETuCXX36JFi1agDGGjRs3Ijs7Ow0syc7OxplnnhnY6xhOLV0anHNUrV4NGeGwOZfrusar1jkBi1sgAiybY8SIEejVqxcikQhGjhiB9957Dz169AAR4cYbbwTjFqpXr24+yzjH+PHjwTnH7t27MGTIUJQvXx63tMkFCV85YxzVqlVTqKF05uyQDUGEmmefDW5xlC9XHr/88gsqVqwIy7bAhNy7q1WrhuzsbGMAjuPAsizk5JRAlSpV0lawcuXLwbZscCuVlmZcAlBFSastcgOYM2cOnnxyDIgIJUqUCOzVPoiAi5s0wSWXXJIKz5QnL4SPEY8+YvB9k7mD/L19xw5UrFABu3bvxvr168HAsHnLFkx+aTISsThGjhqFlte1xLhxTyMSycKK/34lvfwAOjdzxgzUrFkTl156KVavXoNy5cqhZcuW+Pt99+HxJ57Ad999h0aNGhWKINSqEInghYkT0bdPH0yaNAn9+/fHqlWrVNgpjx05YiTskEpeOZ4BpOrWrYt69eqBBMHzPelLmHWNIzjiRQ0HF7kBuK5khr/yykvo1KmTSsj4IF8hcgC4Jj4yLq0eymvXjh5S7gHnHJMmTsKYJ8fg22+/Rb169TBlyhT4no+c7Gzc1eMu1KlTByNGjoTFOYYOGYpYPIZRo0YBRPjb3/5mnLl27dph4sSJmPziZLS4pgUGDRoEz/PQ/Y47cFePHrjiiivQsGEjXHPNNcYJrFu3LoRPiMdi6NqtG7p3747bbrsNl156CRo0aIA+ffqiXr16uKtHDwgwEFkqChAmRazT0oKEOi+pEDQFFJkbLuIo4LicPZlMnl5QUHAL57xFdnb2xaFQqKwIeM3ynoTxjoO/ZYbPgh2ywS1L4fQqpPI9eJ70shmTqWDbtgEiJB0HRIRwOCzTwa4vVxVIY7JsCxa31NKtM4jp6WDOuQRrLI6QHYIgAdd14Xny2rjFEcmIgPMUFKzDwmeeGYd7BtwDm1vgto2QZUGQQCKRhO/54ExuFSENBSeTICFgK6CJMQbh+3AdF4KEmQDcSt0nLwQIua67u6Cg4Asi+iAnJ+ftjIyMrSdJNjCAxQfSsqQMAGAKDuWQZGfpGfu+MN44Y35qBhHB9zwIAJbvA4zBEx58zzdZQSJ9dwyc+xAEeMKHq3gGjFQCJ0SwmQ1fzUbPdeF5HjwhEBI2RMgHwOF5PjzPNU5br9694DgOyA7BJgJngPAFPNeD53lyJWOAHZLMeN/1lOFpNBLwfWlwvvClMVoWLFjFRgcrNgMwqVadNQPBAkCcA0QpyJQzs2Jo6NeyLGkcXHr22vvnlqVy/innDLYljcQwfbjJCXBG4NAOFgHE5Dl5ChlEANq1VSQRRPLktUi4iAjq8xrZYwFo2JLOnCXvCQT570CGkCvAUh/DC8HSxfUqsm8K5gDy8vLw7LPPwrIs9OrVC+FQGJmRCLIyM5GVlYX/fPUf9OrVC7e1a4du3bph5syZsG0b4XAYmeqYzMxMZIQzYIdCCNk2MjMzkZmZiXA4hFAohEiGPF+2OjYSyUAoZMO2bckMsuT55DHZyM7OQlZWFjIyIgb/tywLJUuVQqfOndG5c2fMnTsXLVq0gGVZyMjIQGZmJrKzM5GVlY3s7GxkZmUhEomgefPmsG0bn3z6KbKyslCiZA5eeuklZEYyYXMLE8aPl/eRnYXJk19EOByCHQohIyOC7Oxs5GRnp+5RMZSKIxF03A3gSBc8depU9OnTB4wx5OTkwLZt87N06VL8+OOPeOihh3Dttddi2LBhKCgowLhx42BZFr799lt88vEnmDZtOhKJhCKFWFi4cCGWLFkCW+2XK1euxKJFi/D+++8jFArh3XffxcKFC1MzkjG89tpr+OyzzxAOhxEOhxEKhZSBWGbm5ebmYv78+ViwYAE6d+6MsWPHgnOOjz76CKFQCKFQGF9++aU8R0ie47nnnkNeXh4GDx6MFya+gHA4jOzsbLOPZ2ZmwrZthEIhZGVlyaVepZBDoZC5nuC1FAW/4g+BggFgx44dCIVCWLp0KW6++ea0v82ePRtXX301xo8fj7vuugszZ87E9u3bsWnTJgDA9ddfj3Lly+GOO+5A586dAQCLFi3Ctddei6pVq+Kll182x11yySWwbRvt2rVD48aNkZGRgTfffBMA0KdPH7Ru3RobN27El19+ecSH+9NPP2Hy5Ml4/vnnwRjD6NGjAQDxWAzLly/H2rVr8dFHH6V95tFHH0XVqlVRs2ZN9O/f//+b0VuUef8/zAA8z0PZsmUlhj9vHpo2bSqdLM+D67oIh8N45ZVX8MQTT0AIgQcffBD5+fnIyAjD9300b94cderUgeu6OOeccyCEQF5eHtq0ycWgQYPwzTffwPM8NGvWDKeccgquuuoqAECZMmVw9dVX47333oMvfKxYsQKzZs0CAEyePBmO4yiP3zMRiRAC9evXR9euXXHnnT3gOI5BMa9r2RLz58/Ho48+ivvvvx+O45hz6KjGcRy4jgvHcREKhYyDFw6H0+7X9334vg/Pk1FJ8EdfT1Hg/n+IE/jqq6+iW7duin3jwHU9COHDU8mSeDyOG264Ea+++qrZdyORCPbt249kMgnbthGNRsE5Nw/x66+/xmuvv4Y9u3dj9OjREmGzbURjMelUWhZi8Tgsy4LjOBCeQL26ddG+fXs4rosbb7oJBwsKwBU/QG9HBEI0GkVBtAC+J2DbVmpwVRh4Vs2aOHjwoGIfM9iWbcirRISCggL4vo+bW7dGNBZDZmYEHTp0QDQWBQjIzc1FMpkAYxxCCDjKgLhyOi1uSUZQOATbsorcCIp8Bfjhhx9QuXJlrFmzBo0aNUrP2gmB88+vD4tzlD6lNK677jpY3MLBgwcxbtw4EAk5gOpYR8X+nudj5oyZmDRpkqKHE5xk0hynY24iQjKZBEC49LLLMHbsU3jl5Zfx2syZEGbWU1rSLZlMqhBV0r/k54EH7r8fQ4cORa+ePdG5c2cIX6aq9XcQgHAohNdffx2+7+PZZ54xTKOxY8cCJOHgZ599VjGVkGIZqUyhyT6CDpsJPOGBIMZYi5ycnItDoVBZvYzNmDEDHTp0wJw5c3B9q1awQyEzUNq6X3zxRWzYsAENGjTAgf0H8PEnH5sHqY/jOvTjHGAMrlqebVsuYr6QqVQSQjp9KtyybMskVnS9gUYgZdgmwSLLsgAiuJ4L3/MlJ9DiCIfD4JzJzwmCMIwgmaTRQJIOVx3Hge/5qiaBI5QRBkgaFkPqejjnkqLueQowkwQR7eQWZi4pVPW4A0FFbgCGECECuXBFfkjx4hU4wjmY4toRVKpUs3ZVDM1VIsfzPAAEy7IBJtm9Qs04nS+QMXp6rZ6e+QjG/YpCrtFCjfgxxhAOhw2pRSKNLDU7NXrHpSERCTiuBxK+2l44LDsEIsBzXYl/WCnjlGCXAog0xcziBhEMViyd1EhgsP4uSIpMpYW54e0TJPuXBEwxRzD9ywNoIoGgdZJEgO3LGZPsIQZYZEmiB1TxiPANImcesBAgxhVjKLU9BQs2RCG2kR4wWAQwCwyBnL8vIHTuwiLFQKe0c8otQCKiQhscGDhJHiInabxFHQ7y4jKAX375BQCwatUqxdgRadSob1Z+g4ULFuKLLz6HlhnQK4WEjsnkEygwSJLihdQeqpNN8AGRonQhQOvSULRQM94YpqaK+ZqGltqmNGvH9+UA++pHiADzR61YehXxNSVNwLCXfPXdHy1bBl9IeNnTqxxnatBZsSkrFYsBLFq0CHv27AERYcKECYbBowfj1ra3YsfOnWjVqhXKlZEp2Wg0Zma172sqF6Wza0Tq3yQEyE83DLklCDNrg3kIIXz4vmfeM8elnSNobHILMAMsfPgk6wf04MprlOfVvEBdUCIHW35eeD4sy8KjjzyKZCIJz3UN2hgOhY1fU1Q0sGI3gMWLF+Oiiy5CQUEBzqx0pslyMsYx6N57MXv2m3hrzhxcdNFFGD9hPOqddx569uwJxoDbbrsN3bt3w5VXXmnYPuvWrUP79u2Rm5uLgoICMMZw4403od1tt+G6667D7t170K7dbWjatCkcxwFjDCtXrsQVV1yBtm1vlaVnjOO1ma/hmmuuwTXXXIP/fv1fXNG0KXJzc3FV86uwYsV/wThDXl4ebr31Vtx80804cOAAOOfYtGkTcnPboPlVzbF06VIwxtC3T180btwYs2fPhqV8D854gLQst5tvv/0WjDFcfPHFWLlypUEFNQoYRCWDGdUT+pVMJk/fs2dP3/z8/PmO4+wiIvI8j1zXJc/zqGfPnuS6Lj311FO0adMmikZjFI1GqaCggO644w568sknKS8vj5JJh3bs2Em9e/eme+8dRIl4nOrVq0cFBQVUEI1Sv379yHUcSsTjtPiDD2jx4sU0YMAAcpJJatiwIcWiUTp48CA1bNiA4vE4RaNRGjRoIHmuS127diUn6dDBgwfp/4b+H0WjMWrVshUlEglyHIc8z6NatWpRIpGgaCxGPXr0oFg8RslkkpZ9tIyW/HMJde/enRLxBN18880Ui8UoFo9TIpmkufPm0c8//0ye69KokSMpGo1SLBqjRCJBnueR53kUi8UpFovR4MGDzXMZM2YMJRIJcxwRkRCC9Mv3ffJ93/y34zi78vPz5+/Zs6dvMpk8/YRfAYgIK1euRNOmTQEAP//8M8qVKycLNQL1c/v370eZMmUAEE45pZTKlUtH6cILL9QnQ1ZWFgDCTTffjMsuvRSXXXYZ8vPzQUQ455xzVKEIR+3adSRdzLaxffsOEIDp06ej/gX10bhxY5QqVRIgwsCBA9GkSRMMHDgQQgjUqVPHfFelSmeACLjhhhtwycWX4IrLr8CePXsgVDyvSR0gwq6dO5Gbm4vz69fHtOnTZbIRQXJvqv5v1KhRZoZnZGSo/EIoDf8vCkmcYokCDrdUvf766xg9ejSICBkZGQZZ8yXJH4lEAvfddx9uuukm9OnTBzNmzEAsFkPTpk0NDuC6rvHWPV+gVKlScF0XCxYsQGZmpontHcdVXAIB1/NgqRSsIIFOnTrhufHj4XseNm3Kg+MkUbJEDj795BNYto3Bgwdj+fLliMWiYAC+++57eI6javsYFixcgEgkE46TQMmSJbF/3z5kZmZi29ZtqFOnDvr27YvOnTtj/fp1SCikTyaDVAzvOWYSnHfeeSAi/Pe//z1k0IO5gJMuG3hkShjw5ptvon379qmcufr92GOPoX379nj99ddx3XXX4bXXZmL8+PG4Z8AAMMZQvXp1GRczhkpnSv+hd+/euPTSS3HmmWeiYsWK8rhq1WU8zjiqV68BriqCatSoAQCYOHEibm3bFq1atUJOTgkwxrD6l19w8SWXoHfv3njyySfRokUL9O7dGzfd3BqTJk0EYwz/N3QoGjVqhFIlS+GMM04HGMOECRMwYMAAXHVVMzDG0OCCC1CpUiU0bNgQ8+bNT5WlaY9eYxicY8qUKQCATZs2SXDoMLpBwdXxcFoEJwUlzFC+Annt4L8L39Sjjz6Kd955B2XLlsWDDz6Ipk2bHrIUFhZgMu8F2Eb6thg7jB6QWrYV2nDIeW+99VaVMCJdTJim6nWkgSh8XWkVvYr0khpUSSxt3bq1ocMf7rkcLit4wiOBhzOAI20NReHZskKFJb/nDs2A6gHB8ROzPOqMZodWARQlFFwshSGF5do0PYwK3fThlDZTKOKxEWTTBkJRzAuzazQSxwIP+9BjVKiqoewjzqDUQVSopIvY0Us6UvcYJAEzUyj6Ww3rhMUBdu3ahccffxxEhDvvvNMkZfTP+nXr0KlTJ9SpUwctW7bE8uXL01A1ycj10lA7/VmD7PmeyaXr37qu8OabbzaAj+d6cD1Xkj9d1yRj9Hn193meq5xLaSz6vMHc/bZtW3HxJRejQcMGWLdunXFYHfUz5oknjACV/myQe6CP198l708cVjXkpOUDAMCUKVPQu3dvCCEQiUTMwOkwcf78+ZgwfgJ+WfsLqlWvjrfmzMHPP/+M5s2bo2zZspI2DY4DB/ajdOnSyM/PR15eHurUqY3MzCzs3LUTOdnZ+OGHH1G//vlIJBJYv34DQraNOuecg8mTJ4OI4LouvvvuO/i+j9q1ayNk29i+YweEECgoKECtWrUU70AifTbnyMjMBFMG4BeChx988CEsXboUlmWhT+8+eOGFiTIbqJjK/fr1Q6mSJUFqoAUJWf3DU/oAMp0tTLYTCMGy2G/SLjrhV4C8vDxkZ2fj888/l0UWAUj2xRdfRM+770bPXj1x/vnn4/+GDEFeXh6+/vprrFu3zpR+CyEwcOBAAMDAgQNRt25d3HmnLPuaPm06Jkx4HuedVw++76NTp84499xzUb5CecydOxeDBg0CEaFvnz4oUaIEypQpg/bt28MXAk2aNMHq1Wtwbt26yM3NlRC178nVR6SkeYUgBSHL6/Z8H3v37jWGXOeccwBIKruvId9gLkFXFBeqdA6GxcGS9ODsP2m2gCPp3ZcqJcGdt956C9dee63ZOzmAzEgEk16chKlTpwIAnn1uPPLz85GVnYUmFzfBiy9OAmMMX3zxOZpe0RQTJjyP++67Dz/99CNOOeUUgMlc+8CBAxXcypFMJvHtt98CYGjTpk2Knub7OLNSJVSoUB4XXnQRGJeQ7NVXN4dlWRKw0nl5U4qmhSnUQHCVrmVccg/Ufq31Crny/JminCOwp6cGFKkyOFVupkvCGOFXZXFPqhVg5syZhsypcXkZI0s+vS8EGjW6EMsUpv6vf32JrKwsxKIxMMaQm9sWS5cuxYgRI9Cte3eACPXPr4+6556LZ54ZZx6QzutzzrFgwQKcW/dcTJw4CW/Mnp2mC6S5/J4qNM3OzjbKYVwNLrP0uVI1AzwgU8dtRSEvWdJgGtu3b0/VMnBZlWR0CBkz35uqV2CGBpaSswk6gPRbVMRPDAM43IV+9dVXqFWrFjZt2oR69eqZ2NiyJJumSpUqOO+887Bu/XpUqVIF3//wPT7//HOMfeopWIzjljZt0K1bN9x6662wOMc9A+7BjTfdiB9+/AkPDBmiqoMpUFJloWvXrvjxhx9RvXo1nFKqFEhIRlHVKlUwf8ECfPDBEmzfvh02t00JmN6TzQDaSpOQSQaSpRXBdAWPzdHy+uvx6pQpeEfxGBljeG7CeFmWZtv4+edV2LZtG3bu2I4dO3fKPL8hqnDFRtKcRCtNUgZgv4o/nBRA0JNPPon77rsPkyZNQseOHZERyQioe8gbe+ihYcjMjCA3Nxfbd+zA2KeewqKFi4yEilZN1A9MQqsSYbQsyzhpSqtLAUE8VbmjBBmEkN64r8JQpv4uZ6wsJ3M915BGJCVMQsG+75moAkz6BMFKHo3YOa4Dz/eV2JONUChd2tayLJUlJJlX8DxTAs4Zk6uPqoMsTC0/qShhnpZ4RXpCJEja0ECArsox9K2AfJrwpWMEzmApfJ0Ipk5P5s6ZooQJc1eWKgbRs8qEgYaDx9SSbSkNYhsAwVEEDVKrQUZGBjhj8FzPOIWpCclgWcwYpiCC4yQhfKkCYlsWwuGQ5AQqQmtIRQGkVhzfcyE0chg0SKVoqgUiTnpKWAqASYkqBZVCOOdS4QvpApG+0hFgAASndF6hYvkwRoYRZAAguWSACSUuqVA9zfgFmKlEZoyBgwIsXR/CE1KfThCIS/6eHFhFNBFKsl45b1JaThjsgjEOoXh/esUg0hIxBBA3ZBNf1z4SB6lBJ6KUJH4RQgFF7gPo9w8ckC3u9ubvTSsP1yHenj27kZeXh+3bt6evAJrI6fvYt2+fYfv4QZaOOp+nwSDPTzGKoWljKUaP5/nYtWsXXN9TtK4Uo0cXbHhqIHfu2g3hEzxfwPM9uKr61/Fds1qY8NAX8FwfruvD9zy5lShh6415G7Fr1y54wjff6Qsh/1v4ioksii0LWKw4wJIl/8TKlSsBAA8/PDxdYNHi6NKlC95/fzEqV66MTZs24bLLL0slRHRVMOd47tlnU0u30dRjRkfYCuzHzCiBMCUUKQNPTb1+/PHHjSCFtltSfkGH9h3MuR4eNkw+KMaMiLX22oNilHo/5UroUbN7GQPemDULp1WsiLJly6bCPiYLh9OO5+kVxCedARzJchcsmC/z+56P8hXKywpfVRQ5ZMgQvPbaa/j+++9Rrlw5zJ8/H5dddhm6dOkC27axN38vGjZsiOZXXQXP88AtC5s2bcI555yD29vfrgo8Q1j8/mKce25dXHjhINCHSQAAIABJREFUhVizZg2iBQVo1qwZqlSpgpVfr8SokSOxYsVXKFO2DDIzM7Fz505EIhG0u7Udmje/GjVrno0tm7fg9Zmv4Z9LlqBMmTLIyMjAlq1bwC2GjXkbcMEF9XHuuefihx9+QFZmFtrm5qJL5y6ofGZlLF68GJZtIZIZQVZ2FiIRWbnMuYxKypQpg0hGBJs3b8a5dc9FjRo1sOK//0VGRga2b9+BCy5ogFq1amHFihWHCEOc8K/DUcJc1zU/mhL2wgsv0Nq1a8lxHPPTo0cPev7552n16tXkuA5t2LCB+vXrZ6hTt99+uzlPgwYNyFX0Ltd1afv27TRmzBhyXZc6dOiQ9p233nqroV55nkePPfYYffXVV+a92267jTzPo2rVqsljXI+6d+9OnudRbm6u+VybNm3I8zxq166dea9v377k+z6dccYZ5r0hQ4YYCpf58XzyfI8mTJhAvu+T5/uUm5tr/j5w4EDyfPkdvu+T53k0aNAg8n2fhBBpPycVJSy4EqxatQqNGzcGAHzzzTeorBTBjBCDbWPbtm2G+FGpUiVTHMkYQ2ZmpkHRmjWTBIwpU6agRIkSqFq1Kg4cOADGGG5ufTNOO+00PPTQQ7IiJxRKawjhui4uuOCCtBYxjDE0bNjQbDXVq1c37weFGnRhiN4+qlWrBsYYGjVqZM5XoUKFtDy+PmdQppYzhlgsZv5+9tlngzOOaDRqvrN27drFpg1QLD6ALg3TiJau9tHZvHg8jn/8/R+45pprsGHDBtx2222Gfau19fSxixYtghACXbt2xb59+7B3714MHjwYvu+j2ZXNsHnzZgwbNgz9+99jMoREhHg8npbp0xW9ruvi888/Nw7j6tWrjSSN4zhwXMc4o6FQCI4nK4J//PFHU7PoeintIJMNdBy4jpNWhibvwUXJkiVNYunrr7+G68r3XHWPK1asMNEM4SStDg7uW5r2tHDhQrRt29bE4b4vAZAhQ4agS9cumDdvHizLwvQZ06XIEmdwHAdPPTUW5513HkqVKoUOHTrAdV08NXYsGjRogGg0iqVLl6J8+fKYPn06Hhr2EJo0aYI33ngDjAHNmjXDmjVrsGzZMoTDYVWd7MD3BcLhMKLRGK644gpcddVV2Lp1K/7z1X+QSCRw9tlnIxKJYE/+HmRlZUIIH6MfG406tesgmUzi3XffRUHBQUQiEcTjcdiWFH9wHQfxREKuFpwjFLKREYnADtnKCAWeHPMkateujXg8jiVLliAWi+Hxxx9HHfXeh//8p6wttBVgVNR8jeICglJ5e1VYoXLtGs279957MXv2bFSoUAEjR43CDa1awddpVCFjYsuSihrQFbkEhMIhMDB4Kt0K3cjBQMMhs6T6noek48DzPaURxHH33Xdh2tSpsEMhEBESiaQyEh92yEZOVjY450gkk3A9pTAmyEjVW6q0PBySdf+xWEw6q5wjHAohkiW3sEQ8DuFrlTAlEiUEXLWSaCn7kC2bRdghC5xbJycSaNv2IcWhwdSnUdLWaU/OA7JoLHC8zsFLMEUXTgAE13FBYBJqZUymYHWRJYepELa4pbQHFalD6RNI8IYZ1M2yZXGnjPMlZsA5R2YkAsYZHKXyFeQDaGk3y5Z4vhACiWQCQgFBWudIJsKSIEGwbC0Th8MgkywlHxOQiilKAyj2plHBmzqktw5L7+4hK3gIwlJdwHiq3w9XhiDLxQGyuKKASQvQ2cagIyYx9pRyGGOFY3muYOmUSpn8vDIkRfNKo4wxGcfrc9mWDT+YTmZcXaclu5kFM39QKmGByqE/nUQMAOzbt88INPfr10/XUxhMPR6Po2vXbihz6qm46qpm2JS3SRV06qJNYUq/TcEFUdp5DLysavFTbWC01q48cPToUaq1i59qBBWQ6Zc1ogGZd4KpLJadPdIJHQBBQGoUmRMFPPhHHhkOAIhGY+jbty8ISlZet5ARKRAKAFq0aPHnQwKnTp2KO++8M+Agpp74unXrcO/gwXj11VewefNmLFmyBEv+uQTz588DgZB0kognEmrPJyQTCSSSiTTZ+EQiiWQ8qbp6EXr16oVoNAoonyCRSMg9WPiwlKRLLBpD0kkosWZhmkuJwpXHZrUKFIoajR8Py5Ytw5eff4FwOIx7BgxQVcMpRdIff/wRggiLF7+Phx9+GN27dYNlWdi8eTOeffZZAwN/vnw5Pv30U4TDYdx7773FJRBSPAawdu1alClTBl9//TWuvPLKNJz/iSfGYPSo0bjppptgWRY6d+6MvLw8fPjhhyBBqFOnDn7++WdMnjwZQ4YMwQ8//oAXX3wRX/7rSwghMGnSJKxZvRpvz30H7777rgnZIpEMCCIMf/RRfLh0KRLJJCZOmoRwOIz7738Avu9jxIgR+P7770zvAWlUqQpg0g4fSd1i35dUMNfz4CqBqIsvvhgLFszHZ599hptuugnJZBK33HILHMfBqlWrcOWVV0IIH198+QVycnJw76B7MW7cOIwcNRI9e/aEp8LShg0bYskHH2DFihVo2bKlTBj9WQxAt06bNWuWkYnTzZwikQw888w4zJ07F6FQCNOmTUN+fj5ycnIABjS94grUq1cPvXv3xpYtW3DBBQ3Qt29fvDlbyr/Vq1sXLVu2RI8778Rnn30ms4ZCmH1/7S+/4Lprr0OpkiXR8+674bouRowYgaysLDz88DC88MILam8/uqdshsMoeShnjXMMf+QR2Yji8svBLY43Zr8By7KwdOlS9Ohxp5TK37ARlmWhVu1a6N+/P5599lkDNmmn76FhD6H+BfXxt7/9DcUlEFDkBjBnzhx06NABjDHE4/FCsuvy688++2x8//33YIzhl19+QWZmpsEPSpQsYRIzJUqUMJ+PJxLgjGPmzJnYtGkT9uzZg/37D6SkWC3dyIkUqYcZ0oYdCsk4m1uIRmNSohYKueOWGlweSMqo61WhZTgckoqj2dmIZGYiHA4bA87OykbJEiWRk5OD77//HpZlY/ny5Rg0aKBRAu15d08jDpmVlYXsgFLoB4s/gB2yi0sfougN4LPPPkP9+vWxc+dO1KxZ0xSA6AdbqlQptGrVCgsWLEB2djbefvttvPnmmxg+fLgRktYDmBoMZrzmrVu3IhaNYtiwYYqWJaFVXZhf99xzMfedt7Fz5048//zzMoJA6vNpHlhK+idtBqZ6/DETHeiEVlDd01IQdOvWrRGNRlUlNMfHH32MK6/8W+p4O6UIPmXKFFMhbNvq79wqNji4yHGAoUOHYuTIkRgzZgzuvPNO5OTkGPqz3HcZ+vXrizp16uDuu+/Gpk2bMGjQICxctFBJtYiUnDqXnD8iwHWVSljIBgMz+AKC/fysVIhGmrKtu3RBiVcH4m6t8uX6PuDLLp+RzAjAGJykA9/3wCA7loczIoaedriqpTfeeAPNmzdHmTJlkJubizlz5qSFvyxlaUfNpwTzESctEJTGjQ+QJ/QgSFq1AoKYVPJOAUcehFBxuWXB1nJuruzAoYWV5XGpDqDc1s2jJTVMQBqT53nGADjjsEOpGayLRzRhQ8vEqYevfAsCtyyEQ2GDRaSMgKV0Aw6byj1Weo/uRJreNvakBoLSOoBpPZ1CLeGJCEz3/FUhnq+0/4yiF0/V/KdzDSmFLjIGCF1vyKFbPmuSqWkfb0skUPIK5WoUDocPW6GbkRFW9LMglz81h4KkEKTVOOr3Au4kyZoAQ/nWFDZzP4evbtbXdDy3hj+ofXywA3hh2yczk0znbxbsEh6YbZR6KHpPTyv61O3ZmCzRZkidw/DveYqGzRgZHyPwxOWipLB/k9tQoWPh4lLdGiOYBtZNqwOnTIFapvqIFSqOZUZJ5aQvDl2+fDmWLFkCABg0aJCBTG1uw1Y9BF544QUkEgl8+OGHuOyyy1JCi5aNkHG0LNOq1bJSCp9cYfmWZQek6OV2odvQ6LyAbYcQUlLxGv9P+SOyiZPrOEgmk0aGVvoPStLNVQWiCgdo06aNkZwTRPBcF4lEEo7r4IYbblBbk49p06aiZ8+eZgVyXAelTzlFns/xcO2115rUshCE313f/kcZwOHKmubMmYMWLVoAAEqWLJlaDRkw7OGH8dTYp7B//36UK1cOK1euxOWXX4Zu3boBYBgw4B4zk0aMGAGA4ZNPPkHlypVRr149bNiwAfn5+ahWrRo6d+5klt8+ffqiRYsWGDBgQKrMW7FzW1zdQoEtMALPtWrXRqNGjTBh/Hi4vofdu3ejWrVqyG3TxghIdunSBR07dkC5cuXwxRdfYMqrr2L+/PmIZGQoWFcCRUJlO3WuAAyIxWK4/PLLDAl2+rTpeO655ySRVfEWfE8bo0hfLU7WMFBnuTTJYsaMGejUqZN5WEII7N27F4sWLkLLli1RUFCAG264Aa7roWLFiorEofX2UhKur732GjZs2IBvv/0GVSpXxv3/+AfWrl2HRx99FJMmToIvBD799FMsfv99jBv7tGEZa+x+8fuLsWjhIvzj7/eDfEKf3n3w008/4d///g9mzXoD5As8cP8D+PnnnzH26acx7umnIYjw0Ucf45VXX8XWrVsxb95cdOzYHtdf3wqxaMwkJSjo5Jrvlanf1rfcgrvuvgsg4L333kM8HjdOsWVZCm5Oqan+KRpGrF+/HvXr1wcA/Oc//0GNGjWMg0ckbzwonHT22bWkDrDm1Af4+joBc+GFF+LMM8/EU0+NldXB06ejZMkSqFevHn75ZQ2IBBo0aCCXZRBC4TDCapbefvvt2Ji3Eb4Q2LFjBwQpdXHFv2nZsiWEILw+63WULl0aNc86C6tWrQIR4aKLLoJQqp+nn36Gafuq5SOMArgyhDSnXhlD2bJl8elnn2L0qNGmOkoIgfLlyqWMVDkqfwqRqGnTpqFr165mRUjz3BVda8CAAbjlljZwPQ/du3eD5/uIx2IqP++aIpBFi94FQOjWrRs2btyIAQMG4oEhQ9CpU0fs27cP+fn5GD1qlMy7K619AiGZSCKRSIAEIScnB2eccQa+/fYbZGSEQYIkyUReIRYv/gAEqReUv2cPEokEJk6cBNPDXvcDVuCQZVkmRRwc8GA4GHy/R48euPvuu1G1alUTJRADxisF1V/bUk8KSljwtXPnTnDOsWzZMrRu3fqQaODewYPxwAMP4K233kLSSZomzowzCF/grrvuQtWqVdGgQQO0atUKgNTfHzlyJBo3box58+bhwP79aNCgAeLxOBYtWoSqVavCMJKIgbgq52JAq1atUKlSJbzwwgsSMWTA00+PRe1atZGdnY22bdsCTOr5XdS4MQoKCrB06VKcWelM+L5nIjnd0bRGjRrIzso2fQWCe7cbYEVpXKRKlSr44Ycf1HtChoACuP6G6/Hee+8dMvhFLRBx3IGgwsWhnufBtm24Sg83Ld2qrNvzXPTr2w/z5s1DuXLlMHTo0FSXUbXvy3o/VRsoUsWhtmUBYKagk9SyxkykYCtcQNYjup5XqHEkxweLF6PRhRfBcRx0794N8+bPB6nUcWYkA4xzuE5K1Nl0PAXALAs2DzKCHNkHkAG2HVKMICZrBlU3E10wovUMKUAJ00zpwsWhnHO4rrs7Go1+IYQ4cZHAo8nEUUCd2+jyAKZ1ixZk0PtfmpS6DuUU+qYdS8uyTRNGUgaghRp06Mg1G1n4RvdHRxaWChOTSRnyhUI2fOGpbUQWh2pHVsLSFGDrSlqZzW0ZUgqBpJKIYaY4NAPEYLqd2CqU1VuijgDM/QWyg/rZ6aRUURhA8QJBh1nSgsmhwskZrilYhSBRuZxzMNUl1IA7Rps50BCSyRbsXB0gi1CpEIBkISc7BALg+S6Yb0MwYTT9TPaSA5ZhCalSMBagnRVq+sg4N8rvnHEQROpaQZKTSCkhyKJuFP2HAUGxWEz2AFLJobQVQP307dsX5cuXR6tWrXCw4KCid5HZKtJYOoRA2xlhZOVTpFM/VY2rqWQiBRfr3j2pljQi1d/Yl5L2RreHhNT79zUTSMHJng9Ph6i+dGg7duwIIQRKliyJMmXKoEKFCrjrrrsMwTUoQR/sp2yk5QNVz4cT1zxpDWDGjBlo27YtiAgHDhwwPYFd18XWrVvRtWtXPPPMOGzbtg0LFy7AjBkzsHTZUvmQXc+wZuQyLEEWV7Vo0716XcdBUrVySzoOkk5SdijTvojq05tMJhGPJ9C1axckkwk4ThKe50IIeazjJBGLRRGLx5BIJGWlsPDw/PMTkEjKaEL+xOEk4kg6STi+zBQWFBQgmUzi6hZXY/OWzcjLy8OTTz6Jzp07SxaR6xrgx7SNcxw4jkQdXb3NCP/PtQL88MMPOP3007Fq1SpcfPElaXo5I0aMwKRJk3D99ddj06ZNuP329ti5cwfefvttMM7w7LPPYs5bb2HtunWYOnUqYvEYrr/+emzevBkdO3VELB7D00+PxfDhw7Fl82bcfvvt4Jxj8ODBZgv47LPP8OknH6NmzbPwySefIplMYMKE543P0bx5c2zYuBEPD38Yffv2QSQSwaiRo7Bx40bcN3gw1q9fj/y9e0GCEI3FUl3HOT+kkpdz2YlcV/xOmzYNTZo0CaiVKCIM42l+jWYXBXsc/WkMQKd6X3/9dXTq1BHhcBiRSMT0BX7mmXH44IMPUK1aNbzxxhvIz9+L0qVPQTgcxrr169ClSxecV68eevbsiWnTpmHBwgWoVasWZs+ejaeffhpCCAx/5BHUrl0bc+bMwYgRI9C5c2e8//77sC0bs2fPRrOrmqF+/fpo2fI6VKhQAZFIBNnZOZj52mtYvHgxqlevjoceGgbPk5z+4cOHo17dunjmmWcw5oknULp0aZQoWQIVK1RATk4OckrkIDunRKqnsbrH7OxsxONxxGJx7M3fi9WrV+Occ85BZiQTmVmSESTbztqyH3FWFrKys1W/44hpIVtcRlDkTuDChQtx6623AoCp+Suc3jzjjErYtGkzqlSpgm3btiE7OxvJpJPWTUPvhZ7nmYJR3Z0zEomgRE4OAMgaPsfB5Zdfjm7duuGqq65C+fLlwRhDmTJlVNFoqsrI932UKFFCpXwzzDWVLl3aRC76unWRx5FyIPqasrOzccYZZwAAJkyYgFtuuQXNmzc/7OcsO53+ZSImnMSk0KDT8uGHH6JJkybYv38/KleufMix4XAY3bt3x3PPPYvSpUvjueeew7Rp0zB48GAAQOnSpfHJJ58gkUhg6tSp6NixI2655RYAQLdu3TBgwABEIhE88MADAIB27drhkUceAdTSfscdd+Dhhx8+4rV269YNzZs3BxEZsujhXqeeeiq2bdt2TPefQhaB0aNHo3v37keOwwN6wWnK6DgJdAGCOIDWB0gmk7t83yfXdSmZTFLfvn0pmUzSiBEjaMuWLZRMJimeiFM8nvrJzc2liRMnUjKZpLy8PGrTpg0lE0lKJBIUj8dp48aNtHbtWopGo5RMJmn37t20Zs0a2r59OyUSCRo6dCjF43Fas2YN7d69m+LxuGnF0rJlS6NFsH37dvOdu3btMsfF43Fav349bdu2jfr372/+Fo/HyUkmaceOHZRIJGjtunW0devWtGtPJhKUTCbJcRy6/bbbKZFM0OrVq2nNmjW0du1a2rlzJzmOfBb6x0mm9BESyaS5Vv03rWEQ1BrQ+gB79+49rvoARQIE2bZdtnDDo/SCC43wwcij7d+/H4l4HHYohNKnlEZGJCwpXAFAiVuSRwDANHa2bRsPPzwMDz74UEqrnzO8+uqrmPjCRHz11VfIUIkgI9hskEDJCBo6dChmzZqFZs2a4aXJk6U3TgIWt5CZmSmBIiX0TCJV1CIJojYsy0b58uWwZvUaZOdkp4Ag20Y4nAHGgKSqDbQt2/QD1NcktZC1Qyg5EnbITtsuTyok8GgG4Af66mkkUEO8upBTt33xvXTkzrJ1dTBMv96QIoWm1LZ1JbF6kMo5E0TwXRcJR4Zssr6QI6SOCYUkFSwRj8tG0UIgZNvIzsoC41J+1vU8RRwRygA4uGUjZIcQsm34wkcikYDre+CMIWxLZxcMJhmV4j7C6AvoOgZDlAnZqmUtD2gk8pMLCTxcAoMZoSUytCqmELPCbV4Z5+CWRN64Wip0+EVEsrM2Uv12oSBT/b3B9muMMViMgWwbIaX/pyVrNevIsjhISJaxJo7I9+WMDTqiWiuQB9Q+dZGnbdumZZxWBtcrlSBhxKP07CPLUjxHZla5dEranyAMXLFiBebOnQsAGDhwgBlsXfBh8cJiyixQLWuliycqnP++v/8dz4wblxpoFTH06tVLFn1YWqmLGUFnznUpt6SLaU1fi3P06dMX//7PvzFu3DMY8sAQQzljSgvYxOoB6pksZ+MB2FlVDHEbAwak7jMlAMkLqYtagR9uilH4nw0HmDVrFlq3bg3GmPGyWVp71PRiD1CwVFpepikOCfCkko4jt4yA8WiFzZ5398RZNc7CmCefBDHg5Zdfwtk1z0LehjxwMLzyyivYuHEjTjvtdJAKUZs0boJ7Bw/GsIcfNoPatm0uatepgw0bN2DmzJnYunkLzlTNq2rVqgUAGDx4MNq1a4fGjRtD+D7mzn0Hs2bNQrny5QKGrUCgADE1TU9Iat0VDw+suA0gkUgAkJ3DOnRonwoVCXj++edRvXp1VK1aFZWrVEblypXx2BOPgYhw6qmnokaNGjjrrBqoXr0GypQpAwIwf/4CdO7c2eDmCOQUiAjPPPMMJk58AWt++QVdu3XDF59/gVKlSmHNmjUYP2E8BBFisRhWr16DLVu2ggRQtWpV3HX3Xfj2m2+QlZUFX0guwqw33sBPP/2EEjklEI1G8d0P32NTXh6ICFu2bAGRwKxZszBr1hv417/+jV69eqF165vRrFkz7Nq1y3Aiq1evimrVqsn7rFwF/fr1hxDC3GONGjVQo3p1VKhQoVikYYoNCNq2bRtq164NIsJnn32G1q1bp1Xx9OzZE7169UpzjrSM7K5du9JauXMu+QSffvoJRowYgQULFig1jkBlEIDbbr8NDRo0xLnnnouxY8fi66+/xmOPPYZBg+7Fjh07MGLkCCQSSVx55ZXGYx8+/BEcOLAf27dvR7t27TBt+nQUFBRI8ocQKHVKKSSTSTRvJvUKde2C7/to1KiRcQ7PO6+eUhgR8DwfFrfQ+ubWaNWqpVIjt1KFHp6LLVu2GB9Bl4gh1W2uyGnhRW4AU6ZMwT333KOIH17aCkcg7NyxE7t27TLhEWNA2bLlULFCRXz99deHNJJq1KgR9u3bBxDh7Jpn48cff8Q555wDQPIPzz//fJQufSr+/e9/w/M8DB8+HFdffTU+/uhjVDqzElzXgef5ypNPnXfJkg/QvHlzhMNhnH/++bINvQ7DUqoUKd2JAM1r1apVxiDWrl2neAqW+ejevXuxbt1a8z7nHKVKlUKlSmfgu+++k2inJSXmOedo2LCh4Ree9AawZ88eZGVlYfny5WjVqpUqyuBgTN5YxYoVcdpppynvWXnAimzZsGED0zlcKnNbWLFihTwP52jbti0mv/wSOnfuDBICHTp2wj39+2Pt+nXo26cP8vPz0b9/f7Ro0QLDhw/HjBkzcO211+KJJ56QDCWbG+dr2bJl6NevH3JycvDA/Q/Asi08/sQTuPrq5ti5cyfGTxgPx5HwtKaExGIxMMvCWWedheuuuw7bt2/HSy+9DMuyUKlSJVSrVhXbtm5HmVNPVXCz5B9qUgsRcOmllwYiJGbqGBkVjy9QZDiA5sBt27YNp512GrZt24Zyivlq8uLqRjV9K7gFpI7zU7WBnGNvfj7KlC0rdfbV0gmGtJy6aUrBg8WhULl8pfQV0AiSM9AGgeAp6pcgGS5GIhEwAI5KRae1hlOfv/222zHnrTkQJOA6EkPggXyDBK5k+9uMjLBZHX4NRtf/raOGk5IRdNppp4GIULFixbQmEfohCgBc0Wi1xA5TcumpBsyyjJSIUKZsWQkUgQxphCldH03H5pyBCckmIiLJKhIEaPKIIAPk6O8SSiZGUIpcwhiM4leKjCLS2U0MGP34aLkmKJIHhABxrlaK9NrzI3VOPRp+clI7gYGtMi30kaBNoCtWIDSSIIskckL3zg00ZCIiCQiBTMwsqVlS299QtYzymKrHNCphqXrAVEcRJilbnIGTZa5RO2SccRUzsTQDYJyhRvUa5jukmhhLgVtBXl+hNjDF1VH1jzcAxox8m2XhkJRw4ZsP/g4ul2kOYaBu3swvKlSAiUKNmTmBE0/bAbmuG2OARRZ4iENqUabX54dCh3Y1LXy9HNIAglXgsgAVJrTjha77j34ViwEEwRs9G4629AVZsscJlzbfX1inUPPzCg9McPZK753/PpfJOjEzucVeHq693MJ8h8INko5GhDzS7Dni/lmoC6c+ViqHqvoCRRTRiRmdEziW6znku5TBscM4diea/n+RGsAR97k0GPi3D3Lhwfht1TOpnny+ysYBMM2lfM83W0/6eY+xM7jOgBonlopE/VOnw09KA/i9K8jRvuPXmi4zpvQjA9qA8nM6HklRsoIiFL/1+gpvdcerGbQQArFYDPF4/OTYAoorrNHL9zE95IA2r2Xb6jM8LZ0cTP3+nr3/N13Xr7w830NBQRTRaMFxSxP/QRIxxRB2/sqM4xZHiIdkz19lAACMs1dURZm/dSXQ1xGPx1FQUIBo9CAKDhYYVtNJsQIUpfMTdNB4oObu6NsACyzR/Ai4Bf0uYuavXdevGZf+u+d5SCaTcBwH0WgUBw8W4OCBgxDknxwGUDi0K85o46iOaODv6XgCmfrCotoCj/VZJB1HViAlpWZRQbQABQUFOFhwEH6hhhwnlAEcTeigKI3gcDO/cAhW+OEfQlsDK5IV6hBDO8rzEMJHIp5EIinL0MwKUBCVBnDwIFwVvp5IBkCHG/zgfwch0N9jCL8Wkx/pGo4EQh3P7z5WozjcqgDANNJKJhPGCJKJJBwniYICtQIcPECOc+IYyGBNAAABlUlEQVStABwAZ4zZ7DCo2/F8HS68Ki6QpajuCZBM51TxqeyLkIgnZLFrIoFYLGYXFER5QUGUa5bVCWEAJLM6FmMsxBgL63BKKAZuUe/1RTHwxemveJ6HeCIBJ5GQzTESScSTcaNtpH9isVg4Gi0IHTx40IrH4+yEMQDOucs53wtgs+/7vwA4jYgcIYQvjlO4Upyv4hz8wrM+Hk8gkYwjIQefJRMJlkjEWTLphA4cOLB93/59mw8ePLg3Go26J4wBAIhblrXa8zwWj8e3ATiFiBxo/bS/XkdG9BJxJOJy4OPxmPx3Io54PIZ4PMHU31k8Ebdi0di+gwcOriuIFqxOJBLxE2kFSIZCoTwAMc/zNgshMhhjfsAAimxKFWeDpeM562PxGOKxOOKxOGLxmIF39e/09xMsHouyWCIeT8QTe+PxxO5EMp48obaAUCi007btvUKIDURkARAnRefrYnwRCLGCmCx1U9IwKbUQpSDiydazOgTUDa9i8TiLx2J+LB7zYrG4d7y2gL9ef73+ev31+uv1P/v6f+Xwu/VNHO2qAAAAAElFTkSuQmCC",
          uso: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAEZ0FNQQAAsY58+1GTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAi6SURBVHja1FprjFXVGV17n3vnxcBMqWUqYmIVRIM2FdBIJqHjY2zxUccfNhpCwPYHv6yKhjBtQyWNRWnSxmYkISlBMAUH/FOKjjNaGVoaEWvB4dHUysBUZ+487p37POfsffbj64977nAZnCLMGaRfcnLnTO7MWWvt9X3723sfRkT4fw42lQQYYxwAiMjW19dfO6uh4QbOmB0YGDiey+VGI3kIEUV+AeAAOBFhxowZNz373HO7enqO5QcGEnY0naaTJ08m7r///pZInjUV4IkInPPq7y9btvYvfz04lM3laXQ0TdlslnwhiIgom83mFixY8O0rhkAJOBHhtoULH9u5c9eJbDZPmUyW0pkMeZ5HSikqj2eeeebnVwSBEviGhoZFL23a1JUYHNKu51MmmyXP80hrfQ7wzs7OT26//fYnAFR9pQRKwOPxeN3KlStf+vRUr+95PuVyuSLwcYqfOHFi5N57790EYBGArwGIf+UjcPfdd6/u7Ozq9X1BhUKB3HFWsdZSwXXtunXr9gJoAnAdgG8AqCq33aVesUutXjfffHNTa+tPf/3HvXsXVcTjzBiDyspKxGJn/2UQBMhkMojH44wxLgEcAuAAEERkvpIyWl1dfdUvnn9+x9DwiNLGkO/753ncGEOpVIo+7++nZDJFruuRUko3NTX9IPKq92W/yDmPt7S0rOk5dmxEG0NSSlJKkbX2HLvkcjnq7++noaEhyuXy5Loe+X6xdB49evSTOXPmLLzsBBobG1s6u7pOaGNIG31eOSQi8jyPEolB6h9IUCaTIdd1yfd9klJSEARjf7Nnz57EZSNQWzu94YVfbXz342PHVTqdIWPMecCFlDQ8PEyf9/dTKpX6QuBa6+KIhVZ76qmn1kdFYMJeyHFizgsbN37Q1HTXIiEEqqqqcM3sqzHnmtlgjEEbg3w+D8/zEI/FUVNTDScWA2cMnHMwxsYuALDWgjEGx3GQz+e9xsbGpT09PR9NNocnrEIPPvRg6333fW+R1gpfnzkTlZUV8H0fyVQKNdXVyOXyAANqa2tREY8XQXMOPg546bNEiogwffr0mpdffvkVAHdOSTfKOY/v3vPGJ7fccut1jAEVFRWIV8QR4w6ILIiAqqoqVFdXnQU9Bh4AzhIokSg9p/z3q1evfnbLli2/iZxAXV3d1W93dv1z9jWz6xzOEYvFEY/H4DgOHMcBZwyOEwPn7ByrlCs/HiwRUHYLAPA8z21sbPzukSNHPorUQkopXVlZoWtrpoFAiDkxODEHDufg3PnSwIviFEdlPHgAqKmpmdbW1rYFwOLIJ7KtW7fuV1pTLpejQlhZhDi3shhjyFo7dpXH+Pv/FevWrdsUeRn9zm23PSqkNEIIEkKcB9yUAR8/mV1sSCmpubm5OTICYb8yY/v27QeJiIIgBH4B1ScT+Xw+v2TJkjujIsABOHPnzn1odHTUL/U3E9slGhL79u17OzILAYgDmLZ27dqdJWtEqfhE0dra2hpZKwFgGoCburq6/kWXL/Ty5ctXRkXAATBt3rx5j6VSKf9yMXBdl5YuXboskm4UQAWAq1atWrV5KkGPz690Op1fsWLFiigIcAC1AG7Ytm3boakEbowhY8zYAslaG7S0tDww6fVAaKW6urq6u3p6eoamCrzWmpTSFASKpJRERLR///7/VFdXxye9IgutNPOOO+542vO8IFLgY+AVSRmQEII8z6NCoUDGGHrggQd/NOFK8SJajgCAPHz48BtPPvnkHy62XSlvW0o/W2thiUDWwlgLYwyM0dBaQymFIFDQxuD667+1JJJFfZgPMwEsaGtr+9vFKP1FPldKURCEivs+FVyXcrkcpdNpGkkmKZEYpNToKO3Y8Vp+0iNQ2mUGkAcwvGbNmp+9//77n19Q9ZJIZWJZa2HLVNfGjKkuAwUhAwhfwPN9+L6AkGLCLXR+Cd2rApAPguDTxx9//PlEIuF+0WiO3VsLawmwBGvLwBsLozWU0tBKIQgCSCkhhIDv+yi4HgqFAkaSSSRHRhKRESjtWQHI9fX1dS9fvrwtCAIzXv0S0BJopVXo6wBCylBxjUCFigsJ3xfwQuC5XA5CBjh9+ozq6+v7SeQHHOHhRT2AWY8++sPndu9u/zEAGGPKSBCIiolqjYW1pqi8MWCcQevQOkGAQKmxEQgCBScWx5nTvWLzK20vHjjQvWFKTmgYYw6AWQCu3bBhw4vr16+/S2tdBD9mn9Au1hT9rg20VuCcQykNpQLIcARkEIBzjsGhQbv79df/3PHWW2tHR1NHp/SIiTFWBeCbjuPceujQod8vXrx4lhAitI45m6ghcKV0CP584Mlkkvbsbj+y7097f5lMJt8FIAGYsHhM3RkZY6wWwJx77rlndUdHx9PF+q2LdV0bKK2hdbGuc87LElaCcY50Ok0db+77d3t7+4uDg4k3AeQAqKITJwYfJQEHwKxYLLb4ww//vuPGG+fVu54/VhpLkxLnbAw4ARBCoKPjrc/ad+363Zkzp3cDyACQRCQnvbF1kaXVMMZcrXXf4cOHP5s7b169EBJaKchQbc4ZhJAAA0QQoHv/e6kd21/d3Hvq1B4i+gyAABBcSPEpIRCGAJA+fvzYKSnlrZ7nFj0uJThjMGFCHzjQndm1c2d7z8dHtwI4A8ANzwvspTw0EgKl82AABQKYlAL5fAHGWjAAFkBPz8fi9V0739n/3nu/JaLe0C6FyR50xKLwPxGZ+vr6+c3NzWufWPXEMikVbLjB1dvbq1/dtvVgd3f3ZinEUQDpsB1Rl6p6pEnMOZ/2yCOPbHz44YdXzp8/f0ZDQwM+/OhIPsZjNa+9tv0fnW93bPF87wMAyVD1IArgkYxAaJ2KmpqauVLKGe3t7aSUUsPDw4mug+9sywykDwDoB5AC4EcJPKqZmAOoZ4xdXVdXt1Ap5bquexJANkxOP2z+rtyXPRhjFeH2ixPmqwbgX2gGvaLeVgknsrJpYeqBl+K/AwDMg91KD8rpzwAAAABJRU5ErkJggg==",
          gf: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3ggEBCQHM3fXsAAAAVdJREFUOMudkz2qwkAUhc/goBaGJBgUtBCZyj0ILkpwAW7Bws4yO3AHLiCtEFD8KVREkoiFxZzX5A2KGfN4F04zMN+ce+5c4LMUgDmANYBnrnV+plBSi+FwyHq9TgA2LQpvCiEiABwMBtzv95RSfoNEHy8DYBzHrNVqVEr9BWKcqNFoxF6vx3a7zc1mYyC73a4MogBg7vs+z+czO50OW60Wt9stK5UKp9Mpj8cjq9WqDTBHnjAdxzGQZrPJw+HA31oulzbAWgLoA0CWZVBKIY5jzGYzdLtdE9DlcrFNrY98zobqOA6TJKHW2jg4nU5sNBpFDp6mhVe5rsvVasUwDHm9Xqm15u12o+/7Hy0gD8KatOd5vN/v1FozTVN6nkchxFuI6hsAAIMg4OPxMJCXdtTbR7JJCMEgCJhlGUlyPB4XfumozInrupxMJpRSRtZlKoNYl+m/6/wDuWAjtPfsQuwAAAAASUVORK5CYII=",
          gh: "data:image/png;base64,AAABAAIAEBAAAAEAIAAoBQAAJgAAACAgAAABACAAKBQAAE4FAAAoAAAAEAAAACAAAAABACAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABERE3YTExPFDg4OEgAAAAAAAAAADw8PERERFLETExNpAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQUFJYTExT8ExMU7QAAABkAAAAAAAAAAAAAABgVFRf/FRUX/xERE4UAAAAAAAAAAAAAAAAAAAAAAAAAABERE8ETExTuERERHg8PDxAAAAAAAAAAAAAAAAAAAAANExMU9RUVF/8VFRf/EhIUrwAAAAAAAAAAAAAAABQUFJkVFRf/BQURLA0NDVwODg/BDw8PIgAAAAAAAAAADg4ONBAQEP8VFRf/FRUX/xUVF/8TExOPAAAAAA8PDzAPDQ//AAAA+QEBAe0CAgL/AgIC9g0NDTgAAAAAAAAAAAcHB0ACAgLrFRUX/xUVF/8VFRf/FRUX/xERES0TExacFBQV/wEBAfwPDxH7DAwROwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0NEToTExTnFRUX/xUVF/8TExOaExMT2RUVF/8VFRf/ExMTTwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQTBUVF/8VFRf/ExMT2hMTFPYVFRf/FBQU8AAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAITExTxFRUX/xMTFPYTExT3FRUX/xQUFOEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBQU4RUVF/8TExT3ExMU3hUVF/8TExT5Dw8PIQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQHxMTFPgVFRf/ExMU3hERFKIVFRf/FRUX/w4ODjQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8PD0AVFRf/FRUX/xERFKINDQ04FRUX/xUVF/8SEhKYAAAAAAAAAAwAAAAKAAAAAAAAAAAAAAAMAAAAAQAAAAASEhKYFRUX/xUVF/8NDQ04AAAAABERFKQVFRf/ERETwQ4ODjYAAACBDQ0N3BISFNgSEhTYExMU9wAAAHQEBAQ3ERETwRUVF/8RERSkAAAAAAAAAAAAAAADExMTxhUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8TExPGAAAAAwAAAAAAAAAAAAAAAAAAAAMRERSiFRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8RERSiAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQED4SEhKXExMT2RISFPISEhTyExMT2RISEpcQEBA+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAIAAAAEAAAAABACAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwRERNzExMT2hMTFOwAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABxMTFOwTExPaERETdAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAERERRkExMU6hUVF/8VFRf/FRUX/w8PDxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPDw8QFRUX/xUVF/8VFRf/ExMU6xERFGUAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODg4SExMTtxUVF/8VFRf/FRUX/xUVF/8VFRf/Dw8PEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8PDxAVFRf/FRUX/xUVF/8VFRf/FRUX/xMTE7cODg4SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQHxMTFNsVFRf/FRUX/xQUFMMRERN1Dw8PYBMTE3gAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw8PEBUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xMTFNsQEBAfAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgTExTcFRUX/xUVF/8SEhJvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPDw8QFRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xMTFNwAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEExMTxBUVF/8VFRf/ExMUuQAAAAAPDw8QDw8PYxISEnoODg5GAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMDBUVFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xMTE8QAAAAEAAAAAAAAAAAAAAAAAAAAABISEn4VFRf/FRUX/xUVF/8NDQ04Dw8PIRMTE+IVFRf/FRUX/xUVF/8RERE8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQPhUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xISEn4AAAAAAAAAAAAAAAAREREeExMU9xUVF/8TExT+ERETcwAAAAcTExTJFRUX/xUVF/8VFRf/FRUX/xMTFK4AAAABAAAAAAAAAAAAAAAAAAAAAAAAAAERERSwFRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/ExMU9xERER4AAAAAAAAAABISEpcVFRf/FRUX/xISEooQEBA/ERETwhUVF/8VFRf/ExMU+hMTFqoRERRlDg4ONAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAABA0NETkODhNoExMUrhMTFPoVFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/EhISlwAAAAAAAAANExMU9RUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xMTFKsAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGRMTFKsVFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8TExT1AAAADQ4OFFkVFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8TExOPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMTE48VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8ODhRZExMTnRUVF/8VFRf/FRUX/xUVF/8VFRf/EREU0QAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBERFNEVFRf/FRUX/xUVF/8VFRf/FRUX/xMTE50RERTQFRUX/xUVF/8VFRf/FRUX/xUVF/8SEhJeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEhISXhUVF/8VFRf/FRUX/xUVF/8VFRf/EREU0BISFPIVFRf/FRUX/xUVF/8VFRf/FRUX/wAAABYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWFRUX/xUVF/8VFRf/FRUX/xUVF/8SEhTyFRUX/xUVF/8VFRf/FRUX/xUVF/8SEhTyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASEhTyFRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xMTFNsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMTFNwVFRf/FRUX/xUVF/8VFRf/FRUX/xMTFPYVFRf/FRUX/xUVF/8VFRf/FBQU4QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBQU4RUVF/8VFRf/FRUX/xUVF/8TExT2ExMU1hUVF/8VFRf/FRUX/xUVF/8TExT8ERERDwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEREQ8TExT8FRUX/xUVF/8VFRf/FRUX/xMTFNYTExOpFRUX/xUVF/8VFRf/FRUX/xUVF/8PDw9iAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw8PYhUVF/8VFRf/FRUX/xUVF/8VFRf/ExMTqQ4OE2cVFRf/FRUX/xUVF/8VFRf/FRUX/xMTFuMODg4SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ODhITExPiFRUX/xUVF/8VFRf/FRUX/xUVF/8ODhNnAAAAGBMTFPwVFRf/FRUX/xUVF/8VFRf/FRUX/xISEl8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEhISXxUVF/8VFRf/FRUX/xUVF/8VFRf/ExMU/AAAABgAAAAAExMUrhUVF/8VFRf/FRUX/xUVF/8VFRf/Dg4ONQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODg41FRUX/xUVF/8VFRf/FRUX/xUVF/8TExSuAAAAAAAAAAAODg40FRUX/xUVF/8VFRf/FRUX/xUVF/8PDw8yAAAAAAAAAAAAAAAAERERDwwMDCgAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAIMDAwoERERDwAAAAAAAAAAAAAAAA8PDzIVFRf/FRUX/xUVF/8VFRf/FRUX/w4ODjQAAAAAAAAAAAAAAAATExSeFRUX/xUVF/8VFRf/FRUX/xMTE1wAAAAAAAAABw8PD2MTExToFRUX/xMTFPMUFBTSERETwRERE8EUFBTSExMU8xUVF/8TExToDw8PYwAAAAcAAAAAExMTXBUVF/8VFRf/FRUX/xUVF/8TExSeAAAAAAAAAAAAAAAAAAAAAA8PDxETExTfFRUX/xUVF/8VFRf/ExMU1hMTFK0TExTxFRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/ExMU8RMTFK0TExTWFRUX/xUVF/8VFRf/ExMU3w8PDxEAAAAAAAAAAAAAAAAAAAAAAAAAAA8PDzMTExTxFRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xMTFPEPDw8zAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8PD0ITExTxFRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8TExTxDw8PQgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8PDzETExTeFRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/ExMU3g8PDzEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEREQ8TExObExMU/hUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/ExMU/hMTE5sREREPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPDw8xExMTqRMTFPsVFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/FRUX/xUVF/8VFRf/ExMU+xMTE6kPDw8xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAwMFA8PD2MRERSkFBQU0hMTFPMVFRf/FRUX/xMTFPMUFBTSEREUpA8PD2MMDAwUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
          gl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAABnRSTlMA/wD/AP83WBt9AAAN1UlEQVR4AexcZXPjSBTcXxOTvMy7xxfGZWaGaJmZmZmZmZmZmdnMzB7JNwv1qs6VOJY0tuWUp/rz5PW0q0f99JQakcxK6eItQGZlBMgIkFkZATICZFZGgIwAmZURICMAshitiybrexXblk5DNnOk2i3G6bCvmYcJWuaMCevVohPAsWGx6h/Zd/wrd2xbWf0EcB3YqsqmfnK0LZseYZCIBEBWE/5p4Mp+wtCvJWO3Vqufv8dtHNoZCOo6ZYd1ahEJ4LtzRZ1fC+pTF9T1P7hZnQQIvHqiKW0IBFU5lPfiCREJYFs5C4r7Cfu6BdVJAOeutVEErfPGRRhGFAIgu1Xft0VUfYaBbRmXI1ItFuvzGkd0jyKo65oXNupEIYD//g11QZ2o+tRF9QJP7lUPAYJvX2haNIkmmKv0Xj0rCgHsa+dDWRgAx+al1eT5Z9+mCglaF02KsGyKBWCcdsOA1hXWZ6A7MB5X2vtPwG8a07tCgvoehchsSLEA/sd3sNtUWJ+mpEHgxaN0FyD08Y2mVbMKCarzavluXkyxAI5NS3AplcG5fVXa+8+h7TEI4kSWSgEYt9NQ3j5GfcZhXRivJ439JxgwT+gfg6C+dymymlMmQOD5Q01xgxj1acoaBV8/S2P/+fJe2+b3GATV+bV9d6+lTADc88FFxIZz9/r0FcB9fE+VBO2r56RGAMYL7ZFYMI3qwfp9aek/oZB5SnksdtD4cthSIEDw1VNNaaMq69O0bBp8/yot/Uf1Wdv+zyoJqgvr+h/eSoEAzl3roIjYcB3Yko4CeE4fxK31eAja1y9MogDQHhnZPU4BTGP74jiTZv6DwpYZw+MkaBgEja9kCRB89xLaI1VC27p56NPb9BIgrP2m6/hP1eyg8fX0XlIFcO3fHE9lAPeRnWnmP+ePqbIV8RN0bF6WHAGgPdKHkwDmiQPZUDB9XoAhy5zRnAga6Y78Gl81SLVHYkPb9o/Q149p4z96ja5LDieCmpKG0PhKuACuwzvirwze1LtP7EsXAbyXT6lylFw5OnesTrQA0B4ZwLU4DPPUIWw4lA4PQIx1wQQeBI3Du7JeT8IFCH35AO0RTtC2/yus/hIR/UImva5bPg+CmrLGwTfPEi6A+/heiCfckK3wnD0sfgF818+rc2tyogZw7tmQWAHYMG6P0FzLAlhmjoggJG7/YW1LpvImaBrVk2vjqwb39shfvOvTdfo3rFOJ2n8sJn3PYn7soPGVQAE8Zw6B//BBNp5nOi5q/7l9GSbM+AFPMCZKAGiPCIF13liYZxLhsq2YJZCgaVxfNhggLgC0R/7lXxzMMxm0IvUfu0Xfp0wAO2h8vUuIAJ4L0B7hD3UOnmc6I04BYMJMINxHd5EVANojY/jWRH6eifyCCTPBME8aBI0vYgKEDbg9kkukPphnEtWCCTPhgMYXSQG8V05De0Qg1Hk1YZ5JFAsmzArrCWUHja+T+4kKwLLWhRPJFAfzTCJbjo2LCRI0T8ONrzAJAaA90r2AYH363iUwz5TiBRNmg9sTJKjt8HdY/ZWYAL4bvNsjMeaZropHgMDzB5ri+gQJQuOLiACsbSm0R4jBvmqOiPxn6wriBC2zRkYQIiAAfIBHFnr4kE9kH+CRAIcP+Wpw/QCPBGCe6aYYP8AjBfiQj78A0B75W5YIiORDPufOtQkiaJkLH/LxFYB1W22j2xjL5MaWSsIoU9iGt/LfuYQbAKnEvau2cZ0SRNBKFzE2vTABtNfDKxqEh8jC5VLyoBWmdnVVubXUeamBKremsXXdULkiIezwoS2uy349I0gA5uFctD0LzaFQuQSVZxEGneXoitM1vGBIAeydlYgGakQxk0Lbspg7EyIsy1eAgJ051RLtyEJbZWiyAg0mX6W/P6XJU6Tq9NW5Cl9fCtGkeeGDmqBAW+Tfj+5YXsRr4CkAq7+N9tT+vsvOLLRBgcbIiWsQLpdhu1T9nRoBDKXK0GAZ+d/+KBlap8CH9v3odilY1QWeAjBPFuEtMH5psJJCw6SkXUji6FozVS5k61STvP8MlaLlFNopgaNj7k3lJUDQyZxp82MLgAQtpAhXTKfMhdQ5Ci95/5GgeRTaIf3fuZ0oivhMnAVgjffR3rq/tgBsl6EZFHEXMpSlwIX0JeT8B6x/Kr54ZdGHtlvJaq5wFoB5tvx/u4ARbZaj8UQvZFpi71wzBf7TkZD/wOmPlaONv6w/CsyDWRwFCLmZcx2iNwIN1lJopIygC/n6UfiBJNn+04eo/wyXodUUnH4UmFOlEb+VgwCs6THaVz96IwC+YZZSaCixCzmUdBfSF2P/kRM7/SEStBgu3oqwpxaru8lBAObFmkr2AkghnaWjC1k7EPQfyffMtV0a+8SYR/PjFiDsZS50jb3dr3Q2RfBlAC7Ul8K2kCT/yVZ4euMATMj6J/7KXLHBnG6Fg21cArCW52h/w9jbEU9n+IFEX6pMjgC6YmVwkJxQ5pKj9XDxxsSe2qzhbnwCvNpY9XagwSoK3z9EXMjWMSku9LfM2h78h3Dmig3myZI4BAj7mYs9q9yLfDqjs7x9kuFC6my5pxcJ/6GjM1eVYM62iwRdVQjA2t6gA405CEAuneHHEhyOEu4/RRQR/4HMxQF767LGh1UJ8GY7t00hnU0QfCHTEmuiXQi/pWoH/iMsc20C6+cA5vmqmAIgP3OlP8dNIZ0phKYzOsvTR6nmMP/La2ZNuP+MgMzFGcz5zpGQq1IBWOsrdLA5530hnS0TkM7AhYqVCfSfQuw/ClKZiw/2N2QN9ysVgHm5Hu2EW4UHpGiusHRGS3BEgkhM3H/MbbH/SAVlrlmQuXiCebygcgHOdeSxI5l0Bi7UG7uQPEH+4+oJ/kMoc/HAiaJKBYh+/uF3GWwUlM7wIwp+UEmEANoCKjBQQThz8cBuZeUCHPqdx46E0xktsbQj6kLgP214+Q9krhX8rT/qYbRyC7oxXOjukM4W8U1ndBZ+UFFly8n7Tw++/oOJzIfMJRTMpd6VCsBanqFjuWQ0wDfVTIq/CxVSIvKfaZC5BOPwn6z+Tswgpr+DTpaS+WNb+KYzWkrWhfBWptY18bAUn4t3HM5cckHWDzieD+8mY7ajXd+Ym6PQLorAZbCOYzoDF+qpxKZB0H+c3fEFwCtzraEInP4uOXOtnHV8iPuVZNiLexI8QhmpdBYcqNCScyFNPhUYoOCeuaRoCYmLd39j9uW6SMjNdS6IZY0PfiQDgRVI0Tzu6YyWmtsIdiHwn1ZK7v4jQbMFZS54D/P9ZSTL8B1P9xmZBzN+zcfxxjbZ997hYG4u5OpByoXkzm5KRHO0/kmCM9du5ffBUI9W8CdKTJD9fBQd/VdoOhvLLZ0FsAsVUAT8J4/y9+foP6MFZ67Df7Dv90aQn8AHGvCegLncD+2U8ddgNdd0JjW3FuxCf+PZU+w/XP7uMGGZa6eUudCNNT9NwL+rCTq+T2vtayAonQ2RcHCh7sJdSI5nTxGd8MwFKff79IPfkrB/WcYiVn0ZnSxJTjrDjy7afEqY/yjw7Cmik5K5juex/7V3Dz5yhVEUwP+cce2GjWu7cW3btm03qm27QRXVtt2ZbO8op/r2vp7qS+a+uHHP5r7z252ze2N7UUrZZxMB0FBw6GxQUJ1JdXlEXSHcn3oB7g/MFSPN5a75fyEAQGG5QIHUWe9IwCskBYa4Qrg/rfADSNZces1Poeb/swAoKEBnM4Lq7H372B32Ct2RAUxb3B/KXHzN/wcBcFCAzor92sQVIic01eTzprg/pLn0mn/Hgz/mKVC4moECobMgV4gd8snnTfWM5fTL/G1ZlK75HgTAQUGu7eJAOhNG6RMaboDXKWOuhTAXUfM9CICGAnTGD/m4AR7MNQunn6j5HgTAQgEv5CnQGTHkIwZ4MNfE+C80iE2o+Z4GgBTSUOgFKKg6G41vl5JDPmKANyKAuVDzO6HmexAAAQVSZxjy1cMVogd4OP0yc1uimgs1Hx9n8zIAHgp4GSwQnUWZCQ0xwBNzzYO5yJrvfwCAwmmBQklGZ8SQDwM8t7mm4cVL1HzvA+ChEE5OcOoMc2JqgAdzjcU3O4ma70EAPBQup/a3cUEBOhse168QMcCDuSLBaj7xu329CICHAnTWHzrThnz6AA//+30VcxE1388AeChAZz0jxJAPAzynuYia738AxPPqRgYKsWJ1Fv7xCgmvlAHMtwM8mGsSzKXW/AIIQIUCdKYP+fQBnkzYVkQcNb8ian5hBQAoNMPX5nc6Gwyd6UM+DPB0cyk1vwACUKAAnfWJ6kO+YgZ4vcRcePHqNb9gAlCggJfBTPyaLveQzzHA6wZzOWu+BaBAATpThnx3McBzmctR8y0ABQrQmXvIhwGe21zrSqfOjUfNtwB0KEBnUegsN+SLOQd4MJde8y0ARwqAQj6DudBZZsiXcA5gekSSs2EureZbAAoUquKFPDWns++HfBjgwVyo+RfmoeZbADQUcjobk9HZN0M+DPBgLtT8I0TNtwDcUFiW0dm3Qz7cn4E5c2Vq/gCm5lsAChSgs+wVwgAP5krX/LV8zbcAFCisjiRnxpI9wrkhX3qAlxCsibnYD+1YAAQUJkQ/dozL8ZEBzIf28eTYaHJtGa7mWwAEFPalNtdNDo89bphIfwBdzLWhBlnzLQD+JwoH+7/qVvFlpwqpPT34mm8B8M/n15+PLf90cGHRpxf4RwvAHt8DsMcCsADssQAsAHssAAvAni8AV5380akCdgAAAABJRU5ErkJggg==",
          bb: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAIAAADdvvtQAAAVZElEQVR4AezSQREAAAgDIKvYyEo2X4e9uSMCs/c1EAiBEAiBEAgEQiAEQiAQCIEQCIFAIARCIAQCgRAIgRAIgUAgBEIgBAKBEAiBwt5ZeLeRa2H8X3j82sfMzMzQTbtlXC4tl/m0cZgZt7wNlhmzaZIyh5nJ5aYcajb1+yU6x+1L7dTxQByPdHRyHI9GuvebzxpdXelq6OSvjvG25q88k5++KrEyFoG+SoYEo72/OMo0zMPzcy+s+uyInvzpnrzy0/9d+bkXPL84yoti3xjv941xvt+Z6P+jKUE/nBJozfzLl1yiAMUozC3cyO1UImqjWiqnCRrq4Zkk0NDtSL40ymu4h4mH+sn/9DzgL73o9e0Jfr94NfS/7ydMXb7xnYD0FTG7QzZlrNt1avtHlzJOl5zIrTpXVJtb3lhUbS6sMpfVXa0z36x9KvMvX3KJAhSjMLdwI7dTCVVRIdVSOU3QEM3RKE0jAGIgDCK5aNclCcT7hd+96FGGeZi+PcH/L7Oipy7fsDx297qdJ/bmFJwuqKlpun7rzoOHbZ1dH3dbNEtUThM0VNN0g0ZpGgEQA2EQCcEQT/RYCIzYkkCDlnlN8L7gDcLfH08N8piTsDhi+9qdJ0/kVvPwWu61Pn5scZ2EMIiEYIiHkIiKwIhtVQF1JIH0eDd9caSJkcfwUSZeE695bopKPXo8t6rhSktHZ5dlSCUERmyERwUUQR2UQjUURE1JIJV5M9zDE3AZw744/4PQTRmMP6633O/uppNxh4QiqINSqIaCqImyqKyUSZJAGDtAyYcpyzas33WqpOZye+cji1snFERNlEVlFEd9QJAEGrDV3Wtse/773bjIlMyiKrMY+RoqoTKKoz4gAAWAfFUSyJEMUhjADAsOnSy+39puMXwCBKAAEGABHEkgu3n4SBNWLkidyq92kS6n+zHJVTokYAEcIAIoSaC+w2Ss2VHzEg+dKn7U1a3dM2ht77x84y6DDGYCs86VMQ3IaCMqNct/3aFVcXuwrsmLIra/5Z82yydltm/q66ak6V7Js3xTZ/qkzAvZKgowZ+i75kB4cqaYh8w8W8qUT155YxVTTfdaO1FAM9JRNxABFHABmiRQ70iZ39M4n+jUrLsP21TEmnmX6sbrWRcqNuw+Hbj+8JyQrZOWbfjbmzE/fyXkW+P9+BEzoUf+rI2MU4LsKUYew/jQm22WFM6QzzGRM8bn+5MDf/dG+Ig5CW94Ja+M2xOTdnRHZm5BRTOUZfpSRdUACrgADeiMTiCe0O+nRzK9phxWfvr1l28yXAjZmEFX/5dZURCF+nv8Cf9dCScgDf4E4ajSoBMV7jYv4W6DWzT6mRd6vCjM8YxZsHp+WM8858m8aix2VXooQAM62jIugVD+v+/FVzVeV4JjW8ej88X1zKCMX7T2e5MCeGaYvtTsOr4nKAt3YTCUwib/+SuhM7xTeP2V111VOJUFdACIskYkEN0v7iH8lE7Dh8uJ19PIuYn8yiENDwnGDBUnDALjcH155Yf4yx60djgNAl5eYARMYxGo50mP82Xs6TRw+48X/mlW1CfF3P+QXTUgXnbMPit5iQMjYFKbgQgEaqbEfU5DlrT/LONW/X92Gk59jfbenZ3vNCCACaRGIRC/Fdw9xdVm58C619r+x5mRgj1uk1kw9LfZMU6/ywATSAHWEAT60ijTf9+Pd9qr1dnZNXnpeoxndyLQ50asGj3/AwwCpz1ojKYB1hAEosd+zTNJyWxbae2Vv78dxwCIAakbrJ9kQP3r18MultYrmTEHUoA1BIEwlyYtXf9xt6IZ52st94I3Zvx4WpD29pdWmYkGsUZlYcT2+su3lKABmEAKDgZ5hXn9dXY0Sz8tilPj1ZbV24+NWbgaQ4yXGvPFmPSuTCaWsTLcgTfDRpoAAZdIQWWzchwAk9oA1hAE4r3z42nBrMezqJSYgy6uMTMn9JZ/+h9mREImnhBWyaBPJzI9zdy0dWIa0vx0WjADuLCkj/CM3rnfqhYCgAmkAGsUM55+4lJZg0WDxFNh18TOzFyfNQdeX7Xpb2/FMj1Nc5j9PEKxg4eunhlhvux1a5CVezC8YSqGIVyxbgURL5TfT49gadiymN1J+86wgNV8/Y4W3mLARB1jzQMxA2vRPt190NZ0tQVfx77jhRt2ncLr/m7QlgmL1/7rnbg/zojEsQq98IOK9WtkPCEi23SdWq9S0rrIixrwduF6GzknAe/98pg9sWlZ6YfPZ50rx1lx884DMdrTNAEm4hmLQNFpWYO4BhmD+dbdh83Xb7MGg0mUiyX1WefLccRuz8zdkZm3JeMivqqn89pdp5i95BIOdvKR06V0J3llDSU1ZhxS9Cv0fKJrGZQEmIYjEAtr1IJPJsA0FoGwRCYtWd/5SIVVMjIBI2ACqYEIhG3yuzcibt9TwQyRCRgBE0iN5Y1ntRe7zZXDJxNDdcA0ljeejF2debZMOXwyASNgGm5BGbMy2NXK4ZMJGAHTcARiiSfTa8rhkwkYAdNwBGKililahZNsMgEgMAKm4QjE1PsfZ0bduvdQCXwyASAwAqbhCIQXiXBx1cq2ZMgEgL0mmDG39Yz0xIGgBD6ZABAYDbovDN/4emWGmEwACIxGJdCIVavi9yqBTyYABEZjEghDzHPqio1O786UCegAEBgNSiAWYbE58N4DJ2MqyAR0AAiMBiUQ7pvvTAyobHDSEJOpquE6y9mA0bjROVjXdzK3yjn4ZAI6ADR0eBeWQX2494xz8MkEdABoaAJhQZgSnDTEZAI6ADR6gClCnLiaRwx5WAzPZj8GGWQ+8K+rCdnV3Q10hg4wJQwxdke4iCGGGNkXKti5MWnJut/PiBTjUzIf+JcvuUQB15EW6ADQwAQShtgEv6rBNsQIYxi/JYcIivygxV7pp3e48oF/+ZJLFKAYhbll0E2w707wRzZDE0i8xbLOlw3iivTUg+d/83r4Jx2OCU8xCnMLN3L7IHrBgE5Gae1dmrh7cDxiV27efSdgM5vqnXgRcAs3cjuVDIrwgAZ0kkC9SxOjB2FpYmXDtf+8F6cwzhC3UwlV6S8/oAGdJBAeMRPxBnQNTS9iU86OVuUBUAlV1Zlv6By4frKI5yIJxPiUCATYybqhz6Zm4lqq+POlKuKLtei4ze3mnYeABnSSQL15nE9F/VW9PNjdy6J3YU89P7izh0kEUeCH/tzjKalwRexuKtdHC+ACNHnUwZM9YgdPFutmvPRGNOvHyDIRf+NnL4fwjiCUB5kZIOL68GU/ZhoVUq1uCyyBC9AkgZ4YYolbcrSHnbD2nYQzs2f9MqcCS/7xdmzaofME3GDq2TrgaL52O/nAWWaA8D3ZIx/VUjlN6KAIcAGaJNCTMcTCcD2CdRw+XcIryR576EI4lqWfoQyx8X1WHxjmYTckI5XThA6KABegSQI9OfZg9ILVWhtirN+b7ZcG7vb6j9Xbjzty/nJserY9FlI5TdCQ1iYYcAGaJNCTYB2/fi2MwKua4t50reWHU4IYDtuOVxS508EHz6ttTuhWm0SkcpqgIU0VASjgejochzxwDuh9CiubtR14niiy2XNgcHGCDpHwHK8K/zynvnOjzbcYDWmqCEABF6BJAv1fH8D5KZriHrYpg4Gnzab91h4caG0r4/Zyo02DgIY0VQSg+jYtCcTCqMjUo9qBztjlvaAtNt87jJ2PXaocaIUf2QmqQhNY/jSnXQKoT0sC9cnYz5xKqQB2J2O5Y0/9cHKAE4Hi2QvwnYn+3O5MHH4FCYgACrgkgfpO342c94E4gUWLxKmlNi0XxjG/eCXEiWB7V27c/elUMSS3YVHSnEaKABFAAZckUN8H+bOXgq/d0soQe/Rx97jFa58lEAyAB1dvDrRdxtEtP5wcaJNANERzGikCRAAFXJJAfV8lWBacWKPdCfDTvVKY7Hm2XYKFE9x+oBWeLartXbVoYz6Jk8K1O/kbiHpNMEkgW/7I3Vn5Fs2S9wf7acJmu5ynPNDaWNVqcy0RtdGQdlrszsqz6wmWBArV0gBOPXDus7YeOS8dTu5tbR+AD+t+a8e/342z6VulCRrSTgsgkgSyu0v1Tb807aDnWIKv2m86af8A9jfSY9mzg2iChrTTAoiQVhLItiHGUZgcfaWd/fLi/NWY2TaH8N+fHMCZLI7Uw0lNGPA2XSJUThPa2ZKAA0QAJQlEtulICuQAFItmac3OE8wU26Mva4CeG7qaA1lwYthbhE/lq3ec0E5+wAEigJIEsrtj5lxRnUWzZL5+myOeOGPbXuv8ZcFGrflmHzMKP2t103XPhL2YXfbYg1FG5TShnfyAI4SUBLLr0Eg/dN6iZWIxRj+DUMxj3Ew/mhI40yclJi2bc582H7kYnZo13SuJdxyXKNCPEZC4Vdtlcax0AyJJoP4MMbYPa3wEXavH3ERma/p/mQ57wZNHBWPIfKB8/1MvFBg5L/HuQ213PQMOEEkC9fcY3jAlaR3yjrm4b0/wV3FLA1UxrM4rb9BUbGABnP6oLwnE8OLvb8UKQ0zTtCengMGEKmuyqISqqFBrmYEFcIBIEqgfhwbmdCC7/izap82HL2K9KxyTcjuVUJUOAjO0ZxwGRJJAz5lOPIotrdfmmJ++HOL04ixu5HbdNiQBi0NTiJJA7wZu1i32b0XDNQYWn+3dPTig7djcwo3crltEX2CRBHIgj+l5LzChp+c+8z3Z+Wx2Fqe+M8iw+ZrgSy5RgGIU5hY99/MDCLAAjiSQQ0Pp306PYOLOomPCmcq+0qVRO/86O/rr43wx3Z8248l8ySUKUIzCesoGFAAihs+SQI7a8yPmJIiVpjqnew/bC6vMR06VbNp3JjY9h8wH/uVLLukvDyB4zEkYmPUuCSRWp7PLuLTmssXAqaTm8j/eiXNiE6okkDhe3vNnr4TsY7uPIROKoz4gAIUkkPPjIUweArI0X79jHOqgLCqjuBj3SAIp3bfKSJaz9ZmvE6NXN04oiJooaw0DIgmkWlfEIsDxi9YS/qKjs8v9qINSh0+XoiBqqt/xSAKJTNQw7BFQ3vbRRbGZyw0SiqAOSqEaCgpNJYG0jcvJz5RwT5EpmaW1V4bokXWIjfCoIOJWWafCJYH0e6mxOIYzi9mHtTXjIvMlQ4JJCImoCIzYCI8Ker6wJIFseBjo+dmixWLh6aakTXvPFFSaW1kQ4mIJkRAM8RASURHY9iI1SSAtxj2f/M9K/IiOMEks2PvXO3ErYnbzK2cirmXwhko0jQCIgTCIJJZcOsIblEVlFJcEUmGZ/bQVH7LW+P2QrXwmO9InUUy4sdilxamiM3xSIlOO7s7Ov1TWwDZ4VmY91mC5INVSOU3QEM3RKE0jgJAEkRDMEX3JKIvKKM5nSSBFg2UCeN9vbRdPiMhfRNem83e85xebKETPhEOUxc5syhnxfgLvEdyiESmZrJnPOld2prAmv6KZ8284g4cAcvi8eOOQCblKFp/5kksUoBiFuYUbuZ1KqIoKqZbKaYKGRE9D0wjg+LsY1VAQNQW/UXy02MgmCeT0ii3v1fv7TNEujdr1xV5OOBtLj/7JJFZukHlm4nwnnO3fnxTAvpxfvRr6h+kRf54ZSea986+348RnvuQSBShGYW7hRm4X9VAh1VK5c7N/3I5SS6N3mf9/wh31qVwSyHl/6rzQrZZn0oncKoI4iRjyKg7GyaxPJbNIXmS6ELL1X3FVlFSxl0UR1EGpZzVFfSc9qZJA/Yc9YPsw69h5wYG+6I2GXEZshEeFvTkFqGPTrYH6gCAJ5HyvgMXbz15PIN57rHDKsg1i1CzCLrl4RkgxpkZshEeF/jcyK+3tpBVGMIPnnjp4Mq96YcSOn78ayrNhTyCgu+Z8FeIhJKIiMGI/L4pDjbTCVNiryuSb40efbsu49IZXMtv8rDMursAbhEEkFuEjnuOHraI4N0oCKTXEOEZpoL4CjhDk3IKpyzdgMVEDmZGEbmSiIZoT7XLiM2IgDCIN1NOC4opNMPkK8zBNWLSWqLnOnayO12lnZi5PgtEozxKLBsObvz0bAlUypqiEqqjQWjkN0RyN0jQCOLd5A5VRHPUlgVziGA1W27C34cjpEqJ0E3GcAHVM+jFNLCb9+KHz4MW8AJ2H1Xq3WvXiGy4Jq5vC3CImJ6mEqqiQaqmcJmiI5lzlQAzpCyOcT35Fk+oL/7BxLpU1Zpwp4fhj37WHFkXsmOWdPGnJeo85iX+dHfOnWdF/nBnFkmQyH/iXL7lEAYpRmFu4kduphKpUXyqJyigufWHqDIN2ZOZadEmPurpxad2538oiL1yhdANkPvAvX3KJAvpIgsooLgmkjiEWsP6wxWAJlVFcEkidGdvXTUniPFuDJJRFZRSXBFInfBOjkLvsCjVMQllURnFJIHWmVb49wa+s7qpxCISyqIzikkCqjaPFYbYGScwFqDmClgRiOCmOozNIik7LQmVJIDUXBhHi/7FhCPS2fxoqSwKpuYOHSB1ibavbpwfWk1wkgVTcHs+gsrb5hhEIhPtMHKYpCaTybBBbx41AII7zHaa6D1USiHNM4tKzjUCg+M3ZKCsJpHIWR0k+dveBNArO8EpGWUkgDdZH98Qgd/NhEAqiJspKAmkyneiz5oB7EwgFNZpClAQSW7d8ci5WuCt7ci5WoiBqSgJpNyFk+vXrYUQscMuArKiGgjI6h+Yb5om6ncdJ726UUAel9NsGLyOU/Xhq8L5jbhL+F0VQR0Yo09u5QTCDVfF7xSG9QzQhPCqgCOrIAFOD4N/4dG/4Xw76v/ugbWhRB4ERG+FRAUVkhLLB7Ip4Bv95N44DaW/deej61EFIRP3Pe3GIjfAyxJ1LZLET9A8zIsOSMoprzGLvhEslREIwxENIRFUQc0MSSNveaOU3xvlOWb5h4+7TBNFlG87g8gYBEANhEAnBEE/zXkcSSPl8IweUiAjAhIgL2nDkyOnShsstnV0f60MaGqI5GqVpBBCxfIdrH+lBEkiTIAc8vM95eOJgGrNgNTHkkvedOZ5bxZob9gp2qvGmoxKqokKqpXKaoCGao1Ga1j6ogySQbt1S7ziJlRIs9mPFFmORycvWzw/d6rv24OodJwitmnOhnNCZeeVNRdXm6qYbnJJszfzLl1yiAMUozC3cyO1UQlVUSLVUThPD9SeNJJD+fGLXFa8V66GWImImz55gCd8Y78fp4z+aEkSAMDIf+JcvuUQBilHYeiAmlVCVDcZIAhmWWyJ/5als/VLiIwkk8//apQMZAAAAgEH+1gd5WwgJhECcAoFACIRACAQCIRACIRACgUAIhEAIBAIhEAIhEAiEQAiEQCAQAiEQAkEyEVOTAEOkBQAAAABJRU5ErkJggg==",
          ouj: "data:image/x-icon;base64,AAABAAEAQEAAAAEACAAoFgAAFgAAACgAAABAAAAAgAAAAAEACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwTwoAclEOAHVWAABzUhAAdlcAAHdYAAB0UxIAdVQTAHhZAgB2VRUAe1sJAH1dDgB3XB0AeF0eAHpfIQB7YCIAfGEjAH1iJAB+YyYAf2QnAIFmKQCEah8AgmcrAIVpLgCHbSQAhmovAIhuJQCJbyYAh3EzAIhyNACJczYAi3U4AIx2OQCNdzoAjng7AI95PACQej0Aknw/AJN9QQCXgUUAlYROAJaFTwCXhlAAnItWAKCPWgChkFsAo5FcAJ2RYQCekmIAn5NjAKKWZgCkmGgAp5pyAKqdbQCrnXUArJ52AK+hegCpoX4AraWCALOqhwC0q4gAtayJALatigC3r4sAuLCMALmxjQC3tJQAuLWVALm2lgC7uJgAvbqaAL67mwC/vJwAwb6eAMbBqQDHwqoAwsOuAMXGsgDHyLQAyMm1AM7PugDP0LsA0NG8ANLTvwDT1MAAztXEANDWxQDR18YA0tnHANTbyQDV3MoA19zTANfezQDZ4M8A2t/VANvg1gDc4dcA3eLYAN7j2QDf5NoA4OXbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjYl9dXFlZWVlcXV9iY2RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY2FcVU9JQDo2NDQ2OkBJTlVcYWNkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRiXVZMPTIpIRoUDg0NDhQaISgyPUxWXWJkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGNfVEk0JxgLCAIDAQAAAAABAwIFCxgnNElTX2NkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGJZSzQkEQUDAQAAAAAAAAAAAAAAAAEDBREjNEpZYmRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY2BSPykUBQEAAAAAAAAAAAAAAAAAAAAAAAABBBMoP1JfY2RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY11NNB0MAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAADDB00TV1jZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY11MMBYEAQAAAAAAAAEDBwIJBAQJAgcDAQAAAAAAAAEEFC5MW2NkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY11MLBMHAAAAAAABAwcIERccHyIiHxwXEQgHAwEAAAAAAAcTLExdY2RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGBNMBMHAAAAAAABCQ4YJi84PURGRkQ+OC8mGA4JAQAAAAAABxMuTV9kZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGJSNBYHAAAAAAEDChgqOEVNUlhcW1tcWFJNRTkqGAoGAQAAAAAHFjRRYmRkZGRkZGRkZGRkZGRkZGRkZGRkZGNZPx0EAAAAAAECDyM0SFBcYGJiY2RkY2JiYFxRSTQjDwIBAAAAAAQdP1ljZGRkZGRkZGRkZGRkZGRkZGRkZGRfSykMAQAAAAEEFCk7TlphY2RkZGRkZGRkZGRjYVpPPCkUBAEAAAABDChKX2RkZGRkZGRkZGRkZGRkZGRkZGRiVDQUAwAAAAECFCtDUl5iZGRkZGRkZGRkZGRkZGRiXlNDKxQCAQAAAAMTNFNiZGRkZGRkZGRkZGRkZGRkZGRkXUkkBQAAAAADDypDVGBjZGRkZGRkZGRkZGRkZGRkZGNgVUMqEAYAAAAABSRJXWRkZGRkZGRkZGRkZGRkZGRkY1Y1EgMAAAABCiM8UmBjZGRkZGRkZGRkZGRkZGRkZGRkY2BTPCMKAQAAAAERNFZjZGRkZGRkZGRkZGRkZGRkZGFMJwgAAAABCRg0Tl5jZGRkZGRkZGRkZGRkZGRkZGRkZGRjXk80GAkBAAAABSdMYWRkZGRkZGRkZGRkZGRkZGRcPRgHAAAAAw4qSFpiZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGJaSCoOAwAAAAMYPVxkZGRkZGRkZGRkZGRkZGRjVTMOAQAAAAcYOFBhZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYVE5GAcAAAABCzJVY2RkZGRkZGRkZGRkZGRkYk8pCAAAAAEIJkVaYmRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGNcRSYIAQAAAAgpTmJkZGRkZGRkZGRkZGRkZGBJIgQAAAADES1NX2RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYE0vEQMAAAACIUlfZGRkZGRkZGRkZGRkZGRdQRsHAAAABhc4UmJkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGJSOBcHAAAABxpAXWRkZGRkZGRkZGRkZGRkXDoUAwAAAAccPVdiZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRiWD4cAgAAAAEUOlxkZGRkZGRkZGRkZGRkZFo2DwEAAAACH0RcY2RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY1xEIAkAAAABDjZZZGRkZGRkZGRkZGRkZGRZNA0BAAAACSJGW2NkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRbRiIJAAAAAA00WWRkZGRkZGRkZGRkZGRkWTQNAQAAAAkiRltjZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkW0YiCQAAAAANNFlkZGRkZGRkZGRkZGRkZFo3DwEAAAACH0RcY2RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY1xEIAkAAAABDzZZZGRkZGRkZGRkZGRkZGRcOhQDAAAABxw9V2JkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGJYPRwCAAAAARQ6XGRkZGRkZGRkZGRkZGRkXUEbBwAAAAYXOFJiZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRiUjgXBwAAAAcaQF1kZGRkZGRkZGRkZGRkZGBJIgQAAAADES1NX2RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYE0vEQMAAAACIklfZGRkZGRkZGRkZGRkZGRiTykIAAAAAQgmRVpiZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY1xFJggBAAAACClOYmRkZGRkZGRkZGRkZGRkY1UzDgEAAAAHGDhQYGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGFQORgHAAAAAQsyVWNkZGRkZGRkZGRkZGRkZGRcPhoHAAAAAQ4qSFpiZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGJaSCoOAwAAAAMYPVxkZGRkZGRkZGRkZGRkZGRkYUwnCAAAAAEJGTROXmNkZGRkZGRkZGRkZGRkZGRkZGRkZGNeTjQYCQEAAAAFJ0xhZGRkZGRkZGRkZGRkZGRkZGNWNRIDAAAAAQgjO1JgY2RkZGRkZGRkZGRkZGRkZGRkZGNgUzwjCgEAAAABETRWY2RkZGRkZGRkZGRkZGRkZGRkXUkkBQAAAAADDylCVGBjZGRkZGRkZGRkZGRkZGRkZGNgVEMpDwMAAAAABSRJXWRkZGRkZGRkZGRkZGRkZGRkZGJUNRQDAAAAAQIUK0NSXmJkZGRkZGRkZGRkZGRkZGJeUkMrFAIBAAAAAxM0VGJkZGRkZGRkZGRkZGRkZGRkZGRkX0spDAEAAAABBBQpO05aYWJkZGRkZGRkZGRkYmFaTjspFAQBAAAAAQwoS19kZGRkZGRkZGRkZGRkZGRkZGRkZGNZQB4EAAAAAAECDyI0R1BaYGJiY2NjY2JiYFxQSDQjDwIBAAAAAAQdP1ljZGRkZGRkZGRkZGRkZGRkZGRkZGRkYlI0FQIAAAAAAQMIGCo4RU1SV1xbW1xXUk1FOSoYCAMBAAAAAAcWNFJiZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgTTEUBwAAAAAAAQkOGSUtOD1ERkZEPTgvJhgOCQEAAAAAAAcTME1gZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY15MLxQHAAAAAAABAwcIERccHyIiHxwXEQgHAwEAAAAAAAcTLExeY2RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjXUwxFQUBAAAAAAAAAQMGBwIJCQIHBgMBAAAAAAAAAQQWMExdY2RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGNeTTQeDAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwwdNE1dY2RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY2BSQCkUBQMAAAAAAAAAAAAAAAAAAAAAAAADBRMpP1JgY2RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYllLNSQSCAcBAAAAAAAAAAAAAAAAAQcIEiQ0SlliZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjX1RJNScaDggCBwMBAQEBAwcCCA4aJzVJVF9jZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRiXVZMPjMqIhsUDwsLDxQbIikzPkxWXWJkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjYVxVT0lBOjc0NDc6QElPVVxhY2RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY2JgXVxaWVlaXF1gYmNkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
          usty: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlPjlDMzAwNDI3LTg4Q0QtNDI2RC05QkZELUFEMUU2RUI2RjRDNjwvdGl0bGU+PGRlZnM+PHBhdGggZD0iTTAgNS42MjNBNS42MjMgNS42MjMgMCAwIDEgNS42MjMgMGgxMi43NTRBNS42MjMgNS42MjMgMCAwIDEgMjQgNS42MjN2MTIuNzU0QTUuNjIzIDUuNjIzIDAgMCAxIDE4LjM3NyAyNEg1LjYyM0E1LjYyMyA1LjYyMyAwIDAgMSAwIDE4LjM3N1Y1LjYyM3oiIGlkPSJhIi8+PC9kZWZzPjxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+PG1hc2sgaWQ9ImIiIGZpbGw9IiNmZmYiPjx1c2UgeGxpbms6aHJlZj0iI2EiLz48L21hc2s+PHVzZSBmaWxsLW9wYWNpdHk9IjAiIGZpbGw9IiNGRkYiIHhsaW5rOmhyZWY9IiNhIi8+PHBhdGggZmlsbD0iIzJFQ0M3MSIgbWFzaz0idXJsKCNiKSIgZD0iTTExLjI1IDB2MTQuNjI1SDBWMHoiLz48cGF0aCBmaWxsPSIjRTc0QzNDIiBtYXNrPSJ1cmwoI2IpIiBkPSJNMjQgMHY3Ljg3NUgxMi43NVYweiIvPjxwYXRoIGZpbGw9IiNGMzlDMTIiIG1hc2s9InVybCgjYikiIGQ9Ik0xMS4yNSAxNi4xMjVWMjRIMHYtNy44NzV6Ii8+PHBhdGggZmlsbD0iIzM0OThEQiIgbWFzaz0idXJsKCNiKSIgZD0iTTI0IDkuNTYzdjE0LjYyNEgxMi43NVY5LjU2M3oiLz48L2c+PC9zdmc+",
        },
        gs = (e) => ms["gst" == e ? "gh" : e] || ms.unknown,
        vs = (e) =>
          "data:image/svg+xml," +
          encodeURI(
            {
              tampermonkey:
                "<?xml version='1.0' encoding='utf-8'?><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 400'><g id='XMLID_273_'><g id='XMLID_78_'><path id='XMLID_83_' class='st0' d='M304.8,0H95.2C42.6,0,0,42.6,0,95.2v209.6C0,357.4,42.6,400,95.2,400h209.6 c52.6,0,95.2-42.6,95.2-95.2V95.2C400,42.6,357.4,0,304.8,0z M106.3,375C61.4,375,25,338.6,25,293.8c0-44.9,36.4-81.3,81.3-81.3 c44.9,0,81.3,36.4,81.3,81.3C187.5,338.6,151.1,375,106.3,375z M293.8,375c-44.9,0-81.3-36.4-81.3-81.3 c0-44.9,36.4-81.3,81.3-81.3c44.9,0,81.3,36.4,81.3,81.3C375,338.6,338.6,375,293.8,375z'/></g><g id='XMLID_67_' class='st2'><path id='XMLID_74_' class='st3' d='M304.8,0H95.2C42.6,0,0,42.6,0,95.2v209.6C0,357.4,42.6,400,95.2,400h209.6 c52.6,0,95.2-42.6,95.2-95.2V95.2C400,42.6,357.4,0,304.8,0z M106.3,375C61.4,375,25,338.6,25,293.8c0-44.9,36.4-81.3,81.3-81.3 c44.9,0,81.3,36.4,81.3,81.3C187.5,338.6,151.1,375,106.3,375z M293.8,375c-44.9,0-81.3-36.4-81.3-81.3 c0-44.9,36.4-81.3,81.3-81.3c44.9,0,81.3,36.4,81.3,81.3C375,338.6,338.6,375,293.8,375z'/></g></g></svg>",
              monkey:
                "<?xml version='1.0' encoding='UTF-8' standalone='no'?>\n<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 59.16 69.57'>\n    <g transform='translate(-110.73,-61.49)'>\n        <path d='m 130.15,99.28 c 2.9,-1.3 4.93,-4.22 4.94,-7.6 0,-4.61 -3.74,-8.35 -8.35,-8.35 -4.61,0 -8.35,3.74 -8.35,8.35 0,4.6 3.74,8.34 8.35,8.34 0.72,0 1.41,-0.1 2.08,-0.27 0.41,-0.18 0.85,-0.33 1.32,-0.46 z m -7.55,-6.13 c 0,-2.3 1.87,-4.17 4.18,-4.17 0.58,0 1.15,0.12 1.65,0.34 -0.11,0.31 -0.18,0.65 -0.18,1.0 0,1.53 1.19,2.79 2.7,2.91 -0.04,2.26 -1.89,4.09 -4.17,4.09 -2.3,0 -4.18,-1.87 -4.18,-4.17' style='fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.03' />\n        <path d='m 146.01,83.31 c -4.61,0 -8.35,3.74 -8.35,8.35 0,3.35 1.97,6.23 4.82,7.56 0.55,0.14 1.08,0.32 1.56,0.54 0.63,0.15 1.28,0.24 1.96,0.24 4.6,0 8.34,-3.74 8.35,-8.35 0,-4.61 -3.74,-8.35 -8.35,-8.35 z m 0.04,14.01 c -2.3,0 -4.17,-1.87 -4.17,-4.17 0,-2.3 1.87,-4.17 4.17,-4.17 0.51,0 1.01,0.09 1.46,0.26 -0.13,0.33 -0.21,0.7 -0.21,1.08 0,1.61 1.3,2.92 2.92,2.92 -0.05,2.26 -1.9,4.08 -4.17,4.08' style='fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.03' />\n        <path d='m 144.48,101.56 c -0.88,-0.89 -2.66,-1.31 -4.61,-1.49 0.0,-0.06 0.02,-0.13 0.02,-0.2 0,-0.14 -0.02,-0.28 -0.05,-0.41 -0.06,-0.24 -0.18,-0.46 -0.33,-0.65 -0.31,-0.37 -0.77,-0.62 -1.3,-0.62 -0.48,0 -0.92,0.2 -1.23,0.53 -0.16,0.17 -0.28,0.38 -0.36,0.61 -0.05,0.17 -0.09,0.35 -0.09,0.54 0,0.02 0.0,0.04 0.0,0.06 -0.03,0 -0.07,-7.94e-4 -0.11,-7.94e-4 -0.05,0 -0.11,0 -0.18,0 0.0,-0.02 0.0,-0.04 0.0,-0.06 0,-0.19 -0.03,-0.37 -0.09,-0.54 -0.07,-0.23 -0.2,-0.44 -0.36,-0.61 -0.31,-0.33 -0.74,-0.53 -1.23,-0.53 -0.53,0 -1.0,0.25 -1.32,0.63 -0.15,0.19 -0.26,0.41 -0.32,0.65 -0.03,0.13 -0.05,0.26 -0.05,0.4 0,0.07 0.01,0.14 0.02,0.21 -1.76,0.17 -3.61,0.58 -4.53,1.49 -0.29,0.28 -0.48,0.62 -0.55,1.02 -0.02,0.1 -0.03,0.22 -0.03,0.33 0,3.35 3.73,5.89 8.68,5.89 4.78,0 8.68,-2.64 8.68,-5.89 0,-0.11 -0.02,-0.22 -0.03,-0.33 -0.06,-0.39 -0.25,-0.73 -0.53,-1.02 z m -7.01,-1.7 c 0,-0.21 0.09,-0.4 0.24,-0.53 0.12,-0.11 0.28,-0.18 0.47,-0.18 0.2,0 0.38,0.08 0.51,0.22 0.12,0.12 0.2,0.3 0.2,0.49 0,0.04 -0.01,0.08 -0.02,0.13 -0.06,0.33 -0.34,0.58 -0.69,0.58 -0.36,0 -0.66,-0.28 -0.7,-0.64 -0.0,-0.02 -0.01,-0.05 -0.01,-0.07 z m -3.68,0 c 0,-0.19 0.07,-0.36 0.19,-0.49 0.13,-0.13 0.31,-0.22 0.52,-0.22 0.18,0 0.34,0.07 0.47,0.18 0.14,0.13 0.24,0.31 0.24,0.53 0,0.02 -0.01,0.04 -0.01,0.07 -0.03,0.35 -0.33,0.64 -0.7,0.64 -0.35,0 -0.63,-0.25 -0.69,-0.58 -0.0,-0.04 -0.02,-0.08 -0.02,-0.13 z m -0.16,6.82 c -0.93,0 -1.7,-0.76 -1.7,-1.7 h 0.49 0.49 c 0,0.39 0.32,0.72 0.72,0.72 0.39,0 0.72,-0.32 0.72,-0.72 h 0.49 0.49 c 0,0.93 -0.76,1.7 -1.7,1.7' style='fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.03' />\n        <path d='m 115.82,89.87 c -1.14,-0.47 -2.52,-0.26 -3.29,0.5 -0.36,0.36 -0.7,0.99 -0.3,1.93 0.45,1.07 1.22,2.33 2.01,3.29 0.99,1.2 1.64,1.49 1.87,1.47 0.13,-0.01 0.27,-0.27 0.37,-0.67 l 0.02,0.0 c -0.44,-1.11 -0.69,-2.32 -0.69,-3.6 v -2.93' style='fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.03' />\n        <path d='m 160.15,90.37 c -0.75,-0.75 -2.09,-0.96 -3.23,-0.52 v 2.95 c 0,1.29 -0.25,2.52 -0.71,3.65 0.09,0.36 0.22,0.6 0.35,0.61 0.23,0.01 0.88,-0.27 1.87,-1.47 0.78,-0.95 1.56,-2.21 2.01,-3.29 0.39,-0.94 0.05,-1.57 -0.3,-1.93' style='fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.03' />\n        <path d='m 130.96,93.23 c -1.51,-0.11 -2.7,-1.37 -2.7,-2.91 0,-0.35 0.06,-0.69 0.18,-1.0 -0.5,-0.22 -1.06,-0.34 -1.65,-0.34 -2.3,0 -4.18,1.87 -4.18,4.17 0,2.3 1.87,4.17 4.18,4.17 2.28,0 4.13,-1.82 4.17,-4.09' style='fill:#282a2b;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.03' />\n        <path d='m 146.05,97.32 c 2.27,0 4.12,-1.81 4.17,-4.08 -1.61,-0.0 -2.92,-1.31 -2.92,-2.92 0,-0.38 0.07,-0.75 0.21,-1.08 -0.45,-0.17 -0.95,-0.26 -1.46,-0.26 -2.3,0 -4.17,1.87 -4.17,4.17 0,2.3 1.87,4.17 4.17,4.17' style='fill:#282a2b;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.03' />\n        <path d='m 146.29,102.92 c 0,-0.11 -0.0,-0.22 -0.01,-0.33 h 0.86 c 3.46,0 6.5,-1.81 8.23,-4.53 0.03,-0.05 0.07,-0.1 0.1,-0.16 0.3,0.33 0.66,0.46 0.96,0.48 0.04,0.0 0.08,0.0 0.13,0.0 0.83,0 1.79,-0.65 2.86,-1.95 0.86,-1.04 1.71,-2.43 2.21,-3.61 0.52,-1.24 0.31,-2.46 -0.58,-3.37 -1.01,-1.01 -2.65,-1.38 -4.15,-0.97 V 86.44 71.27 c 1e-5,-5.4 -4.37,-9.78 -9.78,-9.78 h -21.53 c -5.4,0 -9.78,4.37 -9.78,9.78 v 15.21 2.0 c -1.52,-0.42 -3.19,-0.07 -4.21,0.95 -0.89,0.9 -1.11,2.12 -0.58,3.37 0.5,1.18 1.34,2.56 2.21,3.61 1.07,1.29 2.03,1.95 2.86,1.95 0.04,0 0.08,-0.0 0.13,-0.0 0.31,-0.02 0.68,-0.15 1.0,-0.52 0.03,0.05 0.06,0.1 0.1,0.15 1.73,2.74 4.77,4.58 8.26,4.58 h 0.86 c -0.01,0.11 -0.01,0.22 -0.01,0.33 0,4.06 4.26,7.12 9.92,7.12 5.46,0 9.91,-3.19 9.91,-7.12 z m 13.86,-12.55 c 0.36,0.36 0.7,0.99 0.3,1.93 -0.45,1.07 -1.22,2.33 -2.01,3.29 -0.99,1.2 -1.64,1.49 -1.87,1.47 -0.12,-0.01 -0.26,-0.25 -0.35,-0.61 0.45,-1.12 0.71,-2.35 0.71,-3.65 v -2.95 c 1.13,-0.43 2.47,-0.22 3.23,0.52 z m -14.14,-7.05 c 4.61,0 8.35,3.74 8.35,8.35 -0.01,4.61 -3.75,8.35 -8.35,8.35 -0.67,0 -1.33,-0.08 -1.96,-0.24 -0.47,-0.22 -1.0,-0.4 -1.56,-0.54 -2.84,-1.33 -4.82,-4.21 -4.82,-7.56 0,-4.61 3.74,-8.35 8.35,-8.35 z m -29.52,13.09 c -0.09,0.39 -0.23,0.65 -0.37,0.67 -0.23,0.01 -0.88,-0.27 -1.87,-1.47 -0.78,-0.95 -1.56,-2.21 -2.01,-3.29 -0.39,-0.94 -0.05,-1.57 0.3,-1.93 0.76,-0.76 2.14,-0.97 3.29,-0.5 v 2.93 c 0,1.27 0.25,2.48 0.69,3.6 z m 1.9,-4.72 c 0,-4.61 3.74,-8.35 8.35,-8.35 4.61,0 8.35,3.74 8.35,8.35 -0.0,3.38 -2.03,6.3 -4.94,7.6 -0.46,0.12 -0.91,0.27 -1.32,0.46 -0.66,0.17 -1.36,0.27 -2.08,0.27 -4.61,0 -8.35,-3.74 -8.35,-8.34 z m 9.29,11.24 c 0,-0.11 0.01,-0.22 0.03,-0.33 0.07,-0.39 0.26,-0.73 0.55,-1.02 0.91,-0.9 2.76,-1.31 4.53,-1.49 -0.0,-0.06 -0.02,-0.13 -0.02,-0.21 0,-0.14 0.02,-0.27 0.05,-0.4 0.06,-0.24 0.17,-0.46 0.32,-0.65 0.31,-0.38 0.78,-0.63 1.32,-0.63 0.48,0 0.92,0.2 1.23,0.53 0.16,0.17 0.28,0.38 0.36,0.61 0.05,0.17 0.09,0.35 0.09,0.54 0,0.02 -0.0,0.04 -0.0,0.06 0.06,0 0.12,0 0.18,0 0.03,0 0.07,7.94e-4 0.11,7.94e-4 -0.0,-0.02 -0.0,-0.04 -0.0,-0.06 0,-0.19 0.03,-0.37 0.09,-0.54 0.07,-0.23 0.2,-0.44 0.36,-0.61 0.31,-0.32 0.74,-0.53 1.23,-0.53 0.52,0 0.99,0.24 1.3,0.62 0.15,0.19 0.27,0.41 0.33,0.65 0.03,0.13 0.05,0.27 0.05,0.41 0,0.07 -0.01,0.13 -0.02,0.2 1.94,0.18 3.73,0.59 4.61,1.49 0.28,0.28 0.46,0.62 0.53,1.02 0.01,0.11 0.03,0.21 0.03,0.33 0,3.24 -3.89,5.89 -8.68,5.89 -4.95,0 -8.68,-2.53 -8.68,-5.89' style='fill:#282a2b;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.03' />\n        <path d='m 134.49,100.58 c 0.37,0 0.66,-0.28 0.7,-0.64 0.0,-0.02 0.01,-0.04 0.01,-0.07 0,-0.21 -0.09,-0.4 -0.24,-0.53 -0.12,-0.11 -0.29,-0.18 -0.47,-0.18 -0.2,0 -0.38,0.08 -0.52,0.22 -0.12,0.12 -0.19,0.3 -0.19,0.49 0,0.04 0.01,0.08 0.02,0.13 0.06,0.33 0.34,0.58 0.69,0.58' style='fill:#282a2b;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.03' />\n        <path d='m 138.18,100.58 c 0.35,0 0.62,-0.25 0.69,-0.58 0.0,-0.04 0.02,-0.08 0.02,-0.13 0,-0.19 -0.07,-0.36 -0.2,-0.49 -0.13,-0.13 -0.31,-0.22 -0.51,-0.22 -0.18,0 -0.34,0.07 -0.47,0.18 -0.15,0.13 -0.24,0.31 -0.24,0.53 0,0.02 0.01,0.05 0.01,0.07 0.04,0.35 0.33,0.64 0.7,0.64' style='fill:#282a2b;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.03' />\n        <path d='m 134.33,104.97 c -3.4e-4,0.39 -0.32,0.72 -0.72,0.72 -0.39,0 -0.72,-0.32 -0.72,-0.72 h -0.49 -0.49 c 0,0.93 0.76,1.7 1.7,1.7 0.93,0 1.7,-0.76 1.7,-1.7 h -0.49 -0.49' style='fill:#282a2b;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.03' />\n        <path d='m 165.85,106.2 -0.22,-0.22 c -4.1,-4.1 -10.78,-4.1 -14.88,0 -1.78,1.78 -2.77,4.16 -2.77,6.68 0,2.52 0.98,4.9 2.77,6.68 l 0.08,0.08 c 1.66,1.66 3.85,2.5 6.04,2.5 2.19,-2.7e-4 4.37,-0.83 6.04,-2.5 2.45,-2.45 2.45,-6.44 0,-8.9 -0.57,-0.57 -1.5,-0.57 -2.08,0 -0.57,0.57 -0.57,1.5 0,2.08 1.3,1.3 1.3,3.42 0,4.73 -2.18,2.18 -5.73,2.18 -7.92,0 l -0.08,-0.08 c -1.22,-1.22 -1.9,-2.86 -1.9,-4.6 0,-1.73 0.67,-3.37 1.9,-4.6 2.95,-2.95 7.76,-2.95 10.71,0 l 0.22,0.22 c 4.23,4.23 4.23,11.13 0,15.37 -2.87,2.86 -6.68,4.45 -10.74,4.45 h -4.03 c 0.06,-0.28 0.11,-0.59 0.11,-0.94 0,-4.96 -7.31,-7.35 -7.23,-10.18 0.19,-6.94 -9.38,-7.21 -9.58,-0.27 -0.19,6.97 -1.11,14.35 6.29,14.35 0.64,0 1.26,-0.0 1.86,-0.0 0.03,0.0 0.07,0.01 0.11,0.01 h 12.46 c 4.84,0 9.4,-1.88 12.82,-5.31 5.38,-5.38 5.38,-14.15 0,-19.54' style='fill:#282a2b;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.03' />\n    </g>\n</svg>",
              webdav:
                "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 640 512'><path d='M537.585 226.56C541.725 215.836 544 204.184 544 192c0-53.019-42.981-96-96-96-19.729 0-38.065 5.954-53.316 16.159C367.042 64.248 315.288 32 256 32c-88.366 0-160 71.634-160 160 0 2.728.07 5.439.204 8.133C40.171 219.845 0 273.227 0 336c0 79.529 64.471 144 144 144h368c70.692 0 128-57.308 128-128 0-61.93-43.983-113.586-102.415-125.44z'/></svg>",
              yandex:
                "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 512'><path d='M153.1 315.8L65.7 512H2l96-209.8c-45.1-22.9-75.2-64.4-75.2-141.1C22.7 53.7 90.8 0 171.7 0H254v512h-55.1V315.8h-45.8zm45.8-269.3h-29.4c-44.4 0-87.4 29.4-87.4 114.6 0 82.3 39.4 108.8 87.4 108.8h29.4V46.5z'/></svg>",
              firefox:
                "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 496 512'><path d='M496 262.5C497.6 380.8 388.9 504 248 504c-106.7 0-190.9-62.5-229.8-151.7-43-97.7-5.7-251.6 70.3-320.3l-2.7 69.7c3.9-5 32.5-6.4 37.1 0C139 71 190.7 48 232.1 47.2c-15.8 13.3-52.2 61.6-49.2 86.2 20.2 6.4 51.1 6.6 67.4 7.7 5 2.8 4.1 19.6-5.8 33.4 0 0-13 18-48.1 24.3l2.7 41.1-37-7.4c-12.4 31.5 17.4 59.4 48.4 54.2 34.3-5.8 45.9-32 70-30.6 23.8 1.4 33.2 14.6 30.1 27.1 0 0-3.9 14.9-29.6 12.4-21.8 34.5-50.4 53.5-97.3 49.4 71.3 59.1 168.3 5.5 192.6-42.8 24.3-48.1 8-122.1-16.3-142.3 28.7 12.4 43.7 27.6 54.2 55.5 5.5-61.9-22.9-132.1-73.8-173.3C436 70.1 494.3 144.2 496 262.5z'/></svg>",
              chrome:
                "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 496 512'><path d='M131.5 217.5L55.1 100.1c47.6-59.2 119-91.8 192-92.1 42.3-.3 85.5 10.5 124.8 33.2 43.4 25.2 76.4 61.4 97.4 103L264 133.4c-58.1-3.4-113.4 29.3-132.5 84.1zm32.9 38.5c0 46.2 37.4 83.6 83.6 83.6s83.6-37.4 83.6-83.6-37.4-83.6-83.6-83.6-83.6 37.3-83.6 83.6zm314.9-89.2L339.6 174c37.9 44.3 38.5 108.2 6.6 157.2L234.1 503.6c46.5 2.5 94.4-7.7 137.8-32.9 107.4-62 150.9-192 107.4-303.9zM133.7 303.6L40.4 120.1C14.9 159.1 0 205.9 0 256c0 124 90.8 226.7 209.5 244.9l63.7-124.8c-57.6 10.8-113.2-20.8-139.5-72.5z'/></svg>",
              onedrive:
                "<svg xmlns='http://www.w3.org/2000/svg' id='Layer_1' data-name='Layer 1' viewBox='0 0 24 24'><title>Artboard 1</title><g id='Templates'><path d='M17,10.57a3,3,0,0,1,1.18.23,3.11,3.11,0,0,1,1,.64,2.82,2.82,0,0,1,.65,1,3,3,0,0,1-1.6,3.95,3.08,3.08,0,0,1-1.16.23H8a4,4,0,0,1-1.56-.31,4,4,0,0,1,0-7.38A4,4,0,0,1,8,8.57a3.54,3.54,0,0,1,.73.07,4.63,4.63,0,0,1,.72-.87,4.72,4.72,0,0,1,.89-.65,4.58,4.58,0,0,1,1-.41,4.79,4.79,0,0,1,1.13-.14,4.37,4.37,0,0,1,1.64.3,4.55,4.55,0,0,1,1.36.84,4.39,4.39,0,0,1,1,1.27A4.66,4.66,0,0,1,17,10.57Z'/></g></svg>",
              gdrive:
                "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><path d='M339 314.9L175.4 32h161.2l163.6 282.9H339zm-137.5 23.6L120.9 480h310.5L512 338.5H201.5zM154.1 67.4L0 338.5 80.6 480 237 208.8 154.1 67.4z'/></svg>",
              dropbox:
                "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><path d='M256 87.2l-151.9 93.9L0 97.5 150.6 0 256 87.2zM0 265.3l150.6 98.3 105.4-88L104.1 181 0 265.3zm256 10.3l105.4 88L512 265.3l-104.1-84.2L256 275.6zM512 97.5L361.4 0 256 87.2l151.9 93.9L512 97.5zM256.3 294.6l-105.7 87.7-45.2-29.5V385l150.9 90.5L407.2 385v-32.2L362 382.3l-105.7-87.7z'/></svg>",
              instagram:
                "<svg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' viewBox='5 4 44 44' style='enable-background:new 5 4 44 44;' xml:space='preserve'><style type='text/css'>.st0{fill:none;}</style><g><rect x='-0.2' y='0.1' class='st0' width='53.8' height='53.4'/><path d='M48.1,26.3c0,4.3,0,7.2-0.1,8.8c-0.2,3.9-1.3,6.9-3.5,9s-5.1,3.3-9,3.5c-1.6,0.1-4.6,0.1-8.8,0.1c-4.3,0-7.2,0-8.8-0.1 c-3.9-0.2-6.9-1.3-9-3.5c-2.1-2.1-3.3-5.1-3.5-9c-0.1-1.6-0.1-4.6-0.1-8.8s0-7.2,0.1-8.8c0.2-3.9,1.3-6.9,3.5-9 c2.1-2.1,5.1-3.3,9-3.5c1.6-0.1,4.6-0.1,8.8-0.1c4.3,0,7.2,0,8.8,0.1c3.9,0.2,6.9,1.3,9,3.5s3.3,5.1,3.5,9 C48,19.1,48.1,22,48.1,26.3z M28.8,8.7c-1.3,0-2,0-2.1,0c-0.1,0-0.8,0-2.1,0c-1.3,0-2.3,0-2.9,0c-0.7,0-1.6,0-2.7,0.1 c-1.1,0-2.1,0.1-2.9,0.3c-0.8,0.1-1.5,0.3-2,0.5c-0.9,0.4-1.7,0.9-2.5,1.6c-0.7,0.7-1.2,1.5-1.6,2.5c-0.2,0.5-0.4,1.2-0.5,2 s-0.2,1.7-0.3,2.9c0,1.1-0.1,2-0.1,2.7c0,0.7,0,1.7,0,2.9c0,1.3,0,2,0,2.1s0,0.8,0,2.1c0,1.3,0,2.3,0,2.9c0,0.7,0,1.6,0.1,2.7 c0,1.1,0.1,2.1,0.3,2.9s0.3,1.5,0.5,2c0.4,0.9,0.9,1.7,1.6,2.5c0.7,0.7,1.5,1.2,2.5,1.6c0.5,0.2,1.2,0.4,2,0.5 c0.8,0.1,1.7,0.2,2.9,0.3s2,0.1,2.7,0.1c0.7,0,1.7,0,2.9,0c1.3,0,2,0,2.1,0c0.1,0,0.8,0,2.1,0c1.3,0,2.3,0,2.9,0 c0.7,0,1.6,0,2.7-0.1c1.1,0,2.1-0.1,2.9-0.3c0.8-0.1,1.5-0.3,2-0.5c0.9-0.4,1.7-0.9,2.5-1.6c0.7-0.7,1.2-1.5,1.6-2.5 c0.2-0.5,0.4-1.2,0.5-2c0.1-0.8,0.2-1.7,0.3-2.9c0-1.1,0.1-2,0.1-2.7c0-0.7,0-1.7,0-2.9c0-1.3,0-2,0-2.1s0-0.8,0-2.1 c0-1.3,0-2.3,0-2.9c0-0.7,0-1.6-0.1-2.7c0-1.1-0.1-2.1-0.3-2.9c-0.1-0.8-0.3-1.5-0.5-2c-0.4-0.9-0.9-1.7-1.6-2.5 c-0.7-0.7-1.5-1.2-2.5-1.6c-0.5-0.2-1.2-0.4-2-0.5c-0.8-0.1-1.7-0.2-2.9-0.3c-1.1,0-2-0.1-2.7-0.1C31.1,8.7,30.1,8.7,28.8,8.7z  M34.4,18.5c2.1,2.1,3.2,4.7,3.2,7.8s-1.1,5.6-3.2,7.8c-2.1,2.1-4.7,3.2-7.8,3.2c-3.1,0-5.6-1.1-7.8-3.2c-2.1-2.1-3.2-4.7-3.2-7.8 s1.1-5.6,3.2-7.8c2.1-2.1,4.7-3.2,7.8-3.2C29.7,15.3,32.3,16.3,34.4,18.5z M31.7,31.3c1.4-1.4,2.1-3.1,2.1-5s-0.7-3.7-2.1-5.1 c-1.4-1.4-3.1-2.1-5.1-2.1c-2,0-3.7,0.7-5.1,2.1s-2.1,3.1-2.1,5.1s0.7,3.7,2.1,5c1.4,1.4,3.1,2.1,5.1,2.1 C28.6,33.4,30.3,32.7,31.7,31.3z M39.9,13c0.5,0.5,0.8,1.1,0.8,1.8c0,0.7-0.3,1.3-0.8,1.8c-0.5,0.5-1.1,0.8-1.8,0.8 s-1.3-0.3-1.8-0.8c-0.5-0.5-0.8-1.1-0.8-1.8c0-0.7,0.3-1.3,0.8-1.8c0.5-0.5,1.1-0.8,1.8-0.8S39.4,12.5,39.9,13z'/></g></svg>",
              facebook:
                "<svg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' viewBox='0 0 30 30' style='enable-background:new 0 0 30 30;' xml:space='preserve'><style type='text/css'>.f{}.c{fill:none;}</style><g><circle class='c' cx='15' cy='15' r='13' stroke='black' stroke-width='3'/><path class='f' d='M16.4,23.9v-8.1h2.7l0.4-3.2h-3.1v-2c0-0.9,0.3-1.5,1.6-1.5l1.7,0V6.2c-0.3,0-1.3-0.1-2.4-0.1c-2.4,0-4.1,1.5-4.1,4.2v2.3h-2.7v3.2h2.7v8.1H16.4z'/></g></svg>",
            }[e]
          ).replace(/#|%20|%0A/g, (e) => ("#" == e ? "%23" : " ")),
        { SHARED_OBJECT_URLS: _s, SHARED_BLOBS: ws } = Te,
        bs = (e) => void 0 !== e.objUrl,
        ys = (e) => void 0 !== e.blob,
        ks = (e) => void 0 !== e.dataUri;
      class Rs {
        constructor(e) {
          if (bs(e)) (this.objUrl = e.objUrl.url), (this.type = e.objUrl.type);
          else if (ys(e)) this.blob = e.blob;
          else {
            if (!ks(e)) throw new Error("incompatible TransferableData");
            this.dataUri = e.dataUri;
          }
        }
        dispose() {
          this.objUrl && URL.revokeObjectURL(this.objUrl);
        }
        async toTransferableData() {
          if (_s) {
            if (
              !this.objUrl &&
              (!this.blob && this.dataUri && (this.blob = _e(this.dataUri)),
              this.blob && (this.objUrl = URL.createObjectURL(this.blob)),
              !this.objUrl)
            )
              throw new Error("incomplete Transferable");
            return { objUrl: { url: this.objUrl, type: this.type } };
          }
          if (ws) {
            if (
              !this.blob &&
              (this.objUrl
                ? (this.blob = await J(this.objUrl).then((e) => e.blob()))
                : this.dataUri && (this.blob = _e(this.dataUri)),
              !this.blob)
            )
              throw new Error("incomplete Transferable");
            return { blob: this.blob };
          }
          throw new Error("incompatible Transferable");
        }
        get tryObjectUrl() {
          return this.objUrl;
        }
        get tryBlob() {
          return this.blob;
        }
        get tryDataUri() {
          return this.dataUri;
        }
        async toBlob() {
          if (this.blob) return this.blob;
          if (!this.objUrl) {
            if (this.dataUri) return _e(this.dataUri);
            throw new Error("incompatible Transferable");
          }
          try {
            return await (await J(this.objUrl)).blob();
          } catch (e) {
            return;
          }
        }
        async toDataUri() {
          if (this.dataUri) return this.dataUri;
          {
            const e = await this.toBlob();
            if (!e) throw new Error("incompatible Transferable");
            return await we(e);
          }
        }
        static fromTransferableData(e) {
          return e && (ys(e) || bs(e) || ks(e)) ? new Rs(e) : void 0;
        }
      }
      const xs = G({
          timeout: 10800,
          check_interval: 300,
          retimeout_on_get: !0,
        }),
        Es = I({ threads: 5 }),
        Ss = {},
        Cs = async (e) => {
          let t, n;
          const r = Ss[e];
          if (r) return await r;
          const s = Es.add(
            async () => (
              (n = xs.get(e)),
              n && (t = await n.toBlob()),
              t || (t = await Ms(e)),
              t && (n || ((n = new Rs({ blob: t })), xs.set(e, n))),
              delete Ss[e],
              n
            )
          );
          return (Ss[e] = s), await s;
        },
        Ms = async (e) =>
          /^data:image\/svg|^chrome:|\.svgz?([#?].*)?$/.test(e)
            ? await (async (e) =>
                new f((t) => {
                  if (ne) {
                    const n = "image/png",
                      r = new ne();
                    (r.crossOrigin = "anonymous"),
                      (r.src = e),
                      (r.onload = () => {
                        const e = (() => {
                          if (oe) return oe.createElement("canvas");
                        })();
                        if (!e) return void t(void 0);
                        const s = e.getContext("2d");
                        s
                          ? ((e.width = r.naturalWidth),
                            (e.height = r.naturalHeight),
                            s.drawImage(r, 0, 0),
                            e.toBlob(
                              (e) => {
                                t(e || void 0);
                              },
                              n,
                              0.75
                            ))
                          : t(void 0);
                      }),
                      (r.onerror = () => t(void 0));
                  } else t(void 0);
                }))(e)
            : await (async (e) => {
                try {
                  const t = await J(e);
                  if (t.ok && 200 === t.status) return await t.blob();
                } catch (e) {}
              })(e);
      class Is {
        constructor(e = 1) {
          if (((this.waiting = []), e < 0))
            throw new Error("Count must not be negative");
          this._count = e;
        }
        acquire() {
          if (this._count > 0) return this._count--, R.Pledge();
          {
            const e = R();
            return this.waiting.push(e.resolve), e.promise();
          }
        }
        release() {
          if (this.waiting.length > 0) {
            const e = this.waiting.shift();
            e && e(void 0);
          } else this._count++;
        }
        get count() {
          return this._count;
        }
      }
      const Gs = [
          {
            type: "storage.session",
            storage: class {
              constructor(e, t) {
                this.prefix = `${e}.${t}.`;
              }
              supported() {
                return R.Pledge(!!ut.session.supported);
              }
              list() {
                return R(async ({ resolve: e }) => {
                  const t = await ut.session.get(null),
                    n = Object.entries(t)
                      .filter(([e, t]) => e.startsWith(this.prefix))
                      .map(([e, t]) => ({
                        key: e.substr(this.prefix.length),
                        value: t,
                      }));
                  e(n);
                }).promise();
              }
              set(e, t) {
                return R(async ({ resolve: n }) => {
                  await ut.session.set({ [`${this.prefix}${e}`]: t }), n();
                }).promise();
              }
              get(e) {
                return R(async ({ resolve: t }) => {
                  const n = `${this.prefix}${e}`;
                  t((await ut.session.get(n))[n] || null);
                }).promise();
              }
              delete(e) {
                return R(async ({ resolve: t }) => {
                  await ut.session.remove(`${this.prefix}${e}`), t();
                }).promise();
              }
              clear() {
                return R(async ({ resolve: e }) => {
                  const t = await this.list().then((e) =>
                    e.map((e) => `${this.prefix}${e.key}`)
                  );
                  await ut.session.remove(t), e();
                }).promise();
              }
            },
          },
          {
            type: "indexedDB",
            storage: class {
              constructor(e, t) {
                (this.db = null), (this.dbName = e), (this.storeName = t);
              }
              open() {
                const e = R();
                if (this.db) return e.resolve(this.db), e.promise();
                const t = indexedDB.open(this.dbName, 1);
                return (
                  (t.onerror = () => {
                    e.reject(new Error("Error opening database."));
                  }),
                  (t.onupgradeneeded = (e) => {
                    const t = e.target.result;
                    t.objectStoreNames.contains(this.storeName) ||
                      t.createObjectStore(this.storeName);
                  }),
                  (t.onsuccess = (t) => {
                    (this.db = t.target.result), e.resolve(this.db);
                  }),
                  e.promise()
                );
              }
              supported() {
                return R(async ({ resolve: e }) => {
                  "undefined" != typeof indexedDB
                    ? this.open()
                        .done(() => e(!0))
                        .fail(() => e(!1))
                    : e(!1);
                }).promise();
              }
              list() {
                return this.open().then((e) => {
                  const t = R(),
                    n = e
                      .transaction(this.storeName, "readonly")
                      .objectStore(this.storeName)
                      .openCursor(),
                    r = [];
                  return (
                    (n.onerror = () => {
                      t.reject(new Error("Error listing values."));
                    }),
                    (n.onsuccess = (e) => {
                      const n = e.target.result;
                      n
                        ? (r.push({ key: n.key, value: n.value }), n.continue())
                        : t.resolve(r);
                    }),
                    t.promise()
                  );
                });
              }
              set(e, t) {
                return this.open().then((n) => {
                  const r = R(),
                    s = n
                      .transaction(this.storeName, "readwrite")
                      .objectStore(this.storeName)
                      .put(t, e);
                  return (
                    (s.onerror = () => {
                      r.reject(new Error("Error setting value."));
                    }),
                    (s.onsuccess = () => {
                      r.resolve();
                    }),
                    r.promise()
                  );
                });
              }
              get(e) {
                return this.open().then((t) => {
                  const n = R(),
                    r = t
                      .transaction(this.storeName, "readonly")
                      .objectStore(this.storeName)
                      .get(e);
                  return (
                    (r.onerror = () => {
                      n.reject(new Error("Error getting value."));
                    }),
                    (r.onsuccess = () => {
                      n.resolve(r.result);
                    }),
                    n.promise()
                  );
                });
              }
              delete(e) {
                return this.open().then((t) => {
                  const n = R(),
                    r = t
                      .transaction(this.storeName, "readwrite")
                      .objectStore(this.storeName)
                      .delete(e);
                  return (
                    (r.onerror = () => {
                      n.reject(new Error("Error deleting value."));
                    }),
                    (r.onsuccess = () => {
                      n.resolve();
                    }),
                    n.promise()
                  );
                });
              }
              clear() {
                return this.open().then((e) => {
                  const t = R(),
                    n = e
                      .transaction(this.storeName, "readwrite")
                      .objectStore(this.storeName)
                      .clear();
                  return (
                    (n.onerror = () => {
                      t.reject(new Error("Error clearing the store."));
                    }),
                    (n.onsuccess = () => {
                      t.resolve();
                    }),
                    t.promise()
                  );
                });
              }
            },
          },
          {
            type: "storage.local",
            storage: class {
              constructor(e, t) {
                this.prefix = `${Ze.PREFIX.STATE_DB}${e}.${t}.`;
              }
              supported() {
                return R.Pledge(!!ut.local);
              }
              list() {
                return R(async ({ resolve: e }) => {
                  ut.local.get(null, (t) => {
                    const n = Object.entries(t)
                      .filter(([e, t]) => e.startsWith(this.prefix))
                      .map(([e, t]) => ({
                        key: e.substr(this.prefix.length),
                        value: t,
                      }));
                    e(n);
                  });
                }).promise();
              }
              set(e, t) {
                return R(async ({ resolve: n }) => {
                  ut.local.set({ [`${this.prefix}${e}`]: t }, () => n());
                }).promise();
              }
              get(e) {
                return R(async ({ resolve: t }) => {
                  const n = `${this.prefix}${e}`;
                  ut.local.get(n, (e) => {
                    t(e[n] || null);
                  });
                }).promise();
              }
              delete(e) {
                return R(async ({ resolve: t }) => {
                  ut.local.remove(`${this.prefix}${e}`, () => t());
                }).promise();
              }
              clear() {
                return R(async ({ resolve: e }) => {
                  this.list().then((t) => {
                    const n = t.map((e) => `${this.prefix}${e.key}`);
                    ut.local.remove(n, () => e());
                  });
                }).promise();
              }
            },
          },
          {
            type: "memory",
            storage: class {
              constructor(e, t) {
                (this.storage = {}),
                  (this.prefix = `${Ze.PREFIX.STATE_DB}${e}.${t}.`);
              }
              supported() {
                return (
                  console.warn("InMemoryStorage is not persistent!"),
                  R.Pledge(!0)
                );
              }
              list() {
                return R(({ resolve: e }) => {
                  const t = Object.keys(this.storage)
                    .filter((e) => e.startsWith(this.prefix))
                    .map((e) => ({
                      key: e.substr(this.prefix.length),
                      value: this.storage[e],
                    }));
                  e(t);
                }).promise();
              }
              set(e, t) {
                return R(({ resolve: n }) => {
                  (this.storage[`${this.prefix}${e}`] = t), n();
                }).promise();
              }
              get(e) {
                return R(({ resolve: t }) => {
                  const n = `${this.prefix}${e}`;
                  n in this.storage ? t(this.storage[n]) : t(null);
                }).promise();
              }
              delete(e) {
                return R(({ resolve: t }) => {
                  delete this.storage[`${this.prefix}${e}`], t();
                }).promise();
              }
              clear() {
                return R(({ resolve: e }) => {
                  (this.storage = {}), e();
                }).promise();
              }
            },
          },
        ],
        Us = {};
      class Zs {
        constructor(e) {
          this.dbName = e;
        }
        init() {
          if (!this.storage_promise) {
            let e = 0;
            this.storage_promise = R(({ resolve: t }) => {
              const n = () => {
                if (e >= Gs.length)
                  throw new Error("No supported storage found.");
                const { type: r, storage: s } = Gs[e++],
                  i = new s(this.dbName, "stateStorage");
                i.supported().then((e) => {
                  if (!e) return n();
                  (this.storage_type = r), t(i);
                });
              };
              n();
            }).promise();
          }
          return this.storage_promise;
        }
        list() {
          return this.init().then((e) => e.list());
        }
        set(e, t) {
          return this.init().then((n) => n.set(e, t));
        }
        get(e) {
          return this.init().then((t) => t.get(e));
        }
        delete(e) {
          return this.init().then((t) => t.delete(e));
        }
        clear() {
          return this.init().then((e) => e.clear());
        }
        type() {
          return this.init().then(() => {
            if (!this.storage_type) throw new Error("internal error");
            return this.storage_type;
          });
        }
      }
      const Ts = (e) => {
          let t = Us[e];
          return t || (t = Us[e] = new Zs(e)), t;
        },
        Bs = {},
        Os = [],
        Fs = Ts("notify"),
        Ds = new Is(1);
      Ds.acquire()
        .then(async () => {
          for (const { key: e, value: t } of await Fs.list())
            Bs[e] = { cbs: [], o: t };
        })
        .always(() => Ds.release());
      const js = async (e) => {
          Bs[e] && (delete Bs[e], await Fs.delete(e));
        },
        Ps = async (e, t) => {
          w.log("notify: click", e);
          const n = Bs[e];
          if (n) {
            X(() => js(e), 1e3);
            const r = { ...n.o, id: e };
            await f.all(
              n.cbs.map(async (e) => {
                await e({ clicked: t, notification: r });
              })
            );
            for (const e of Os) await e({ clicked: t, notification: r });
          } else w.log("notify: click, notification not found", e);
        },
        Ls = async (e) => {
          w.log("notify: close", e);
          const t = Bs[e];
          if (t) {
            const n = { ...t.o, id: e };
            await js(e), t.cbs.forEach((e) => e({ notification: n }));
            for (const e of Os) e({ notification: n });
          } else w.log("notify: close, notification not found", e);
        },
        Ns = (() => {
          let e,
            t = null;
          return {
            cancel: (e) =>
              new f((t) => {
                !(function (e, t) {
                  Se.notifications.clear(e, t);
                })(e, () => {
                  qe.lastError ? t(!1) : t(!0);
                });
              }),
            create: (n, r, s, i, o) =>
              (() => {
                if (e) return e;
                const n = R(),
                  r = (e) => {
                    (t = e || "unknown"),
                      w.log("notify: chronos level", e),
                      n.resolve();
                  };
                return (
                  _t
                    ? ((s = r),
                      Se.notifications.getPermissionLevel(s),
                      mt(r),
                      gt((e) => Ps(e, !0)),
                      vt((e) => Ls(e)))
                    : r("unsupported"),
                  (e = n.promise())
                );
                var s;
              })().then(async () => {
                const e = R();
                let a = 10;
                const l = async () => {
                  if (t)
                    if ("granted" == t) {
                      const { silent: t } = o,
                        a = { type: "basic", title: s || "", message: i || "" },
                        l = () =>
                          new f((e) => {
                            var t, r, s;
                            (t = n),
                              (r = a),
                              (s = () => {
                                qe.lastError
                                  ? e(!1)
                                  : (w.log("notify: chronos created", n),
                                    e(!0));
                              }),
                              Se.notifications.create(t, r, s);
                          });
                      Ge() >= 70 && void 0 !== t && (a.silent = t),
                        Ge() >= 50 && (a.requireInteraction = !0);
                      const c = Bs[n];
                      c &&
                        (w.log(
                          "notify: chronos notification already exists",
                          n
                        ),
                        await f.all([Ns.cancel(n), js(n)])),
                        (a.iconUrl = r);
                      let u = await l();
                      if (
                        (u ||
                          (w.log(
                            "notify: chronos creating failed, retry...",
                            qe.lastError
                          ),
                          (a.iconUrl =
                            "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="),
                          (u = await l())),
                        !u)
                      )
                        return (
                          w.log(
                            "notify: chronos creating finally failed",
                            qe.lastError
                          ),
                          void e.reject()
                        );
                      c && (Bs[n] = c), e.resolve({ type: "chronos", id: n });
                    } else e.resolve();
                  else {
                    const n = () => {
                      t ? l() : a-- ? X(n, 200) : e.resolve();
                    };
                    n();
                  }
                };
                return l(), e.promise();
              }),
          };
        })(),
        Vs = (() => {
          const e = {};
          let t,
            n = null;
          const r = te,
            s = {
              cancel: (t) =>
                e[t]
                  ? (e[t].close(), delete e[t], f.resolve(!0))
                  : f.resolve(!1),
              create: (s, i, o, a, l) => {
                return (
                  t ||
                  ((c = r ? r.permission : "unsupported"),
                  (n = c || "unknown"),
                  w.log("notify: notification level", c),
                  (t = R.Pledge()))
                ).then(async () => {
                  const t = R(),
                    c = async () => {
                      if ("granted" == n || "default" == n) {
                        const { silent: n } = l,
                          c = { body: a || "", icon: i };
                        Ge() >= 43 && void 0 !== n && (c.silent = n),
                          (c.requireInteraction = !0);
                        const u = e[s];
                        Bs[s] &&
                          (w.log("notify: notification already exists", s),
                          delete e[s],
                          u && u.close());
                        const A = new r(o || "", c);
                        (A.onclick = () => {
                          w.log("notify: notification click", s);
                          const t = e[s];
                          t && t.onClick.forEach((e) => e(s, !0));
                        }),
                          (A.onclose = A.onerror =
                            (t) => {
                              w.log("notify: notification close", s, t);
                              const n = e[s];
                              n && n.onClose.forEach((e) => e(s));
                            }),
                          (e[s] = {
                            close: () => A.close(),
                            onClose: (u ? u.onClose : []).concat([Ls]),
                            onClick: (u ? u.onClick : []).concat([Ps]),
                          }),
                          t.resolve({ type: "native", id: s });
                      } else if ("denied" == n) t.resolve();
                      else if ("unsupported" == n) t.resolve();
                      else {
                        const e = (e) => {
                          (n = "granted" == e ? "granted" : "denied"), c();
                        };
                        r.requestPermission().then(e);
                      }
                    };
                  return c(), t.promise();
                });
                var c;
              },
            };
          return s;
        })(),
        zs = (() => {
          const e = {};
          return {
            cancel: (t) =>
              e[t] ? (e[t].close(), delete e[t], f.resolve(!0)) : f.resolve(!1),
            create: (t, n, r, s) => {
              if (ce) {
                const i = e[t];
                Bs[t] &&
                  (w.log("notify: notification already exists", t),
                  delete e[t],
                  i && i.close());
                try {
                  const o = ce.createNotification(n, r || "", s || "");
                  return (
                    (o.onclick = () => {
                      w.log("notify: webkit click", t);
                      const n = e[t];
                      n && n.onClick.forEach((e) => e(t, !0));
                    }),
                    (o.onclose = () => {
                      w.log("notify: webkit close", t);
                      const n = e[t];
                      n && n.onClose.forEach((e) => e(t));
                    }),
                    (e[t] = {
                      close: () => o.cancel(),
                      onClose: (i ? i.onClose : []).concat([Ls]),
                      onClick: (i ? i.onClick : []).concat([Ps]),
                    }),
                    o.show(),
                    R.Pledge({ type: "webkit", id: t })
                  );
                } catch (e) {
                  w.warn(
                    "notify: webkitNotifications creation failed with: " +
                      e.message
                  );
                }
              }
              return R.Pledge();
            },
          };
        })(),
        qs = (() => {
          const e = ie,
            t = {};
          return {
            cancel: (e) =>
              t[e] ? (t[e](), delete t[e], f.resolve(!0)) : f.resolve(!1),
            create: (t, n, r, s, i) => {
              const { informational: o } = i,
                a = R();
              return (
                !e || o
                  ? (a.resolve(),
                    X(() => {
                      Ls(t);
                    }, 1))
                  : (a.resolve({ type: "conf", id: t }),
                    X(() => {
                      const n = e((r ? r + "\n\n" : "") + s);
                      Ps(t, !!n), X(() => Ls(t), 1);
                    }, 1)),
                a.promise()
              );
            },
          };
        })(),
        Hs = (e, t, n, r, s, i) => {
          s = s || {};
          const { timeout: o } = s;
          let a;
          const l = o;
          let c,
            u = !1,
            A = null;
          const d = (e) => {
              switch (e) {
                case "webkit":
                  return zs;
                case "native":
                  return Vs;
                case "chronos":
                  return Ns;
                case "conf":
                  return qs;
              }
            },
            h = () => {
              A && L(A), !u && i && i({});
            },
            p = () => {
              if (((u = !0), i && i({ clicked: u }), a)) {
                const e = d(a.type);
                e && e.cancel(a.id);
              }
            };
          return (
            (r = r || ze.getURL("images/icon128.png")),
            Cs(r)
              .then((e) => (null == e ? void 0 : e.toDataUri()))
              .then((e) => (c = e || r))
              .then(() => Ds.acquire())
              .then(() => Ns.create(e, c, t, n, s))
              .then((r) => r || zs.create(e, c, t, n, s))
              .then((r) => r || Vs.create(e, c, t, n, s))
              .then(
                (r) =>
                  r ||
                  qs.create(e, c, t, n, {
                    informational: !i,
                    notificationId: e,
                  })
              )
              .then((e) => {
                if (!e) return;
                const { id: i, type: o } = (a = e),
                  c = (Bs[i] =
                    Bs[i] ||
                    ((e, t) => {
                      const n = (Bs[e] = { cbs: [], o: t });
                      return Fs.set(e, t), n;
                    })(i, s));
                c.cbs.push((e) => {
                  "clicked" in e && p && p(), h && h();
                }),
                  (A = X(() => {
                    A = null;
                    const e = d(o);
                    e && e.cancel(i);
                  }, l || 6e5)),
                  w.log("notify:", t, n, r, l);
              })
              .always(() => Ds.release()),
            {
              cancel: () => {
                if (a) {
                  const e = d(a.type);
                  e && e.cancel(a.id);
                }
              },
            }
          );
        },
        Qs = (e, t, n, r, s) => Hs(r.notificationId || Xt(), e, t, n, r, s),
        Ws = {},
        Xs = {},
        Ys = (e, t) => {
          let n;
          const r = t.key || "general",
            s = t.timeout || 3e5,
            i = X(() => {
              delete e[r];
            }, s);
          (n = e[r]) && L(n.to),
            (e[r] = { ts: Date.now() + s, options: t, to: i });
        },
        Js = (e) => {
          const t = Date.now();
          return Object.keys(e)
            .map((n) => {
              const r = e[n],
                s = r.options;
              let i;
              if ((i = Math.max(0, r.ts - t))) return (s.timeout = i), s;
            })
            .filter((e) => e);
        },
        Ks = {
          all: (e, t) => {
            Ks.actionPage(e, t), Ks.optionsPage(e, t);
          },
          removeAll: (e) => {
            delete Ws[e], delete Xs[e];
          },
          actionPage: (e, t) => {
            const n = ze.getViews({ type: "popup" });
            n &&
              n.length &&
              ze.sendMessage({ method: e, options: t }, () => {}),
              t && Ys(Ws, t);
          },
          optionsPage: (e, t) => {
            const n = ze.getViews({
              type: "tab",
            });
            n &&
              n.length &&
              ze.sendMessage({ method: e, options: t }, () => {}),
              t && Ys(Xs, t);
          },
          actionStatus: () => Js(Xs),
          optionsStatus: () => Js(Ws),
        },
        $s = Ks;
      let ei;
      const ti = {
          newV: ze.manifest.version,
          oldV: void 0,
          first_run: !1,
          active: !1,
        },
        ni = () => {
          if (!k.late) return void k.registerLateCallback(ni);
          let e,
            t = "version=" + ti.newV + "&ext=" + qe.short_id + "&updated=true";
          if (
            (ti.first_run
              ? ((e = window.openPage),
                (ti.active = !0))
              : ((t += "&old=" + ti.oldV),
                (e = window.openPage)),
            "off" == un.values.notification_showUpdate)
          );
          else if ("notification" == un.values.notification_showUpdate)
            (n = Dr.getMessage("Updated_to__0version0", ti.newV)),
              (r = Dr.getMessage("Click_here_to_see_the_recent_changes")),
              (s = vs("tampermonkey")),
              (i = (t) => {
                t.clicked && Ye({ url: e }, () => {});
              }),
              Hs(Xt(), n, r, s, { timeout: 3e5 }, i);
          else if ("changelog" == un.values.notification_showUpdate) {
            ti.active || (e ), (ti.active = !0);
            const t = { url: e, active: ti.active };
            Ye(t, () => {});
          }
          var n, r, s, i;
        },
        ri = (() => {
          const e = R(),
            t = () => {
              const t = Date.now(),
                n = Ot.getValue(Ze.STORAGE.LAST_START, 0),
                r = Math.round((t - n) / 1e3),
                s = r <= 60;
              w.log("upd: restart?", s, "(", r, "seconds ago)"), e.resolve(s);
            };
          return k.late ? t() : k.registerLateCallback(t), e.promise();
        })(),
        si = () => {
          let e = !1,
            t = !1;
          (() => {
            let e, t;
            const n = R(),
              r = () => {
                t && ((t = void 0), n.resolve(!!e));
              };
            return (
              (t = X(r, 300)),
              kt(15, (t) => {
                (e = "active" == t), r();
              }),
              n.promise()
            );
          })()
            .then((e) => ((t = e), ri))
            .then((t) => {
              e = t;
            })
            .always(() => {
              (ti.active = !t || e), ni(), (li = !0);
            });
        };
      let ii = !1;
      const oi = "extentsion_update_available";
      let ai, li;
      const ci = {
        scheduleNotification: (e, t) => {
          li ||
            ((ti.oldV = e || void 0),
            ti.first_run || (ti.first_run = t),
            ai && L(ai),
            (ai = X(si, 1e3)));
        },
        updateAvailable: () => ei,
        onInstalled: () => {
          ci.scheduleNotification(void 0, !0);
        },
        onUpdated: (e) => {
          ci.scheduleNotification(e, !1);
        },
        onUpdateAvailable: (e) => {
          ii ||
            (w.info("An update to version", e.version, "is available"),
            (ei = e.version),
            $s.all("status", {
              key: oi,
              id: oi,
              class: "information",
              text: Dr.getMessage(
                "0name0_0version0_is_available__Please_re_start_your_browser_to_update_",
                ze.manifest.name,
                e.version
              ),
              timeout: 864e5,
            }),
            (ii = !0));
        },
      };
      k.registerLateCallback(() => {
        Ot.setValue(Ze.STORAGE.LAST_START, Date.now());
      });
      const ui = ci;
      class Ai {
        constructor() {
          this.events = {};
        }
        on(e, t, n) {
          const r = void 0 === n || Array.isArray(n) ? n : [n],
            { events: s } = this;
          let i = s[e];
          return (
            i || ((i = []), (s[e] = i)),
            i.push({ listener: t, filter: r }),
            () => this.off(e, t)
          );
        }
        once(e, t) {
          const n = this.on(e, (...e) => (n(), t.bind(this)(...e)));
          return n;
        }
        off(e, t) {
          const n = this.events[e];
          n && (this.events[e] = n.filter((e) => e.listener !== t));
        }
        emit(e, ...t) {
          const n = this.events[e];
          if (n)
            for (const e of n) {
              const { listener: n, filter: r } = e;
              if ((!r || qt(t, r)) && !0 === n(...t)) return !0;
            }
          return !1;
        }
        listening(e, t) {
          const n = this.events[e];
          if (n) {
            if (t) {
              const e = Array.isArray(t) ? t : [t];
              return n.filter((t) => !t.filter || qt(t.filter, e)).length;
            }
            return n.length;
          }
          return 0;
        }
      }
      const di = new Ai(),
        hi = new Ai();
      let pi = {},
        fi = null;
      const mi = () => {
          const e = Date.now(),
            t = pi;
          pi = {};
          const n = Object.keys(t);
          n.forEach((n) => {
            const r = t[n];
            r && e - r.ts < gi
              ? (pi[n] = r)
              : r.com.reject({ error: "timeout", please_close: !0 });
          }),
            null !== fi && 0 === n.length && (P(fi), (fi = null));
        },
        gi = 15e3;
      let vi = !1;
      const _i = (e, t) => {
          vi || wi.init(), null === fi && (fi = W(mi, 5e3));
          const n = R();
          return ((e, t) => {
            const n = R();
            return (
              void 0 === t && (t = !0),
              $e(null, (r) => {
                const s = r ? r.index + 1 : void 0;
                Ye(
                  {
                    url: ze.getURL("ask.html") + "?aid=" + e,
                    active: t,
                    index: s,
                    parent: r,
                  },
                  (e) => {
                    if (!e) {
                      const e = "tabs.create failed -> giving up now!";
                      return w.error(e), void n.reject({ error: e });
                    }
                    n.resolve({ id: e.id, close: () => Ke(e.id) });
                  }
                );
              }),
              n.promise()
            );
          })(
            ((e) => {
              const t = Xt();
              return (pi[t] = e), t;
            })({ ts: Date.now(), com: n, preparat: t, type: e }),
            t.active
          ).then((e) =>
            n.promise().done((t) => {
              (t.ok || t.aborted) && e.close();
            })
          );
        },
        wi = {
          init: () => {
            vi || (vi = !0);
          },
          onMessage: (e) => {
            const t = R(),
              n = e.aid,
              r = pi[n];
            if (r) {
              if (
                (r.aborter && (L(r.aborter), delete r.aborter),
                "ping" == e.method)
              )
                (pi[n].ts = Date.now()), t.resolve({ pong: !0 });
              else if ("preparat" == e.method)
                t.resolve({ preparat: r.preparat, type: r.type });
              else if ("install" == e.method) {
                const s = e.message;
                r.com.resolve({ ok: !0, message: s }),
                  t.resolve({}),
                  delete pi[n];
              } else if ("import" == e.method) {
                const s = e.message;
                r.com.resolve({ ok: !0, message: s }),
                  t.resolve({}),
                  delete pi[n];
              } else if ("permission" == e.method) {
                const s = e.message;
                r.com.resolve({ ok: !0, message: s }),
                  t.resolve({}),
                  delete pi[n];
              } else if ("unload" == e.method || "abort" == e.method) {
                t.resolve({});
                const s = () => {
                  r.com.resolve({ ok: !1, aborted: !0, message: void 0 }),
                    delete pi[n];
                };
                "abort" == e.method ? s() : (r.aborter = X(s, 3e3));
              } else if ("connect" == e.method) {
                const s = e.message;
                r.com.resolve({ ok: !0, message: s }),
                  t.resolve({}),
                  delete pi[n];
              }
            } else t.reject({ error: "unknown_id", please_close: !0 });
            return t.promise();
          },
          install: (e) => _i("install", e),
          import: (e) => _i("import", e),
          askForPermission: (e, t, n) => {
            const r = {
              permissions: e.permissions,
              origins: e.origins,
              title: t,
              message: n,
            };
            return _i("permission", r);
          },
          installError: (e) => _i("install_error", e),
          askForConnect: (e) => _i("connect", e),
        },
        bi = wi;
      let yi, ki, Ri;
      const xi = () => yi || R.Pledge(),
        Ei = (e) => {
          bt.supported &&
            (bt.onAdded.addListener((t) => {
              e({ added: t });
            }),
            bt.onRemoved.addListener((t) => {
              e({ removed: t });
            }));
        },
        Si = () => {
          const e = R(),
            t = (ki = {}),
            n = (Ri = {});
          return (
            (yi = e.promise()),
            bt.supported
              ? bt.getAll((r) => {
                  r.permissions &&
                    Object.values(r.permissions).forEach((e) => (t[e] = !0)),
                    r.origins &&
                      Object.values(r.origins).forEach((e) => (n[e] = !0)),
                    (yi = void 0),
                    e.resolve();
                })
              : e.resolve(),
            e.promise()
          );
        },
        Ci = {
          permDownloads: "downloads",
          has: (e) =>
            xi().then(
              () =>
                !bt.supported ||
                (ki && Ri
                  ? !!ki[e] || !!Ri[e]
                  : (Ei(() => {
                      xi().then(() => Si());
                    }),
                    Si().then(() => Ci.has(e))))
            ),
          hasOrigin: (e) => {
            const t = Qt(e);
            return xi().then(() => {
              const e = R();
              return (
                bt.supported
                  ? bt.contains({ origins: t }, (t) => {
                      e.resolve(t);
                    })
                  : e.resolve(!0),
                e.promise()
              );
            });
          },
          ask: (e, t, n) => {
            const r = Qt(e),
              s = R();
            return (
              bt.supported
                ? bi
                    .askForPermission({ permissions: r }, t, n)
                    .done(({ message: e }) => {
                      const t = !!(null == e ? void 0 : e.granted);
                      if (t) {
                        ki || (ki = {});
                        for (const e of r) ki[e] = !0;
                      }
                      s.resolve(t);
                    })
                : s.resolve(!1),
              s.promise()
            );
          },
          askOrigin: (e, t, n) => {
            const r = Qt(e),
              s = R();
            return (
              bt.supported
                ? bi
                    .askForPermission({ origins: r }, t, n)
                    .done(({ message: e }) => {
                      const t = !!(null == e ? void 0 : e.granted);
                      if (t) {
                        Ri || (Ri = {});
                        for (const e of r) Ri[e] = !0;
                      }
                      s.resolve(t);
                    })
                : s.resolve(!1),
              s.promise()
            );
          },
          remove: (e) =>
            xi().then(() => {
              const t = R();
              return (
                bt.supported
                  ? ((yi = t.promise()),
                    bt.remove({ permissions: [e] }, (n) => {
                      (yi = void 0), ki && (ki[e] = !1), t.resolve(n);
                    }))
                  : t.resolve(!0),
                t.promise()
              );
            }),
          addListener: Ei,
        },
        Mi = Ci;
      var Ii = {},
        Gi = (Ii.util = Ii.util || {});
      (Gi.isArrayBuffer = function (e) {
        return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer;
      }),
        (Gi.isArrayBufferView = function (e) {
          return e && Gi.isArrayBuffer(e.buffer) && void 0 !== e.byteLength;
        }),
        (Gi.ByteBuffer = t),
        (Gi.ByteStringBuffer = t),
        (Gi.ByteStringBuffer.prototype._optimizeConstructedString = function (
          e
        ) {
          (this._constructedStringLength += e),
            this._constructedStringLength > 4096 &&
              (this.data.substr(0, 1), (this._constructedStringLength = 0));
        }),
        (Gi.ByteStringBuffer.prototype.length = function () {
          return this.data.length - this.read;
        }),
        (Gi.ByteStringBuffer.prototype.isEmpty = function () {
          return this.length() <= 0;
        }),
        (Gi.ByteStringBuffer.prototype.putByte = function (e) {
          return this.putBytes(String.fromCharCode(e));
        }),
        (Gi.ByteStringBuffer.prototype.fillWithByte = function (e, t) {
          e = String.fromCharCode(e);
          for (var n = this.data; t > 0; )
            1 & t && (n += e), (t >>>= 1) > 0 && (e += e);
          return (this.data = n), this._optimizeConstructedString(t), this;
        }),
        (Gi.ByteStringBuffer.prototype.putBytes = function (e) {
          return (
            (this.data += e), this._optimizeConstructedString(e.length), this
          );
        }),
        (Gi.ByteStringBuffer.prototype.putString = function (e) {
          return this.putBytes(Gi.encodeUtf8(e));
        }),
        (Gi.ByteStringBuffer.prototype.putInt16 = function (e) {
          return this.putBytes(
            String.fromCharCode((e >> 8) & 255) + String.fromCharCode(255 & e)
          );
        }),
        (Gi.ByteStringBuffer.prototype.putInt24 = function (e) {
          return this.putBytes(
            String.fromCharCode((e >> 16) & 255) +
              String.fromCharCode((e >> 8) & 255) +
              String.fromCharCode(255 & e)
          );
        }),
        (Gi.ByteStringBuffer.prototype.putInt32 = function (e) {
          return this.putBytes(
            String.fromCharCode((e >> 24) & 255) +
              String.fromCharCode((e >> 16) & 255) +
              String.fromCharCode((e >> 8) & 255) +
              String.fromCharCode(255 & e)
          );
        }),
        (Gi.ByteStringBuffer.prototype.putInt16Le = function (e) {
          return this.putBytes(
            String.fromCharCode(255 & e) + String.fromCharCode((e >> 8) & 255)
          );
        }),
        (Gi.ByteStringBuffer.prototype.putInt24Le = function (e) {
          return this.putBytes(
            String.fromCharCode(255 & e) +
              String.fromCharCode((e >> 8) & 255) +
              String.fromCharCode((e >> 16) & 255)
          );
        }),
        (Gi.ByteStringBuffer.prototype.putInt32Le = function (e) {
          return this.putBytes(
            String.fromCharCode(255 & e) +
              String.fromCharCode((e >> 8) & 255) +
              String.fromCharCode((e >> 16) & 255) +
              String.fromCharCode((e >> 24) & 255)
          );
        }),
        (Gi.ByteStringBuffer.prototype.putInt = function (e, t) {
          var n = "";
          do {
            (t -= 8), (n += String.fromCharCode((e >> t) & 255));
          } while (t > 0);
          return this.putBytes(n);
        }),
        (Gi.ByteStringBuffer.prototype.putSignedInt = function (e, t) {
          return e < 0 && (e += 2 << (t - 1)), this.putInt(e, t);
        }),
        (Gi.ByteStringBuffer.prototype.putBuffer = function (e) {
          return this.putBytes(e.getBytes());
        }),
        (Gi.ByteStringBuffer.prototype.getByte = function () {
          return this.data.charCodeAt(this.read++);
        }),
        (Gi.ByteStringBuffer.prototype.getInt16 = function () {
          var e =
            (this.data.charCodeAt(this.read) << 8) ^
            this.data.charCodeAt(this.read + 1);
          return (this.read += 2), e;
        }),
        (Gi.ByteStringBuffer.prototype.getInt24 = function () {
          var e =
            (this.data.charCodeAt(this.read) << 16) ^
            (this.data.charCodeAt(this.read + 1) << 8) ^
            this.data.charCodeAt(this.read + 2);
          return (this.read += 3), e;
        }),
        (Gi.ByteStringBuffer.prototype.getInt32 = function () {
          var e =
            (this.data.charCodeAt(this.read) << 24) ^
            (this.data.charCodeAt(this.read + 1) << 16) ^
            (this.data.charCodeAt(this.read + 2) << 8) ^
            this.data.charCodeAt(this.read + 3);
          return (this.read += 4), e;
        }),
        (Gi.ByteStringBuffer.prototype.getInt16Le = function () {
          var e =
            this.data.charCodeAt(this.read) ^
            (this.data.charCodeAt(this.read + 1) << 8);
          return (this.read += 2), e;
        }),
        (Gi.ByteStringBuffer.prototype.getInt24Le = function () {
          var e =
            this.data.charCodeAt(this.read) ^
            (this.data.charCodeAt(this.read + 1) << 8) ^
            (this.data.charCodeAt(this.read + 2) << 16);
          return (this.read += 3), e;
        }),
        (Gi.ByteStringBuffer.prototype.getInt32Le = function () {
          var e =
            this.data.charCodeAt(this.read) ^
            (this.data.charCodeAt(this.read + 1) << 8) ^
            (this.data.charCodeAt(this.read + 2) << 16) ^
            (this.data.charCodeAt(this.read + 3) << 24);
          return (this.read += 4), e;
        }),
        (Gi.ByteStringBuffer.prototype.getInt = function (e) {
          var t = 0;
          do {
            (t = (t << 8) + this.data.charCodeAt(this.read++)), (e -= 8);
          } while (e > 0);
          return t;
        }),
        (Gi.ByteStringBuffer.prototype.getSignedInt = function (e) {
          var t = this.getInt(e),
            n = 2 << (e - 2);
          return t >= n && (t -= n << 1), t;
        }),
        (Gi.ByteStringBuffer.prototype.getBytes = function (e) {
          var t;
          return (
            e
              ? ((e = Math.min(this.length(), e)),
                (t = this.data.slice(this.read, this.read + e)),
                (this.read += e))
              : 0 === e
              ? (t = "")
              : ((t = 0 === this.read ? this.data : this.data.slice(this.read)),
                this.clear()),
            t
          );
        }),
        (Gi.ByteStringBuffer.prototype.bytes = function (e) {
          return void 0 === e
            ? this.data.slice(this.read)
            : this.data.slice(this.read, this.read + e);
        }),
        (Gi.ByteStringBuffer.prototype.at = function (e) {
          return this.data.charCodeAt(this.read + e);
        }),
        (Gi.ByteStringBuffer.prototype.setAt = function (e, t) {
          return (
            (this.data =
              this.data.substr(0, this.read + e) +
              String.fromCharCode(t) +
              this.data.substr(this.read + e + 1)),
            this
          );
        }),
        (Gi.ByteStringBuffer.prototype.last = function () {
          return this.data.charCodeAt(this.data.length - 1);
        }),
        (Gi.ByteStringBuffer.prototype.copy = function () {
          var e = Gi.createBuffer(this.data);
          return (e.read = this.read), e;
        }),
        (Gi.ByteStringBuffer.prototype.compact = function () {
          return (
            this.read > 0 &&
              ((this.data = this.data.slice(this.read)), (this.read = 0)),
            this
          );
        }),
        (Gi.ByteStringBuffer.prototype.clear = function () {
          return (this.data = ""), (this.read = 0), this;
        }),
        (Gi.ByteStringBuffer.prototype.truncate = function (e) {
          var t = Math.max(0, this.length() - e);
          return (
            (this.data = this.data.substr(this.read, t)), (this.read = 0), this
          );
        }),
        (Gi.ByteStringBuffer.prototype.toHex = function () {
          for (var e = "", t = this.read; t < this.data.length; ++t) {
            var n = this.data.charCodeAt(t);
            n < 16 && (e += "0"), (e += n.toString(16));
          }
          return e;
        }),
        (Gi.ByteStringBuffer.prototype.toString = function () {
          return Gi.decodeUtf8(this.bytes());
        }),
        (Gi.createBuffer = function (e, t) {
          return (
            (t = t || "raw"),
            void 0 !== e && "utf8" === t && (e = Gi.encodeUtf8(e)),
            new Gi.ByteBuffer(e)
          );
        }),
        (Gi.fillString = function (e, t) {
          for (var n = ""; t > 0; )
            1 & t && (n += e), (t >>>= 1) > 0 && (e += e);
          return n;
        }),
        (Gi.encodeUtf8 = function (e) {
          return unescape(encodeURIComponent(e));
        }),
        (Gi.decodeUtf8 = function (e) {
          return decodeURIComponent(escape(e));
        });
      var Ui = (Ii.sha256 = Ii.sha256 || {});
      (Ii.md = Ii.md || {}),
        (Ii.md.algorithms = Ii.md.algorithms || {}),
        (Ii.md.sha256 = Ii.md.algorithms.sha256 = Ui),
        (Ui.create = function () {
          Ti ||
            ((Zi = String.fromCharCode(128)),
            (Zi += Ii.util.fillString(String.fromCharCode(0), 64)),
            (Bi = [
              1116352408, 1899447441, 3049323471, 3921009573, 961987163,
              1508970993, 2453635748, 2870763221, 3624381080, 310598401,
              607225278, 1426881987, 1925078388, 2162078206, 2614888103,
              3248222580, 3835390401, 4022224774, 264347078, 604807628,
              770255983, 1249150122, 1555081692, 1996064986, 2554220882,
              2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
              113926993, 338241895, 666307205, 773529912, 1294757372,
              1396182291, 1695183700, 1986661051, 2177026350, 2456956037,
              2730485921, 2820302411, 3259730800, 3345764771, 3516065817,
              3600352804, 4094571909, 275423344, 430227734, 506948616,
              659060556, 883997877, 958139571, 1322822218, 1537002063,
              1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
              2428436474, 2756734187, 3204031479, 3329325298,
            ]),
            (Ti = !0));
          var e = null,
            t = Ii.util.createBuffer(),
            r = new Array(64),
            s = {
              algorithm: "sha256",
              blockLength: 64,
              digestLength: 32,
              messageLength: 0,
              messageLength64: [0, 0],
              start: function () {
                return (
                  (s.messageLength = 0),
                  (s.messageLength64 = [0, 0]),
                  (t = Ii.util.createBuffer()),
                  (e = {
                    h0: 1779033703,
                    h1: 3144134277,
                    h2: 1013904242,
                    h3: 2773480762,
                    h4: 1359893119,
                    h5: 2600822924,
                    h6: 528734635,
                    h7: 1541459225,
                  }),
                  s
                );
              },
            };
          return (
            s.start(),
            (s.update = function (i, o) {
              return (
                "utf8" === o && (i = Ii.util.encodeUtf8(i)),
                (s.messageLength += i.length),
                (s.messageLength64[0] += (i.length / 4294967296) >>> 0),
                (s.messageLength64[1] += i.length >>> 0),
                t.putBytes(i),
                n(e, r, t),
                (t.read > 2048 || 0 === t.length()) && t.compact(),
                s
              );
            }),
            (s.digest = function () {
              var i = Ii.util.createBuffer();
              i.putBytes(t.bytes()),
                i.putBytes(
                  Zi.substr(0, 64 - ((s.messageLength64[1] + 8) & 63))
                ),
                i.putInt32(
                  (s.messageLength64[0] << 3) | (s.messageLength64[0] >>> 28)
                ),
                i.putInt32(s.messageLength64[1] << 3);
              var o = {
                h0: e.h0,
                h1: e.h1,
                h2: e.h2,
                h3: e.h3,
                h4: e.h4,
                h5: e.h5,
                h6: e.h6,
                h7: e.h7,
              };
              n(o, r, i);
              var a = Ii.util.createBuffer();
              return (
                a.putInt32(o.h0),
                a.putInt32(o.h1),
                a.putInt32(o.h2),
                a.putInt32(o.h3),
                a.putInt32(o.h4),
                a.putInt32(o.h5),
                a.putInt32(o.h6),
                a.putInt32(o.h7),
                a
              );
            }),
            s
          );
        });
      var Zi = null,
        Ti = !1,
        Bi = null;
      Gi.hasWideChar = function (e) {
        for (var t = 0; t < e.length; t++) if (e.charCodeAt(t) >>> 8) return !0;
        return !1;
      };
      const Oi = function (e, t) {
          var n = Ii.md.sha256.create();
          return (
            n.update(
              e,
              "UTF-8" == t || (void 0 === t && Gi.hasWideChar(e))
                ? "utf8"
                : void 0
            ),
            n.digest().toHex()
          );
        },
        Fi = ["md5", "sha256", "sha1", "sha384", "sha512"],
        Di = (() => {
          const e = (e) => {
              const t = [],
                n = new DataView(e);
              for (let e = 0; e < n.byteLength; e += 4) {
                const r = "00000000",
                  s = (r + n.getUint32(e).toString(16)).slice(-r.length);
                t.push(s);
              }
              return t.join("");
            },
            t = (t) => {
              try {
                return e(me(pe(t)));
              } catch (e) {
                return null;
              }
            },
            n = {
              md5: (e, t) => R.Pledge(ve(e, t)),
              sha256: (e, t) => R.Pledge(Oi(e, t)),
            },
            r = {};
          ["SHA-1", "SHA-384", "SHA-512"].forEach((t) => {
            const n = t.toLowerCase().replace("-", "");
            r[n] = () => {
              const n = (n, r) => {
                const s = R();
                return (
                  N.subtle.digest(t, me(n, { encoding: r })).then(
                    (t) => {
                      s.resolve(e(t));
                    },
                    () => {
                      s.reject();
                    }
                  ),
                  s.promise()
                );
              };
              try {
                return n("").then((e) =>
                  e &&
                  e
                    .substr(0, 4)
                    .toLowerCase()
                    .match(/[0-9a-f]{4,4}/)
                    ? n
                    : R.Breach()
                );
              } catch (e) {
                return R.Breach();
              }
            };
          });
          const s = (e) => Object.keys(n).includes(e),
            i =
              (e) =>
              (...t) => {
                if (!1 !== o) {
                  const n = R();
                  return o.push(() => n.consume(e(...t))), n.promise();
                }
                return e(...t);
              };
          let o = [];
          const a = {
            init: () => (
              w.get() >= 60 &&
                Object.keys(n).forEach((e) => w.log("sri:", e, "is supported")),
              R.sidebyside(
                Object.keys(r).map((e) =>
                  r[e]()
                    .done((t) => {
                      w.log("sri:", e, "is supported"), (n[e] = t);
                    })
                    .fail(() => {
                      w.log("sri:", e, "is unsupported");
                    })
                )
              ).always(() => {
                if (!1 === o) return;
                const e = o;
                (o = !1), e.forEach((e) => e());
              })
            ),
            isSupported: i((e) => R.Pledge(s(e))),
            getHash: i((e, n) => {
              const r = R(),
                i = "string" == typeof e ? Zn(e) : e;
              if (i && i.hash) {
                let e;
                const o = i.hash.replace(/^#/, "").split(/,|;/g);
                for (let n = 0; n < o.length; n++) {
                  const r = o[n].match(/([^=|:|-]+)[=|:|-](.+)/);
                  if (!r || 3 != r.length || !s(r[1])) continue;
                  let i = r[2];
                  /^[0-9a-fA-F]+$/.exec(i) || (i = t(V(i)) || i);
                  const a = r[1];
                  Fi.includes(a) && (e = { type: a, value: i });
                }
                r.resolve(e || (n ? e : { type: "unsupported", value: "" }));
              } else r.resolve();
              return r.promise();
            }),
            check: i((e, t, r) =>
              t && e && s(e.type)
                ? n[e.type](t, r).then((t) =>
                    t === e.value
                      ? R.Pledge(!0)
                      : R.Breach({ type: e.type, value: t })
                  )
                : R.Breach()
            ),
          };
          return a;
        })(),
        ji = Di,
        Pi = () => {
          const e = Ot.getValue(Ze.STORAGE.UPDATE, {}) || {};
          let { scripts: t, black: n } = e;
          return (
            null == n && (n = Object.assign({}, { version: 0, last: 0 })),
            null == t && (t = 0),
            { black: n, scripts: t }
          );
        },
        Li = function (e) {
          e && Ot.setValue(Ze.STORAGE.UPDATE, e);
        },
        Ni = ((e, t, n) => {
          const r = new Is(1),
            s = {},
            i = {},
            o = {},
            a = {},
            l = {};
          if (void 0 === t)
            throw new Error(
              "alarm: storage or setTimeout++ needs to be provided"
            );
          const c = ((e) => e && "function" == typeof e.setTimeout)(t),
            u = c ? t : void 0,
            A = c ? void 0 : t,
            d = n;
          let h = [];
          const p = async (e) => {
              const t = e.name;
              if ((console.debug(`alarm: onAlarm[${t}]`, e), t)) {
                await r.acquire(),
                  console.debug(`alarm: onAlarm[${t}] mutex acquired`, a, l);
                const n = l[t],
                  s = a[t];
                n && s
                  ? (m(n.type, ...n.args),
                    void 0 === e.periodInMinutes && (await v([t])))
                  : (n
                      ? console.warn(
                          `alarm: onAlarm[${t}|${n.type}] - no alarm for alarm`
                        )
                      : console.warn(
                          `alarm: onAlarm[${t}] - no data for alarm`
                        ),
                    await v([t])),
                  console.debug(`alarm: onAlarm[${t}] mutex release`),
                  (h = h.filter((e) => e.name !== t)),
                  r.release();
              }
            },
            m = (t, ...n) => {
              e(() => {
                console.debug(`alarm: emit[*|${t}]`, n);
                const e = s[t];
                if (e) for (const t of e) if (!0 === t(...n)) return;
              });
            },
            g = (e, t) => {
              const { clearTimeout: n, clearInterval: r } = t;
              let s = !1;
              const a = i[e];
              a && (n(a), delete i[e], (s = !0));
              const l = o[e];
              return l && (r(l), delete o[e], (s = !0)), s;
            },
            v = async (e) => {
              let t = !1;
              return (
                console.debug("alarm: internalClear", e),
                A && d
                  ? await f.all(
                      e.map(
                        (e) => (
                          delete a[e],
                          delete l[e],
                          f.all([
                            d.delete(e),
                            A.clear(e).then((e) => (t = e || t)),
                          ])
                        )
                      )
                    )
                  : u &&
                    e.forEach((e) => {
                      delete a[e], delete l[e], (t = g(e, u) || t);
                    }),
                console.debug("alarm: internalClear done", e, a, l),
                t
              );
            },
            _ = (e, t) => {
              let n = s[e];
              return n || ((n = []), (s[e] = n)), n.push(t), () => w(e, t);
            },
            w = (e, t) => {
              const n = s[e];
              if (n) {
                const e = n.indexOf(t);
                e >= 0 && n.splice(e, 1);
              }
            },
            b = async (e) => {
              const t = Array.isArray(e) ? e : [e];
              if ((console.debug("alarm: clear", t), A)) {
                await r.acquire();
                const e = await v(t);
                return r.release(), e;
              }
              return v(t);
            };
          return (
            A &&
              d &&
              (r.acquire().then(async () => {
                const e = [],
                  t = await d.list();
                for (const { key: e, value: n } of t) l[e] = n;
                const n = await A.getAll();
                h && n.push(...h);
                for (const t of n) {
                  const n = t.name;
                  l[n]
                    ? (a[n] = t)
                    : (console.warn("alarm: no data for alarm " + n),
                      e.push(n));
                }
                Object.keys(l).map((t) => (a[t] ? null : e.push(t))),
                  e.length && (await v(e)),
                  console.debug("alarm: init done", a, l),
                  r.release();
              }),
              A.onAlarm.addListener((e) => {
                h.push(e), p(e);
              })),
            {
              onAlarm: p,
              on: _,
              once: (e, t) => {
                const n = _(e, (...e) => (n(), t.bind(void 0)(...e)));
                return n;
              },
              off: w,
              schedule: async (e, t, ...n) => {
                const s = e,
                  {
                    when: c,
                    delayInMinutes: h,
                    periodInMinutes: p,
                    keepExistent: _,
                  } = t;
                return await r
                  .acquire()
                  .then(async () => {
                    const e = (Object.entries(l).find(
                      ([e, t]) => t.type === s
                    ) || [])[0];
                    if (
                      (console.debug(`alarm: schedule[?|${s}]`, t, n, e),
                      e && _)
                    )
                      return e;
                    const r = e || Math.random().toString(36).substr(2, 10);
                    if (A && d) {
                      console.debug(
                        `alarm: schedule[${r}|${s}] mutex acquired`
                      ),
                        e && (await A.clear(r));
                      const i = (l[r] = { type: s, args: n });
                      await f.all([
                        d.set(r, i),
                        A.create(r, {
                          when: c,
                          delayInMinutes: h,
                          periodInMinutes: p,
                        }),
                      ]);
                      const o = await A.get(r);
                      o
                        ? (a[r] = o)
                        : console.warn(
                            `alarm: schedule[${r}|${s}] unable to create alarm`,
                            t
                          ),
                        console.debug(
                          `alarm: schedule[${r}|${s}] mutex release`
                        );
                    } else if (u) {
                      const {
                          setInterval: e,
                          setTimeout: t,
                          getCurrentTime: A,
                        } = u,
                        d = A();
                      let f;
                      g(r, u);
                      const _ = p ? 60 * p * 1e3 : void 0;
                      if (((f = c ? c - d : h ? 60 * h * 1e3 : _ || 0), _)) {
                        if (_ < 0)
                          return (
                            console.warn(
                              `alarm: schedule[${r}|${s}] - period ${p} is too small`
                            ),
                            r
                          );
                        for (; f < 0; ) f += _;
                      }
                      if (f < 0)
                        return (
                          console.warn(
                            `alarm: schedule[${r}|${s}] - when ${c} is too small`
                          ),
                          r
                        );
                      (i[r] = t(() => {
                        m(s, ...n),
                          delete i[s],
                          _ ? (o[r] = e(() => m(s, ...n), _)) : v([r]);
                      }, f)),
                        (l[r] = { type: s, args: n }),
                        (a[r] = {
                          name: r,
                          scheduledTime: d + f,
                          periodInMinutes: p,
                        });
                    }
                    return r;
                  })
                  .always(() => r.release());
              },
              get: (e) => a[e],
              list: () =>
                A ? Object.keys(a) : Object.keys(i).concat(Object.keys(o)),
              clear: b,
              clearAll: async () => (
                console.debug("alarm: clearAll"),
                A
                  ? await b(Object.keys(a))
                  : b(Object.keys(i).concat(Object.keys(o)))
              ),
            }
          );
        })(
          k.ensureLate,
          Rt && Rt.supported
            ? Rt
            : {
                setInterval: W,
                setTimeout: X,
                clearInterval: P,
                clearTimeout: L,
                getCurrentTime: () => Date.now(),
              },
          Rt && Rt.supported ? Ts("alarms") : void 0
        ),
        Vi = "https://blacklist.tampermonkey.net/get.php",
        zi = (e, t) => {
          let n = !1;
          if (t.length) {
            if ("/" == t.substr(0, 1)) {
              const r = vd(t);
              if (!r) return;
              n = _d(e, r);
            } else n = -1 != e.indexOf(t);
            return n && w.log('black: entry "' + t + '" matched'), n;
          }
        },
        qi = "broadcast",
        Hi = (e) => {
          if (($s.removeAll(qi), e && e.description)) {
            let {
              name: t,
              name_i18n: n,
              description: r,
              description_i18n: s,
              expires: i,
              exclude: o,
              timeout: a,
              ...l
            } = e;
            if (i) {
              const e = Date.now();
              if (!(i > e)) return;
              a = i - e;
            }
            if (o && o.includes(Pe.short_id)) return;
            (t = t || Dr.getMessage("Info")), (a = a || 864e5);
            const c = {
              name: t,
              description: r,
              name_i18n: n || null,
              description_i18n: s || null,
              timeout: a,
              ...l,
            };
            $s.all("status", {
              key: qi,
              class: c.class || "information",
              title: Dr.getTranslation(c, "name"),
              text: Dr.getTranslation(c, "description"),
              timeout: a,
            });
          }
        },
        Qi = {
          SEVERITY_MAX: 10,
          SEVERITY_MANUALLY_DEFINED: 11,
          SEVERITY_FOISTED_SCRIPT: 12,
          init: () => {
            const e = R();
            Ni.on("blu", () => {
              "server" === un.values.script_blacklist_type && Qi.checkUpdate();
            });
            const t = () => {
              if (
                (Ni.schedule("blu", {
                  when: Date.now() + 6e4,
                  keepExistent: !0,
                }),
                ae)
              )
                try {
                  const e = ae.getItem(qi);
                  e && Hi(JSON.parse(e));
                } catch (e) {
                  w.error(e);
                }
            };
            return (
              t(),
              un.addChangeListener("script_blacklist_type", t),
              e.resolve(),
              e.promise()
            );
          },
          getWarningsFor: (e) => {
            const t = [];
            return (
              e &&
                Nt(un.values.script_blacklist_server, (n) => {
                  if (!n) return;
                  const { rules: r, reasons: s, reason: i, exclude: o } = n;
                  if (o && o.includes(Pe.short_id)) return;
                  let a = !1;
                  if ((Nt(r, (t) => ((a = a || !!zi(e, t)), 1 != a)), a))
                    if (s) {
                      const e = Dr.getBestLocale(Object.keys(s));
                      t.push(s[e || "en"]);
                    } else i && t.push(i);
                }),
              t
            );
          },
          getEvilnessOf: (e) => {
            if ("off" === un.values.script_blacklist_type) return 0;
            if (!e) return 0;
            let t = !1,
              n = 0;
            return (
              Nt(
                un.values.require_blacklist,
                (n) => ((t = t || !!zi(e, n)), 1 != t)
              ),
              t
                ? (n = Qi.SEVERITY_MANUALLY_DEFINED)
                : "server" === un.values.script_blacklist_type &&
                  Nt(un.values.script_blacklist_server, (r) => {
                    if (!r) return;
                    const { rules: s, severity: i, exclude: o } = r;
                    return o && o.includes(Pe.short_id)
                      ? void 0
                      : (Nt(s, (n) => ((t = t || !!zi(e, n)), 1 != t)),
                        t ? ((n = i), !1) : void 0);
                  }),
              Number(n)
            );
          },
          checkUpdate: (e) => {
            const t = R();
            let n,
              r = Pi();
            if (e || Date.now() - r.black.last > 864e5) {
              const s = (e, t) => {
                const n = R(),
                  r = {
                    method: "GET",
                    url: e,
                    nocache: t,
                    retries: Oe.RETRIES,
                    overrideMimeType: "text/plain; charset=x-user-defined",
                  };
                return (
                  cd.internal(r, { ondone: (e) => n.resolve(e) }), n.promise()
                );
              };
              s(Vi + "?version=get")
                .then((t) => {
                  if (4 == t.readyState && 200 == t.status) {
                    try {
                      const e = JSON.parse(t.responseText);
                      n = e.version;
                    } catch (e) {
                      w.warn(
                        "black: unable to parse version response! " +
                          t.responseText
                      );
                    }
                    if (
                      (w.info(
                        "black: local version: " +
                          r.black.version +
                          " remote: " +
                          n
                      ),
                      n > r.black.version || e)
                    )
                      return s(Vi, !0);
                  }
                })
                .then((e) => {
                  if (e && 4 == e.readyState && 200 == e.status)
                    try {
                      const t = JSON.parse(e.responseText);
                      if (t && t.blacklist && 1 == t.version) {
                        un.values.script_blacklist_server = t.blacklist;
                        const e = t.broadcast;
                        if (ae)
                          try {
                            e
                              ? ae.setItem(qi, JSON.stringify(e))
                              : ae.removeItem(qi);
                          } catch (e) {
                            w.error(e);
                          }
                        Hi(e);
                      }
                      w.info("black: updated blacklist to ", t);
                    } catch (t) {
                      w.warn(
                        "black: blacklist update failed! ",
                        e.responseText
                      );
                    }
                })
                .always(() => {
                  (r = Pi()),
                    (r.black.last = Date.now()),
                    (r.black.version = n || r.black.version),
                    Li(r),
                    t.resolve();
                });
            } else t.resolve();
            return t.promise();
          },
        },
        Wi = Qi,
        Xi = {
          content: "",
          error: void 0,
          forbidden: void 0,
          sri: void 0,
          determined: void 0,
          meta: void 0,
          name: void 0,
          blacklisted: void 0,
        },
        Yi = (e, t) =>
          Ze.PREFIX.EXTERNAL + [e, t ? ve(t) : null].filter((e) => e).join(":"),
        Ji = {
          list: (e) => {
            const t = new RegExp("^" + e);
            return Ot.listValues().filter((e) => -1 != e.search(t));
          },
          set: (e, t, n, r, s) => {
            const i = Yi(e, t),
              {
                content: o,
                meta: a,
                name: l,
                forbidden: c,
                blacklisted: u,
                error: A,
                determined: d,
                sri: h,
              } = n,
              p = {
                base: ye(o),
                meta: a,
                name: l,
                forbidden: c,
                blacklisted: u,
                error: A,
                determined: d,
                sri: h,
              },
              f = { ts: s || Date.now(), url: t, resource: p, modified: r };
            Ot.setValue(i, f);
          },
          get: (e, t) => {
            const n = Yi(e, t),
              r = Ot.getValue(n);
            let s;
            if (r && r.resource) {
              const { resource: e, ts: t, url: n, modified: i } = r,
                {
                  base: o,
                  meta: a,
                  name: l,
                  forbidden: c,
                  blacklisted: u,
                  error: A,
                  determined: d,
                  sri: h,
                } = e;
              s = {
                ts: t,
                url: n,
                data: {
                  content: ke(o),
                  meta: a,
                  name: l,
                  forbidden: c,
                  blacklisted: u,
                  error: A,
                  determined: d,
                  sri: h,
                },
                modified: i,
              };
            }
            return s;
          },
          clean: (e, t) => {
            const n = Yi(e, t);
            Ot.deleteValue(n);
          },
          cleanAll: (e, t) => {
            let n;
            const r = Ji.list(Yi(e));
            if (t) {
              const s = {};
              Nt(t, (t) => {
                const n = Yi(e, t);
                s[n] = !0;
              }),
                (n = []),
                Nt(r, (e) => {
                  s[e] || n.push(e);
                });
            } else n = r;
            n.forEach((e) => {
              Ot.deleteValue(e);
            });
          },
        },
        Ki = Ht(9e3),
        $i = (e, t, n, r) => {
          const s = R(),
            i = !1;
          let o;
          return (
            ((e, t) => {
              const n = R(),
                r = (r) => {
                  let s,
                    i = "";
                  if (
                    4 != r.readyState ||
                    (200 != r.status && 0 != r.status) ||
                    r.error
                  ) {
                    const e = { ...Xi, content: i, meta: s };
                    n.reject(e);
                  } else {
                    let o, a;
                    const l = qA(r.responseHeaders)["content-type"];
                    l &&
                      l.match(/^\s*(image\/|text\/)([+-.a-zA-Z0-9]+)\s*$/) &&
                      (o = l.trim()),
                      o ||
                        ((a = e.match(/.*\.(ico|jpg|jpeg)+($|\?|#).*/))
                          ? (o = "image/x-icon")
                          : (a = e.match(/.*\.(gif|png)+($|\?|#).*/))
                          ? (o = "image/" + a[1])
                          : -1 != e.search(/.*\.(js)+($|\?|#).*/)
                          ? (o = "text/javascript")
                          : (a = e.match(/.*\.(css|html|xml)+($|\?|#).*/))
                          ? (o = "text/" + a[1])
                          : ((e) => {
                              const t = "background.js";
                              let n = Le.getURL(t);
                              return (
                                (n = n.replace(t, "") + "images/"),
                                e.length >= n.length &&
                                  n == e.substr(0, n.length)
                              );
                            })(e) && (o = "image/x-icon")),
                      (s = o),
                      (i = fe(r.response, t.encoding) || "");
                    const c = { ...Xi, content: i, meta: s };
                    n.resolve(c);
                  }
                },
                s = ({ error: e }) => {
                  n.reject({ ...Xi, error: e });
                },
                i = Zn(e);
              if (i)
                if (
                  ["file:"]
                    .concat(Fe.INTERNAL_PAGE_PROTOCOLS)
                    .includes(i.protocol)
                )
                  if (
                    "file:" != i.protocol ||
                    (Te.ALLOWS_FILE_SCHEME_ACCESS &&
                      ["externals", "all"].includes(
                        un.values.script_file_access
                      ))
                  )
                    dt(
                      e,
                      (e) => {
                        r({
                          readyState: 4,
                          status: 0,
                          response: e,
                          statusText: "",
                          responseHeaders: "",
                        });
                      },
                      (e) => {
                        s({ error: e });
                      }
                    );
                  else {
                    const t = "Access to this or all local files is forbidden!";
                    w.warn(
                      "externals:",
                      t,
                      "Loading the following @resource failed:",
                      e,
                      "-> more info:",
                      "https://www.tampermonkey.net/faq.php#Q204"
                    ),
                      s({ error: t });
                  }
                else {
                  const t = {
                    method: "GET",
                    url: e,
                    retries: Oe.RETRIES,
                    nocache: !1,
                    responseType: "arraybuffer",
                  };
                  (t.timeout = un.values.require_timeout),
                    cd.internal(t, {
                      onload: r,
                      onerror: (e) =>
                        s({
                          error:
                            e.responseText || e.statusText || "unknown error",
                        }),
                      ontimeout: () => s({ error: "timed out" }),
                    });
                }
              else s({ error: "unable to parse url" });
              return n.promise();
            })(t, { encoding: r.encoding })
              .done((a) => {
                n && (a.sri = n);
                const l = (n) => {
                  const r = Zn(t);
                  r &&
                    r.protocol &&
                    !["file:"]
                      .concat(Fe.INTERNAL_PAGE_PROTOCOLS)
                      .includes(r.protocol) &&
                    Ji.set(e, t, n);
                };
                n && ["supported", "given"].includes(un.values.require_sri_mode)
                  ? ji
                      .check(n, a.content, r.encoding)
                      .done(() => {
                        (o = a), l(o), s.resolve({ sync: i, resource: o });
                      })
                      .fail((e) => {
                        (o = {
                          ...Xi,
                          forbidden: !0,
                          sri: {
                            mode: un.values.require_sri_mode,
                            type: n.type,
                            value: "invalid",
                          },
                          determined: e,
                        }),
                          l(o),
                          s.reject({ sync: i, resource: o });
                      })
                  : ((o = a), l(o), s.resolve({ sync: i, resource: o }));
              })
              .fail((n) => {
                w.log("externals: get.failed", e, t, n),
                  (o = { ...Xi, error: n.error || "internal error" }),
                  s.reject({ sync: i, resource: o });
              }),
            s.promise()
          );
        },
        eo = (e, t, n) => {
          const r = R(),
            s = Zn(t),
            i = n.sync;
          let o, a;
          return (
            t && s
              ? Wi.getEvilnessOf(t) >= un.values.script_blacklist_severity
                ? ((o = { ...Xi, blacklisted: !0 }),
                  r.reject({ sync: i, resource: o }))
                : ji
                    .getHash(s, "supported" == un.values.require_sri_mode)
                    .done((l) => {
                      if ("enforce" != un.values.require_sri_mode || l)
                        if ("file:" !== s.protocol && (a = Ji.get(e, t))) {
                          const s = Yi(e, t),
                            c = Date.now();
                          un.values.external_update_interval > 0 &&
                            c - a.ts > un.values.external_update_interval &&
                            (Ki.is(s) ||
                              (un.values.external_update_interval > 1 &&
                                Ki.add(s),
                              a.modified
                                ? w.log(
                                    "externals: resource is not updated due to user modifications",
                                    t,
                                    new Date(a.ts).toISOString(),
                                    new Date(c).toISOString()
                                  )
                                : (w.log(
                                    "externals: resource needs update",
                                    t,
                                    new Date(a.ts).toISOString(),
                                    new Date(c).toISOString()
                                  ),
                                  X(() => {
                                    $i(e, t, l, n);
                                  }, 3e3)))),
                            (o = a.data),
                            o.forbidden || o.blacklisted
                              ? r.reject({ sync: i, resource: o })
                              : r.resolve({ sync: i, resource: o });
                        } else r.consume($i(e, t, l, n));
                      else
                        (o = {
                          ...Xi,
                          forbidden: !0,
                          sri: {
                            mode: un.values.require_sri_mode,
                            type: "unsupported",
                            value: "",
                          },
                        }),
                          r.reject({ sync: i, resource: o });
                    })
              : ((o = { ...Xi, forbidden: !0 }),
                r.reject({ sync: i, resource: o })),
            r.promise()
          );
        },
        to = {
          setElement: (e, t, n, r) => {
            const { lastModified: s, ...i } = n;
            return Ji.set(e, t, i, r, s);
          },
          getElement: (e, t) => Ji.get(e, t),
          cleanElement: (e, t) => Ji.clean(e, t),
          dropAll: (e) => (Ji.cleanAll(e), R.Pledge()),
          dropAllBut: (e, t) => (Ji.cleanAll(e, t), R.Pledge()),
          loadResources: (e, t) => {
            const n = R();
            return (
              to.getResources(e, t).always(() => {
                n.resolve();
              }),
              n.promise()
            );
          },
          loadRequires: (e, t) => {
            const n = R();
            return (
              to.getRequires(e, t).always(() => {
                n.resolve();
              }),
              n.promise()
            );
          },
          getResources: (e, t) => {
            const n = R(),
              r = [],
              s = [],
              i = { sync: !0 };
            return (
              t.forEach((t) => {
                const n =
                    t.url ||
                    (t.unsafe_url && Un(t.unsafe_url, t.abs_url)) ||
                    "",
                  o = t.name;
                let a, l, c;
                const u = R();
                eo(e, n, i)
                  .done((e) => {
                    const t = e.resource;
                    (a = t.content), (l = t.meta || "application");
                  })
                  .fail((e) => {
                    if (e.resource) {
                      const {
                        forbidden: n,
                        sri: r,
                        blacklisted: s,
                        error: i,
                      } = e.resource;
                      n
                        ? (c = r
                            ? `can't load @resource '${t.name}' from URL '${t.unsafe_url}' due to a SRI error`
                            : `can't load @resource '${t.name}' from forbidden URL '${t.unsafe_url}'`)
                        : s
                        ? (c = `can't load @resource '${t.name}' from blacklisted URL '${t.unsafe_url}'`)
                        : i &&
                          (c = `can't load @resource '${t.name}' from URL '${t.unsafe_url}': ${i}`);
                    }
                    c ||
                      (c = `can't load @resource '${t.name}' from URL '${t.unsafe_url}'`),
                      w.warn("externals: " + c);
                  })
                  .always((e) => {
                    (i.sync = i.sync && (!e || e.sync)),
                      r.push({
                        name: o,
                        url: n,
                        error: c,
                        content: a,
                        meta: l,
                      }),
                      u.resolve();
                  }),
                  s.push(u.promise());
              }),
              R.when(s).always(() => {
                n.resolve({ elements: r, sync: i.sync });
              }),
              n.promise()
            );
          },
          getRequires: (e, t) => {
            const n = [],
              r = R(),
              s = [],
              i = { encoding: "UTF-8", sync: !0 };
            return (
              t.forEach((t, r) => {
                const o =
                  t.url || (t.unsafe_url && Un(t.unsafe_url, t.abs_url)) || "";
                let a = "";
                const l = R();
                eo(e, o, i)
                  .done((e) => {
                    a = e.resource.content || "";
                  })
                  .fail((e) => {
                    let n;
                    if (e.resource) {
                      const {
                        forbidden: r,
                        sri: s,
                        blacklisted: i,
                        error: o,
                      } = e.resource;
                      r
                        ? (n = s
                            ? `couldn't load @require from URL '${t.unsafe_url}' due to a SRI error`
                            : `couldn't load @require from forbidden URL '${t.unsafe_url}'`)
                        : i
                        ? (n = `couldn't load @require from blacklisted URL '${t.unsafe_url}'`)
                        : o &&
                          (n = `couldn't load @require from URL '${t.unsafe_url}': ${o}`);
                    }
                    n ||
                      (n = `couldn't load @require from URL '${t.unsafe_url}'`),
                      (a =
                        ((e) =>
                          'console.warn("@require: " + decodeURIComponent("' +
                          z(e) +
                          '"));')(n) + "\n"),
                      w.warn("externals: " + n);
                  })
                  .always((e) => {
                    (i.sync = i.sync && (!e || e.sync)),
                      (n[r] = { textContent: a }),
                      l.resolve();
                  }),
                  s.push(l.promise());
              }),
              R.when(s).always(() => {
                r.resolve({ elements: n.filter((e) => e), sync: i.sync });
              }),
              r.promise()
            );
          },
        },
        no = to;
      let ro;
      const so = I({ threads: 1 }),
        io = (e, t) => {
          const n = (e ? e.split("/") : []).concat(t ? [t] : []).join("/");
          return n ? ("/" == n.substr(0, 1) ? "" : "/") + n : "";
        };
      let oo = () => ({
        get: () => R.Breach(),
        set: () => R.Breach(),
        delete: () => R.Breach(),
        clear: () => R.Breach(),
      });
      const ao = (e) => {
          const t = (e.match(/[\dA-F]{2}/gi) || []).map((e) => parseInt(e, 16));
          return new Uint8Array(t).buffer;
        },
        lo = (e) => {
          const t = {
            type: e,
            request: (e) => {
              const t = () => {
                const t = R(),
                  n = (e) => {
                    w.log("rest service: request failed", e), t.reject(e);
                  },
                  r = Object.assign({}, e),
                  s = "xml" === r.responseType,
                  i = "headers" === r.responseType;
                return (
                  (s || i) && delete r.responseType,
                  HA(
                    r,
                    {
                      onload: (e) => {
                        if ([200, 201, 204, 207].includes(e.status)) {
                          let n;
                          if (s) {
                            if (!ee) throw "not supported";
                            n =
                              r.anonymous || r.fetch || null === e.responseXML
                                ? new ee().parseFromString(
                                    e.responseText || "",
                                    "text/xml"
                                  )
                                : e.responseXML;
                          } else n = i ? qA(e.responseHeaders) : e.response;
                          t.resolve({ result: n });
                        } else n(e);
                      },
                      onerror: n,
                      ontimeout: () => n("timed out"),
                      onprogress: (e) => t.notify(e),
                      onuploadprogress: (e) => t.notify(e),
                    },
                    { internal: !0 }
                  ),
                  t.promise()
                );
              };
              return e.no_queue ? t() : so.add(t);
            },
            error: (t) => {
              const n = t;
              let r;
              if (void 0 !== n.status) {
                r = n.status.toString();
                try {
                  r = r + " | " + n.responseText;
                } catch (e) {}
              } else r = t;
              gr(e, "error", "request: " + r);
            },
            wait:
              (e) =>
              (...t) =>
                e(...t).then(
                  (e) => e,
                  (e) =>
                    ((e) =>
                      R.Breach(e ? e.responseText || e.statusText : void 0))(e)
                ),
            changes: (() => {
              let e;
              return {
                listen: () => (
                  e || ((e = R()), t.watch && t.watch.start()), e.promise()
                ),
                notify: (t) => {
                  e.notify(t);
                },
                stop: () => (t.watch && t.watch.stop(), R.Pledge()),
              };
            })(),
          };
          return t;
        },
        co = (e) => {
          const t = Object.assign({}, e),
            n = t.type;
          if (void 0 === n) throw new Error("Internal error");
          let r,
            s,
            i = [];
          const o = (e) => {
              const t = {
                client_id: u.config.client_id,
                redirect_uri: u.config.redirect_uri,
                state: s,
                scope: u.config.scope,
                refresh_token: e,
              };
              return u.config.redirect_uri + "?" + Dn(t);
            },
            a = (e) => {
              let t, n;
              if (
                e &&
                0 === e.indexOf(u.config.redirect_uri) &&
                (n = Zn(e)) &&
                ("string" != typeof (r = n) &&
                  (r = r.search
                    ? r.search.substring(1)
                    : r.hash
                    ? r.hash.substring(1)
                    : ""),
                (t = r.split("&").reduce((e, t) => {
                  const n = t.split("=");
                  return (e[V(n[0])] = V(n[1])), e;
                }, {}))) &&
                (t.access_token || t.error) &&
                t.state === s
              )
                return {
                  uid: t.uid,
                  access_token: t.access_token,
                  refresh_token: t.refresh_token,
                  error: t.error,
                };
              var r;
            };
          let l;
          const c = {};
          Object.defineProperty(c, "credentials", {
            get: () => (l || (l = oo(e.type)), l),
            enumerable: !1,
          });
          const u = Object.assign(c, e, {
            ...t,
            config: { ...t.config, auth_prefix: "Bearer" },
            request: (e) =>
              R(async ({ resolve: t }) => {
                if (!e.no_auth) {
                  const t = (await u.credentials.get()).access_token;
                  if (!t) return R.Breach("Authentication failed");
                  (e.headers = e.headers || {}),
                    (e.headers.Authorization = u.config.auth_prefix + " " + t);
                }
                t();
              })
                .promise()
                .then(() => t.request(e)),
            oauth: (() => {
              const e = {
                run: () => {
                  if (r) return r;
                  let e = R();
                  const t = (r = e.promise());
                  s = "!!" + n + "-" + Xt();
                  const { redirect_uri: i, refresh_supported: l } = u.config,
                    c = void 0,
                    A = async (t, n) => {
                      const r = e;
                      (e = void 0),
                        await u.credentials.set(n),
                        null == r || r.resolve(),
                        t && t.close();
                    },
                    d = (e) =>
                      R(({ resolve: t }) => {
                        HA(
                          { url: e, responseType: "json" },
                          { ondone: (e) => t(e) }
                        );
                      }).promise();
                  return (
                    u.credentials
                      .get()
                      .then(async (e) => {
                        const t = e.refresh_token;
                        if (l && t) {
                          let e,
                            r = 1e3,
                            s = 4;
                          const i = [
                              200, 400, 401, 403, 404, 405, 406, 408, 412,
                            ],
                            a = o(t);
                          for (; !e; )
                            (e = await d(a)),
                              (e && i.includes(e.status)) ||
                                !(--s >= 0) ||
                                (await x(r),
                                (r = Math.min(3 * r, 36e5)),
                                (e = void 0));
                          if (200 == e.status) {
                            const t = e.response;
                            if (t) {
                              if (!t.error && t.access_token) {
                                const {
                                  access_token: e,
                                  refresh_token: n,
                                  basic_auth: r,
                                  uid: s,
                                } = t;
                                return void A(null, {
                                  access_token: e,
                                  refresh_token: n,
                                  basic_auth: r,
                                  uid: s,
                                });
                              }
                              gr(
                                n,
                                "error",
                                "auth refresh token use: " +
                                  (t.error || "!access_token")
                              );
                            }
                          } else
                            gr(
                              n,
                              "error",
                              `auth refresh token use failed with status ${e.status}`
                            );
                        }
                      })
                      .then(() => {
                        if (!e) return;
                        if (!l) return R.Pledge();
                        const t = R(),
                          r = ro({ url: o(), filter: c });
                        return (
                          r.promise
                            .progress((t) => {
                              let s;
                              e &&
                                (s = a(t.url)) &&
                                (s.error || !s.access_token
                                  ? (gr(
                                      n,
                                      "error",
                                      "auth refresh: " +
                                        (s.error || "!access_token")
                                    ),
                                    (u.config.refresh_supported = !1))
                                  : A(r, s));
                            })
                            .always(t.resolve),
                          t.promise()
                        );
                      })
                      .then(() => {
                        if (!e) return;
                        const t = R(),
                          r = ro({
                            url:
                              u.config.request_uri +
                              "?" +
                              Dn({
                                response_type: u.config.response_type,
                                client_id: u.config.client_id,
                                redirect_uri: u.config.redirect_uri,
                                state: s,
                                scope: u.config.scope,
                              }),
                            filter: c,
                          });
                        return (
                          r.promise
                            .progress((t) => {
                              let s;
                              e &&
                                (s = a(t.url)) &&
                                (s.error || !s.access_token
                                  ? gr(
                                      n,
                                      "error",
                                      "auth: " + (s.error || "!access_token")
                                    )
                                  : A(r, s));
                            })
                            .always(t.resolve),
                          t.promise()
                        );
                      })
                      .done(() => {
                        (r = void 0), e && e.reject("auth_failed");
                      }),
                    t
                  );
                },
                revoke: () =>
                  u.credentials.get().then((e) => {
                    const r = e.access_token;
                    return r
                      ? ((s = s || "!!" + n + "-" + Xt()),
                        t
                          .request({
                            method: "GET",
                            retry_auth: !1,
                            url: `${Ao}/revoke?` + Dn({ token: r, state: s }),
                          })
                          .then(
                            () => u.oauth.reset(),
                            () => u.oauth.reset()
                          ))
                      : R.Breach();
                  }),
                reset: () => u.credentials.clear(),
              };
              return e;
            })(),
            wait: (e) =>
              t.wait((...t) =>
                u.credentials.get().then((n) => {
                  if (n.access_token) return e(...t);
                  {
                    const n = R();
                    return (
                      i.push(() => n.consume(e(...t))),
                      u.oauth
                        .run()
                        .done(() => {
                          i.forEach((e) => e()), (i = []);
                        })
                        .fail((e) => {
                          n.reject(e);
                        }),
                      n.promise()
                    );
                  }
                })
              ),
          });
          return u;
        },
        uo = (e) => {
          let t, n, r, s;
          const i = R();
          let o,
            a,
            l,
            c,
            u,
            A = null,
            d = null;
          const h = Object.assign({}, e),
            p = (e) => {
              var t;
              let n;
              return (
                e &&
                  (n = (
                    null === (t = e.firstChild) || void 0 === t
                      ? void 0
                      : t.nextSibling
                  )
                    ? e.firstChild.nextSibling
                    : e.firstChild),
                n
              );
            },
            f = (e) => h.wait((...t) => b.init().then(() => e(...t))),
            m = (e, t) => {
              let n, r;
              if (
                (n = e.getElementsByTagNameNS("*", t)[0]) &&
                (r = n.firstChild)
              )
                return r.nodeValue || void 0;
            },
            g = (e) => {
              const s = [],
                i = e.getElementsByTagNameNS("*", "response");
              for (let e = 0; e < i.length; e++) {
                const o = i[e];
                let a = m(o, "href");
                if (null == a) continue;
                a = a.replace(/\/$/, "");
                const l = o
                    .getElementsByTagNameNS("*", "propstat")[0]
                    .getElementsByTagNameNS("*", "prop")[0],
                  c = m(l, "getlastmodified"),
                  u = m(l, "getetag"),
                  A = parseInt(m(l, "getcontentlength") || ""),
                  d = l
                    .getElementsByTagNameNS("*", "resourcetype")[0]
                    .getElementsByTagNameNS("*", "collection")[0],
                  h = a.replace(
                    new RegExp(
                      "^(" +
                        [jt(n + t) + "/?", jt(r + t) + "/?"].join("|") +
                        ")"
                    ),
                    ""
                  );
                let p;
                try {
                  p = V(h);
                } catch (e) {
                  p = h;
                }
                if (d);
                else {
                  const e = {
                    etag: u,
                    name: p,
                    id: h,
                    modifiedTime: new Date(c || 0).getTime(),
                    size: A >= 0 ? A : void 0,
                    removed: -1 == A,
                  };
                  s.push(e);
                }
              }
              return s;
            },
            v = (e) => m(e, "td:cursor"),
            _ = (e, t) => {
              const n = t || {};
              n.set_current_list && (o = {});
              const r = b
                .request({
                  method: "PROPFIND",
                  url: e,
                  headers: {
                    "Content-Type": "text/xml; charset=UTF-8",
                    Depth: void 0 !== n.depth ? n.depth : 1,
                  },
                  responseType: "xml",
                })
                .then((e) => {
                  const t = e.result;
                  let r;
                  if (null === t || !(r = p(t)) || !r.childNodes)
                    return R.Breach();
                  const s = g(r);
                  if (n.set_current_list) {
                    const e = v(r);
                    e && (a = e),
                      s.forEach((e) => {
                        o[e.id] = e;
                      });
                  }
                  return s;
                });
              return r;
            },
            b = Object.assign(e, {
              ...e,
              config: {
                ...e.config,
                watch_interval: 36e5,
                root: void 0,
                path: void 0,
              },
              request: (e) => (
                (e.headers = e.headers || {}),
                (e.headers["User-Agent"] = "Tampermonkey"),
                (e.anonymous = !0),
                h.request(e).then(
                  (e) => e,
                  (t) => {
                    const n = (null == t ? void 0 : t.status) || -1;
                    return !t || [429, 500].includes(n)
                      ? ((e.backoff = 2 * (e.backoff || 1e3)),
                        x(e.backoff).then(() => b.request(e)))
                      : 404 == n
                      ? R.Pledge(t)
                      : (b.error(t), R.Breach(t));
                  }
                )
              ),
              init: () => {
                if (s) return s;
                (t = io(b.config.root, b.config.path)),
                  (n = b.config.url || ""),
                  "/" == n.slice(-1) && (n = n.slice(0, -1));
                const e = Zn(n);
                if (!e) return R.Breach("invalid url");
                (r = e.pathname), "/" == r.slice(-1) && (r = r.slice(0, -1));
                const o = R(),
                  a = (s = o.promise());
                return (
                  b
                    .request({
                      method: "OPTIONS",
                      url: `${n}/`,
                      responseType: "headers",
                    })
                    .done((e) => {
                      const t = e.result;
                      let n;
                      t &&
                        (n = t["access-control-allow-methods"]) &&
                        n.includes("EDITOR") &&
                        (u = !0);
                    })
                    .always(() => {
                      _(`${n}${t}/`, { depth: 0 })
                        .done(() => {
                          o.resolve(), i.resolve();
                        })
                        .fail(() => {
                          const e = [];
                          R.onebyone(
                            t
                              .split("/")
                              .filter((e) => e)
                              .map((t) => {
                                e.push(t);
                                const r = e.join("/");
                                return () =>
                                  b
                                    .request({
                                      method: "MKCOL",
                                      url: `${n}/${r}/`,
                                      headers: {
                                        "Content-Type":
                                          "text/xml; charset=UTF-8",
                                      },
                                      responseType: "xml",
                                    })
                                    .then(
                                      (e) => e,
                                      (e) => {
                                        if (
                                          405 ==
                                          ((null == e ? void 0 : e.status) ||
                                            -1)
                                        )
                                          return R.Pledge(e);
                                      }
                                    );
                              })
                          )
                            .done(() => {
                              o.resolve(), i.resolve();
                            })
                            .fail(() => {
                              (s = void 0), o.reject();
                            });
                        });
                    }),
                  a
                );
              },
              list: f((e) =>
                _(`${n}${t}/`, { set_current_list: !0 }).then((t) => {
                  const n = {};
                  return t
                    .map((t) => {
                      if (!e) {
                        if (n[t.id]) return;
                        n[t.id] = !0;
                      }
                      return {
                        name: t.name,
                        id: t.id,
                        size: t.size || 0,
                        etag: t.etag,
                        modified: t.modifiedTime,
                        precision: 1e3,
                        removed: t.removed,
                      };
                    })
                    .filter((e) => e);
                })
              ),
              get: f((e) => {
                const r = e.id || e;
                return b
                  .request({
                    method: "GET",
                    url: n + io(t, r),
                    headers: { "Content-Type": "text/xml; charset=UTF-8" },
                    responseType: "arraybuffer",
                  })
                  .then((e) => {
                    const t = e.result;
                    return new Blob([t]);
                  });
              }),
              put: f((e, r, s) => {
                const i = e.id || e;
                let o, a, l;
                const c = { "Content-Type": "application/octet-stream" };
                let u = !1;
                return (
                  s &&
                    s.lastModified &&
                    ((u = null === d),
                    (o = s.lastModified),
                    (l = new Date(s.lastModified).toISOString()),
                    (a = s.lastModified / 1e3),
                    (d || u) && (c["X-OC-Mtime"] = a)),
                  b
                    .request({
                      method: "PUT",
                      url: n + io(t, i),
                      headers: c,
                      data_type: "typified",
                      data: { type: "raw", value: r },
                      responseType: "headers",
                    })
                    .then((e) => {
                      const r = e.result;
                      if (r && u) {
                        let e;
                        d = !(
                          "accepted" != r["x-oc-mtime"] &&
                          (!r.date ||
                            !(e = new Date(r.date).getTime()) ||
                            (e != o && e != Math.floor(a)))
                        );
                      }
                      if (!d && !A && l)
                        return b
                          .request({
                            method: "PROPPATCH",
                            url: n + io(t, i),
                            headers: {
                              "Content-Type": "text/xml; charset=UTF-8",
                            },
                            responseType: "xml",
                            data: [
                              '<?xml version="1.0"?>',
                              '<d:propertyupdate xmlns:d="DAV:">',
                              "<d:set>",
                              "<d:prop>",
                              `<d:getlastmodified>${l}</d:getlastmodified>`,
                              "</d:prop>",
                              "</d:set>",
                              "</d:propertyupdate>",
                            ].join(""),
                          })
                          .then(
                            (e) => {
                              var t;
                              const n = e.result;
                              let r, s, i;
                              n &&
                                (r = n.childNodes[0]) &&
                                (s = r.getElementsByTagNameNS(
                                  "*",
                                  "status"
                                )[0]) &&
                                (i =
                                  null === (t = s.firstChild) || void 0 === t
                                    ? void 0
                                    : t.nodeValue) &&
                                -1 != i.search(/HTTP\/[0-9.]+ 403/) &&
                                (w.warn(
                                  "WebDAV: no way to set file modification date! This might cause redundant up and downloads."
                                ),
                                (A = !0));
                            },
                            () => (
                              w.warn(
                                "WebDAV: no way to set file modification date! This might cause redundant up and downloads."
                              ),
                              (A = !0),
                              R.Pledge()
                            )
                          );
                    })
                );
              }),
              delete: f((e) => {
                const r = e.id || e;
                return b.request({
                  method: "DELETE",
                  url: n + io(t, r),
                  headers: {
                    "Content-Type": "text/xml; charset=UTF-8",
                  },
                });
              }),
              watch: {
                start: () => {
                  if (l) return;
                  let e = 100;
                  const r = (l = Xt());
                  let s = null;
                  const u = () => {
                      if (((c = void 0), l))
                        if (!1 === s) {
                          const e = o;
                          _(`${n}${t}/`, { set_current_list: !0 })
                            .then(() => {
                              e &&
                                (Object.keys(e).forEach((t) => {
                                  const n = o[t],
                                    r = e[t];
                                  n
                                    ? r.modifiedTime != n.modifiedTime &&
                                      h.changes.notify({
                                        time: n.modifiedTime,
                                        name: n.name,
                                        id: n.id,
                                      })
                                    : h.changes.notify({
                                        time: Date.now(),
                                        name: r.name,
                                        id: r.id,
                                        removed: !0,
                                      });
                                }),
                                Object.keys(o).forEach((t) => {
                                  if (!e[t]) {
                                    const e = o[t];
                                    h.changes.notify({
                                      time: e.modifiedTime,
                                      name: e.name,
                                      id: e.id,
                                    });
                                  }
                                }));
                            })
                            .fail((e) => {
                              w.warn("WebDAV: file changes check failed", e);
                            })
                            .always(() => {
                              c = X(u, b.config.watch_interval);
                            });
                        } else
                          ((e, t) => {
                            const n = {
                              "Content-Type": "text/xml; charset=UTF-8",
                              Depth: 1,
                              Timeout: 90,
                            };
                            return (
                              t && (n.Cursor = t),
                              b
                                .request({
                                  method: "SUBSCRIBE",
                                  url: e,
                                  headers: n,
                                  responseType: "xml",
                                  no_queue: !0,
                                })
                                .then((e) => {
                                  const t = e.result;
                                  let n;
                                  return null === t
                                    ? R.Pledge({ changes: [], cursor: a })
                                    : (n = p(t)) && n.childNodes
                                    ? { changes: g(n), cursor: v(n) }
                                    : R.Breach();
                                })
                            );
                          })(`${n}${t}/`, a)
                            .then(
                              (t) => {
                                s = !0;
                                const n = t.changes;
                                (a = t.cursor),
                                  (e = 100),
                                  n.forEach((e) => {
                                    h.changes.notify({
                                      time: e.modifiedTime,
                                      name: e.name,
                                      id: e.id,
                                      removed: e.removed,
                                    });
                                  });
                              },
                              () => {
                                if (null !== s) return (e *= 2), x(e);
                                s = !1;
                              }
                            )
                            .always(u);
                    },
                    A = () => !l || l !== r;
                  i.promise().then(() => {
                    A() || f(() => (A() ? R.Breach() : (u(), R.Pledge())))();
                  });
                },
                stop: () => {
                  (l = void 0), c && (L(c), (c = void 0));
                },
              },
              getRemoteUrl: (e) => {
                if (u) return n + io(t, e) + "?method=editor#bypass=true";
              },
              getRemoteDomains: () => {
                var e;
                return [
                  (
                    (null === (e = Zn(n)) || void 0 === e
                      ? void 0
                      : e.origin) || ""
                  ).replace(/^.*:\/\//, ""),
                ];
              },
            });
          return b;
        },
        Ao = "https://accounts.tampermonkey.net/e/oauth2/v1",
        ho = {
          drive: () => {
            let e;
            (ae && (e = parseInt(ae.getItem("gdrive_poll_interval") || ""))) ||
              (e = 18e5);
            const t = co(lo("drive")),
              n = Object.assign({}, t),
              r = "appDataFolder";
            let s, i;
            const o = Object.assign(t, {
              ...t,
              config: {
                ...t.config,
                redirect_uri: `${Ao}/auth`,
                refresh_supported: !0,
                request_uri: "https://accounts.google.com/o/oauth2/v2/auth",
                client_id:
                  "408438522028-3cgn3t3jas3fak7isbnfod1q4h15g2fv.apps.googleusercontent.com",
                scope: "https://www.googleapis.com/auth/drive.appdata",
                response_type: "token",
                watch_interval: e,
              },
              request: (e) =>
                n.request(e).then(
                  (e) => e,
                  (t) => {
                    const n = (null == t ? void 0 : t.status) || -1;
                    return !t || [403, 429, 500].includes(n)
                      ? ((e.backoff = 2 * (e.backoff || 1e3)),
                        x(e.backoff).then(() => o.request(e)))
                      : [400, 401].includes(n)
                      ? (w.warn("Google Drive: authentication error", t),
                        o.credentials.delete("access_token").then(() => {
                          if (!e.retry_auth)
                            return (
                              (e.retry_auth = !0),
                              o.oauth
                                .run()
                                .fail((e) => o.error(e))
                                .then(() => o.request(e))
                            );
                        }))
                      : 404 == n
                      ? R.Pledge(t)
                      : (o.error(t), R.Breach(t));
                  }
                ),
              list: n.wait((e) => {
                let t = [];
                const n = R(),
                  s = (e) =>
                    "https://www.googleapis.com/drive/v3/files?" +
                    Dn({
                      spaces: r,
                      pageToken: e,
                      orderBy: "modifiedTime desc",
                      fields:
                        "nextPageToken, files(id, size, name, modifiedTime, md5Checksum)",
                      pageSize: 500,
                    }),
                  i = (e) => {
                    o.request({
                      method: "GET",
                      url: e,
                      headers: { "Content-Type": "application/json" },
                    }).then((e) => {
                      const r = e.result,
                        o = r ? JSON.parse(r) : { files: [] };
                      if (((t = t.concat(o.files)), o.nextPageToken))
                        return i(s(o.nextPageToken));
                      n.resolve(t);
                    });
                  };
                return (
                  i(s()),
                  n.promise().then((t) => {
                    const n = {};
                    return t
                      .map((t) => {
                        if (!e) {
                          if (n[t.name]) return;
                          n[t.name] = !0;
                        }
                        return {
                          name: t.name,
                          size: t.size || 0,
                          id: t.id,
                          md5: t.md5Checksum,
                          modified: new Date(t.modifiedTime).getTime(),
                        };
                      })
                      .filter((e) => e);
                  })
                );
              }),
              get: n.wait((e) => {
                const t = e.id || e;
                return o
                  .request({
                    method: "GET",
                    url:
                      "https://www.googleapis.com/drive/v3/files/" +
                      t +
                      "?" +
                      Dn({ spaces: r, alt: "media" }),
                    responseType: "arraybuffer",
                  })
                  .then((e) => {
                    const t = e.result;
                    return new Blob([t]);
                  });
              }),
              put: n.wait((e, t, n) => {
                const s = e,
                  i = s.name || e,
                  a = s.id,
                  l = Xt();
                return R.Pledge()
                  .then(() => {
                    if (t) return be(t);
                  })
                  .then((e) => {
                    const t =
                        n && n.lastModified
                          ? new Date(n.lastModified).toISOString()
                          : void 0,
                      s = [];
                    return (
                      s.push("--" + l),
                      s.push("Content-Type: application/json"),
                      s.push(""),
                      s.push(
                        JSON.stringify({
                          name: i,
                          parents: a ? void 0 : [r],
                          modifiedTime: t,
                        })
                      ),
                      s.push("--" + l),
                      e &&
                        (s.push("Content-Type: application/octet-stream"),
                        s.push("Content-Transfer-Encoding: base64"),
                        s.push(""),
                        s.push(he(e)),
                        s.push("--" + l + "--")),
                      s.push(""),
                      o.request({
                        method: a || !e ? "PATCH" : "POST",
                        url:
                          "https://www.googleapis.com/" +
                          (e ? "upload/" : "") +
                          "drive/v3/files" +
                          (a ? "/" + a : "") +
                          "?" +
                          Dn({ uploadType: "multipart" }),
                        headers: {
                          "Content-Type": "multipart/related; boundary=" + l,
                        },
                        data: s.join("\r\n"),
                      })
                    );
                  });
              }),
              delete: n.wait((e) => {
                const t = e.id || e;
                return o.request({
                  method: "DELETE",
                  url:
                    "https://www.googleapis.com/drive/v3/files/" +
                    t +
                    "?" +
                    Dn({ spaces: r }),
                  headers: { "Content-Type": "application/json" },
                });
              }),
              revoke: () => o.oauth.revoke(),
              compare: (e, t) => {
                const n = R();
                let r;
                return (
                  (r = e.md5) && r == ve(t, "utf-8")
                    ? n.resolve(!0)
                    : n.resolve(!1),
                  n.promise()
                );
              },
              watch: {
                start: () => {
                  if (s) return;
                  let e;
                  s = !0;
                  const t = () => {
                    (i = null),
                      s &&
                        o
                          .request({
                            method: "GET",
                            url:
                              "https://www.googleapis.com/drive/v3/changes/?" +
                              Dn({
                                pageToken: e,
                                spaces: r,
                                pageSize: 1e3,
                                includeRemoved: !0,
                              }),
                            headers: { "Content-Type": "application/json" },
                          })
                          .then((t) => {
                            const n = t.result;
                            if (!s) return R.Breach();
                            const r = n ? JSON.parse(n) : {};
                            if (!(e = r.newStartPageToken))
                              return (
                                w.warn("Google Drive: watch token error", n),
                                o.watch.stop()
                              );
                            r.nextPageToken &&
                              w.warn("Google Drive: too much changes", n),
                              (r.changes || []).forEach((e) => {
                                let t;
                                const n = e.file;
                                "file" === e.type &&
                                  n &&
                                  ((t = Date.parse(e.time)),
                                  isNaN(t) && (t = Date.now()),
                                  o.changes.notify({
                                    id: n.id,
                                    time: t,
                                    name: n.name,
                                    removed: e.removed,
                                  }));
                              });
                          })
                          .fail((e) => {
                            w.warn(
                              "Google Drive: file changes check failed",
                              e
                            );
                          })
                          .always(() => {
                            i = X(t, o.config.watch_interval);
                          });
                  };
                  n.wait(() =>
                    s
                      ? o
                          .request({
                            method: "GET",
                            url: "https://www.googleapis.com/drive/v3/changes/startPageToken",
                            headers: { "Content-Type": "application/json" },
                          })
                          .then((n) => {
                            const r = n.result,
                              s = r ? JSON.parse(r) : {};
                            if (!(e = s.startPageToken))
                              return (
                                w.warn("Google Drive: watch token error", r),
                                o.watch.stop()
                              );
                            t();
                          })
                      : R.Breach()
                  )();
                },
                stop: () => {
                  (s = !1), i && (L(i), (i = null));
                },
              },
              getRemoteUrl: void 0,
            });
            return o;
          },
          dropbox: (e) => {
            const t = e.path || "";
            let n;
            (ae && (n = parseInt(ae.getItem("dropbox_poll_interval") || ""))) ||
              (n = 18e5);
            const r = co(lo("dropbox")),
              s = Object.assign({}, r);
            let i,
              o,
              a,
              l,
              c = !0;
            const u = (e) => {
                let n = [];
                const r = R(),
                  s = (e) => {
                    A.request({
                      method: "POST",
                      url:
                        "https://api.dropboxapi.com/2/files/list_folder" +
                        (e ? "/continue" : ""),
                      headers: { "Content-Type": "application/json" },
                      data: { path: e ? void 0 : io(t), cursor: e },
                    })
                      .then((e) => {
                        const t = e.result,
                          i = t ? JSON.parse(t) : { entries: [] };
                        if (((n = n.concat(i.entries)), i.has_more && i.cursor))
                          return s(i.cursor);
                        r.resolve({ list: n, cursor: i.cursor });
                      })
                      .fail(r.reject);
                  };
                return (
                  c
                    ? ((c = !1),
                      A.put(".version", new Blob([po]))
                        .then(() => {
                          s(e);
                        })
                        .fail(r.reject))
                    : s(e),
                  r.promise()
                );
              },
              A = Object.assign(r, {
                ...r,
                config: {
                  ...r.config,
                  redirect_uri: `${Ao}/auth`,
                  request_uri: "https://www.dropbox.com/oauth2/authorize",
                  client_id: "gq3auc9yym0e21y",
                  response_type: "token",
                  watch_interval: n ? Number(n) : 0,
                },
                request: (e) =>
                  s.request(e).then(
                    (e) => e,
                    (t) => {
                      const n = (null == t ? void 0 : t.status) || -1;
                      return !t || [500, 429].includes(n)
                        ? ((e.backoff = 2 * (e.backoff || 1e3)),
                          x(e.backoff).then(() => A.request(e)))
                        : [401].includes(n)
                        ? (w.warn("Dropbox: authentication error", t),
                          A.credentials.delete("access_token").then(() => {
                            if (!e.retry_auth)
                              return (
                                (e.retry_auth = !0),
                                A.oauth
                                  .run()
                                  .fail((e) => A.error(e))
                                  .then(() => A.request(e))
                              );
                          }))
                        : (A.error(t), R.Breach(t));
                    }
                  ),
                list: s.wait((e) =>
                  u()
                    .then((t) => {
                      const n = {};
                      return (
                        (o = t.cursor),
                        t.list
                          .map((t) => {
                            if (!e) {
                              if (n[t.name]) return;
                              n[t.name] = !0;
                            }
                            return {
                              name: t.name,
                              size: t.size,
                              dropbox_hash: t.content_hash,
                              modified: new Date(t.client_modified).getTime(),
                              precision: 1e3,
                            };
                          })
                          .filter((e) => e)
                      );
                    })
                    .always(() => {
                      i && o && (i(), (i = null));
                    })
                ),
                get: s.wait((e) => {
                  const n = e.name || e;
                  return A.request({
                    method: "POST",
                    url: "https://content.dropboxapi.com/2/files/download",
                    headers: {
                      "Dropbox-API-Arg": JSON.stringify({ path: io(t, n) }),
                    },
                    responseType: "arraybuffer",
                  }).then((e) => {
                    const t = e.result;
                    return new Blob([t]);
                  });
                }),
                put: s.wait((e, n, r) => {
                  const s = e.name || e,
                    i =
                      r && r.lastModified
                        ? (new Date(r.lastModified)
                            .toISOString()
                            .match(/[^:]*:[^:]*:[^:.a-zA_Z]*/) || "")[0] + "Z"
                        : void 0;
                  return A.request({
                    method: "POST",
                    url: "https://content.dropboxapi.com/2/files/upload",
                    headers: {
                      "Dropbox-API-Arg": JSON.stringify({
                        path: io(t, s),
                        client_modified: i,
                        mode: "overwrite",
                      }),
                      "Content-Type": "application/octet-stream",
                    },
                    data_type: "typified",
                    data: { type: "raw", value: n },
                  });
                }),
                delete: s.wait((e) => {
                  const n = e.name || e;
                  return A.request({
                    method: "POST",
                    url: "https://api.dropboxapi.com/2/files/delete",
                    headers: { "Content-Type": "application/json" },
                    data: { path: io(t, n) },
                  });
                }),
                revoke: () =>
                  A.credentials
                    .get()
                    .then((e) =>
                      e.access_token
                        ? s
                            .request({
                              method: "POST",
                              url: "https://api.dropboxapi.com/2/auth/token/revoke",
                            })
                            .always(() => A.oauth.reset())
                        : R.Breach()
                    ),
                compare: (e, t) => {
                  const n = R(),
                    r = 4194304,
                    s = me(t, { encoding: "utf-8" }),
                    i = [],
                    o = s.byteLength;
                  let a = 1;
                  const l = async () => {
                    if (0 == --a) {
                      let t = new ArrayBuffer(0);
                      i.forEach((e) => {
                        e &&
                          (t = ((e, t) => {
                            const n = new Uint8Array(
                              e.byteLength + t.byteLength
                            );
                            return (
                              n.set(new Uint8Array(e), 0),
                              n.set(new Uint8Array(t), e.byteLength),
                              n.buffer
                            );
                          })(t, e));
                      });
                      const r = await ge(t),
                        s = Oi(r, "ASCII");
                      n.resolve(s == e.dropbox_hash);
                    }
                  };
                  for (let e = 0, t = 0; t < o; t += r, e++)
                    ((e) => {
                      i.push(null),
                        a++,
                        ge(s.slice(t, t + Math.min(r, o - t))).then(
                          (t) => {
                            const n = Oi(t, "ASCII");
                            (i[e] = ao(n)), l();
                          },
                          () => {
                            w.warn(
                              "Dropbox: unable to calculate SHA-256 hashes"
                            ),
                              n.reject();
                          }
                        );
                    })(e);
                  return l(), n.promise();
                },
                watch: {
                  start: () => {
                    if (a) return;
                    a = !0;
                    let e = 0;
                    const t = () => {
                      if (((l = null), (e = 0), a))
                        return o
                          ? void A.request({
                              method: "POST",
                              url: "https://notify.dropboxapi.com/2/files/list_folder/longpoll",
                              headers: { "Content-Type": "application/json" },
                              no_auth: !0,
                              no_queue: !0,
                              data: { cursor: o, timeout: 180 },
                            })
                              .then((t) => {
                                const n = t.result;
                                if (!a) return R.Breach();
                                const r = n ? JSON.parse(n) : {};
                                return (
                                  r.backoff && (e = 1e3 * r.backoff),
                                  r.changes
                                    ? x(6e4)
                                        .then(() => u(o))
                                        .then((e) =>
                                          (o = e.cursor)
                                            ? e.list
                                            : (w.warn(
                                                "Dropbox: watch token error",
                                                n
                                              ),
                                              A.watch.stop())
                                        )
                                    : null
                                );
                              })
                              .then((e) => {
                                e &&
                                  e.forEach((e) => {
                                    let t;
                                    const n = e[".tag"];
                                    ["file", "deleted"].includes(n) &&
                                      ((t = Date.parse(e.server_modified)),
                                      A.changes.notify({
                                        id: e.id,
                                        time: t,
                                        name: e.name,
                                        removed: "deleted" == n,
                                      }));
                                  });
                              })
                              .fail((e) => {
                                w.warn("Dropbox: file changes check failed", e);
                              })
                              .always(() => {
                                l = X(t, e + A.config.watch_interval);
                              })
                          : (w.warn("Dropbox: watch token error", o),
                            A.watch.stop());
                    };
                    s.wait(() =>
                      a ? (o ? t() : (i = t), R.Pledge()) : R.Breach()
                    )();
                  },
                  stop: () => {
                    (a = !1), l && (L(l), (l = null));
                  },
                },
                getRemoteDomains: () => ["dropbox.com", "dropboxapi.com"],
                getRemoteUrl: void 0,
              });
            return A;
          },
          onedrive: (e) => {
            const t = e.path || "";
            let n, r;
            n = 18e5;
            const s = co(lo("onedrive")),
              i = Object.assign({}, s);
            let o, a;
            const l = (e) => {
                const n = R();
                let s = [];
                const i = (o) => {
                  c.request({
                    method: "GET",
                    url:
                      o ||
                      "https://api.onedrive.com/v1.0/drive/special/approot:" +
                        io(t) +
                        ":/children",
                    headers: { "Content-Type": "application/json" },
                  })
                    .then((t) => {
                      const o = t.result,
                        a = o ? JSON.parse(o) : { value: [] };
                      if (
                        ((s = s.concat(
                          a.value.map((e) => {
                            var t, n, r;
                            const s =
                                (null ===
                                  (t = null == e ? void 0 : e.fileSystemInfo) ||
                                void 0 === t
                                  ? void 0
                                  : t.lastModifiedDateTime) || 0,
                              i =
                                (null ===
                                  (r =
                                    null ===
                                      (n = null == e ? void 0 : e.file) ||
                                    void 0 === n
                                      ? void 0
                                      : n.hashes) || void 0 === r
                                  ? void 0
                                  : r.sha1Hash) || void 0;
                            return {
                              id: e.id,
                              name: e.name,
                              size: e.size,
                              sha1: i,
                              modified: new Date(s).getTime(),
                            };
                          })
                        )),
                        a["@odata.nextLink"])
                      )
                        return i(a["@odata.nextLink"]);
                      e.set_current_list && (r = s), n.resolve(s);
                    })
                    .fail((e) => n.reject(e));
                };
                return i(), n.promise();
              },
              c = Object.assign(s, {
                ...s,
                config: {
                  ...s.config,
                  redirect_uri: `${Ao}/auth`,
                  refresh_supported: !0,
                  request_uri: "https://login.live.com/oauth20_authorize.srf",
                  client_id: "000000004C1A3122",
                  response_type: "token",
                  scope: "onedrive.appfolder",
                  watch_interval: 18e5,
                },
                request: (e) =>
                  i.request(e).then(
                    (e) => e,
                    (t) => {
                      const n = (null == t ? void 0 : t.status) || -1;
                      return !t || [429, 500].includes(n)
                        ? ((e.backoff = 2 * (e.backoff || 1e3)),
                          x(e.backoff).then(() => c.request(e)))
                        : [401, 403].includes(n)
                        ? (w.warn("OneDrive: authentication error", t),
                          c.credentials.delete("access_token").then(() => {
                            if (!e.retry_auth)
                              return (
                                (e.retry_auth = !0),
                                c.oauth
                                  .run()
                                  .fail((e) => c.error(e))
                                  .then(() => c.request(e))
                              );
                          }))
                        : 404 == n
                        ? R.Pledge(t)
                        : (c.error(t), R.Breach(t));
                    }
                  ),
                list: i.wait(() => l({ set_current_list: !0 })),
                get: i.wait((e) => {
                  const n = e.name || e;
                  return c
                    .request({
                      method: "GET",
                      url:
                        "https://api.onedrive.com/v1.0/drive/special/approot:" +
                        io(t, z(n)) +
                        ":/content",
                      responseType: "arraybuffer",
                    })
                    .then((e) => {
                      const t = e.result;
                      return new Blob([t]);
                    });
                }),
                put: i.wait((e, n, r) => {
                  const s = e.name || e,
                    i = z(s.replace(/[#%<>:"|?*/\\]/g, "-"));
                  return c
                    .request({
                      method: "PUT",
                      url:
                        "https://api.onedrive.com/v1.0/drive/special/approot:" +
                        io(t, i) +
                        ":/content",
                      headers: { "Content-Type": "application/octet-stream" },
                      data_type: "typified",
                      data: { type: "raw", value: n },
                    })
                    .then((e) => {
                      const t =
                        r && r.lastModified
                          ? new Date(r.lastModified).toISOString()
                          : void 0;
                      if (!t) return e;
                      const n = e.result,
                        s = JSON.parse(n);
                      return c.request({
                        method: "PATCH",
                        url:
                          "https://api.onedrive.com/v1.0/drive/items/" + s.id,
                        headers: {
                          "Content-Type": "application/json",
                        },
                        data: JSON.stringify({
                          fileSystemInfo: { lastModifiedDateTime: t },
                        }),
                      });
                    });
                }),
                delete: i.wait((e) => {
                  const n = e.name || e;
                  return c.request({
                    method: "DELETE",
                    url:
                      "https://api.onedrive.com/v1.0/drive/special/approot:" +
                      io(t, z(n)),
                  });
                }),
                revoke: () => c.oauth.revoke(),
                watch: {
                  start: () => {
                    if (o) return;
                    o = !0;
                    const e = () => {
                      if (((a = null), !o)) return;
                      const t = r;
                      l({ set_current_list: !0 })
                        .then(() => {
                          if (!t) return;
                          const e = {},
                            n = {};
                          r.forEach((t) => {
                            e[t.id] = t;
                          }),
                            t.forEach((e) => {
                              n[e.id] = e;
                            }),
                            Object.keys(n).forEach((t) => {
                              const r = e[t],
                                s = n[t];
                              r
                                ? s.modified != r.modified &&
                                  c.changes.notify({
                                    time: r.modified,
                                    name: r.name,
                                  })
                                : c.changes.notify({
                                    time: Date.now(),
                                    name: s.name,
                                    removed: !0,
                                  });
                            }),
                            Object.keys(e).forEach((t) => {
                              if (!n[t]) {
                                const n = e[t];
                                c.changes.notify({
                                  time: n.modified,
                                  name: n.name,
                                });
                              }
                            });
                        })
                        .fail((e) => {
                          w.warn("OneDrive: file changes check failed", e);
                        })
                        .always(() => {
                          a = X(e, c.config.watch_interval);
                        });
                    };
                    i.wait(() => (o ? (e(), R.Pledge()) : R.Breach()))();
                  },
                  stop: () => {
                    (o = !1), a && (L(a), (a = null));
                  },
                },
                getRemoteDomains: () => ["onedrive.live.com"],
                getRemoteUrl: void 0,
              });
            return c;
          },
          yandex: () => {
            let e;
            e = 18e5;
            const t = co(lo("yandex")),
              n = uo(t),
              r = Object.assign({}, n);
            let s;
            const i = Object.assign(n, {
              ...t,
              ...n,
              config: {
                ...n.config,
                root: "/Programs/Tampermonkey",
                url: "https://webdav.yandex.ru",
                redirect_uri: `${Ao}/auth`,
                refresh_supported: !0,
                request_uri: "https://oauth.yandex.com/authorize",
                client_id: "a591fcd2ccd248f0baa84222898065f4",
                response_type: "token",
                auth_prefix: "OAuth",
                watch_interval: 18e5,
              },
              init: () => {
                if (s) return s;
                const e = R();
                return (
                  (s = e.promise()),
                  i
                    .request({
                      method: "GET",
                      url: "https://cloud-api.yandex.net/v1/disk/",
                    })
                    .done((e) => {
                      const t = e.result,
                        n = t ? JSON.parse(t) : {};
                      n.total_space &&
                        n.used_space &&
                        (n.used_space + 5e7 > n.total_space
                          ? w.warn(
                              "Yandex: low disk space warning, only " +
                                (n.total_space - n.used_space) +
                                " bytes available"
                            )
                          : w.log(
                              "Yandex: " +
                                (n.total_space - n.used_space) +
                                " bytes on disk available!"
                            ));
                    })
                    .always(() => {
                      e.consume(r.init());
                    }),
                  s
                );
              },
              getRemoteDomains: () => ["disk.yandex.com"],
              getRemoteUrl: void 0,
              list: (e) =>
                r.list(e).then((e) => e.map((e) => ((e.md5 = e.etag), e))),
              request: (e) =>
                (() => {
                  const t = (e.headers = e.headers || {});
                  if (
                    ((t["X-Requested-With"] = "XMLHttpRequest"),
                    "PUT" == e.method &&
                      e.data &&
                      "raw" == e.data.type &&
                      e.data.value)
                  ) {
                    const n = R();
                    return (
                      be(e.data.value)
                        .then((e) => {
                          (t.Etag = ve(e)), (t.Sha256 = Oi(e, "ASCII"));
                        })
                        .always(n.resolve),
                      n.promise()
                    );
                  }
                  return R.Pledge();
                })()
                  .then(() => r.request(e))
                  .then(
                    (e) => e,
                    (t) => {
                      const n = (null == t ? void 0 : t.status) || -1;
                      return [401].includes(n)
                        ? (w.warn("Yandex: authentication error", t),
                          i.credentials.delete("access_token").then(() => {
                            if (!e.retry_auth)
                              return (
                                (e.retry_auth = !0),
                                i.oauth
                                  .run()
                                  .fail((e) => i.error(e))
                                  .then(() => r.request(e))
                              );
                          }))
                        : t;
                    }
                  ),
              compare: (e, t) => {
                const n = R();
                let r;
                return (
                  (r = e.md5) && r == ve(t, "utf-8")
                    ? n.resolve(!0)
                    : n.resolve(!1),
                  n.promise()
                );
              },
              revoke: () => i.oauth.revoke(),
            });
            return i;
          },
          webdav: (e) => {
            let t;
            t = 18e5;
            const n = e.url;
            if (n) {
              const t = n.toLowerCase();
              t.startsWith("webdav")
                ? (e.url = n.replace(/^webdav/i, "http"))
                : t.startsWith("http") || (e.url = `http://${n}`);
            }
            const r = uo(
              ((e) => {
                const t = Object.assign({}, e);
                if (void 0 === t.type) throw new Error("Internal error");
                const n = Object.assign(e, {
                  ...t,
                  config: { ...t.config },
                  credentials: {
                    get: () => R.Pledge({ basic_auth: n.config.basic_auth }),
                    set: () => R.Breach(),
                    delete: (e) =>
                      R(({ resolve: t, reject: r }) => {
                        if ("basic_auth" !== e) return r();
                        delete n.config[e], t();
                      }).promise(),
                    clear: () => R.Breach(),
                  },
                  request: (e) =>
                    R(async ({ resolve: t }) => {
                      if (!e.no_auth) {
                        const t = (await n.credentials.get()).basic_auth;
                        if (!t) return R.Breach("Authentication failed");
                        (e.headers = e.headers || {}),
                          (e.headers.Authorization = "Basic " + t);
                      }
                      t();
                    })
                      .promise()
                      .then(() => t.request(e))
                      .then(
                        (e) => e,
                        (t) => {
                          if (!e.no_auth) {
                            const e = (null == t ? void 0 : t.status) || -1;
                            [401].includes(e) &&
                              (w.warn("basic auth: authentication error", t),
                              n.credentials.delete("basic_auth"));
                          }
                          return t;
                        }
                      ),
                  wait: (e) => t.wait((...t) => e(...t)),
                });
                return n;
              })(lo("webdav"))
            );
            return Object.assign(r, {
              ...r,
              config: {
                ...r.config,
                root: "Tampermonkey",
                watch_interval: 18e5,
                ...e,
              },
            });
          },
        };
      let po;
      const fo = Object.keys(ho),
        mo = new Ai(),
        go = {
          drive: "gd_config",
          dropbox: "db_config",
          onedrive: "od_config",
          yandex: "ya_config",
        },
        vo = G({ timeout: 600, check_interval: 300, retimeout_on_get: !0 });
      let _o, wo, bo, yo, ko, Ro;
      const xo = (e) => {
          const t = ((e) =>
              `${_o}/api?` + Dn(Object.assign({ l: bo, q: e }, Jt(yo))))(e),
            n = vo.get(t);
          if (n) return n;
          const r = R(),
            s = r.promise(),
            i = (e) => {
              r.reject({ error: e });
            };
          if (Ro && Ro > Date.now()) return i("rate limit or backoff"), s;
          if (!e.startsWith("http")) return i("unsupported url"), s;
          Ro = void 0;
          let o = 1;
          const a = ko(
            {
              url: t,
              headers: { Accept: "application/json, */*" },
              fetch: !0,
              responseType: "json",
            },
            {
              onload: (e) => {
                if (200 == e.status) {
                  const { count: t, url: n } = e.response,
                    s = `${_o}${n}`;
                  (o = 1), r.resolve({ count: Number(t || 0), url: s });
                } else if (429 === e.status) {
                  const t = qA(e.responseHeaders),
                    n = Number(t["retry-after"] || 15);
                  (o = 1), n && ((Ro = Date.now() + 1e3 * n), i("rate limit"));
                } else
                  (o = Math.min(2 * o, 300)),
                    (Ro = Date.now() + 1e3 * o),
                    i(e.responseText || "unknown error");
              },
              onerror: (e) => {
                i(e.responseText || e.statusText);
              },
              onabort: () => {
                i("aborted");
              },
              ontimeout: () => {
                i("timed out");
              },
            },
            { internal: !0 }
          );
          return (
            (s.abort = () => (null == a ? void 0 : a.abort())), vo.set(t, s), s
          );
        },
        Eo = (e) =>
          ((e, t) => {
            let n,
              r = "",
              s = "";
            return (
              "click" == yo
                ? ((r = "?" + Dn(Object.assign({ l: bo }, Jt(yo)))),
                  (s = "#" + Dn(Object.assign({ q: t }))),
                  (n = `${e}/` + r + s))
                : ((r = "?" + Dn(Object.assign({ l: bo, q: t }, Jt(yo)))),
                  (n = `${e}/search?` + r + s)),
              n
            );
          })(wo, e),
        So = () => {
          const e = "?" + Dn(Object.assign({ l: bo }, Jt(yo)));
          return `${_o}/privacy?` + e;
        },
        Co = {
          DEFAULT: "default",
          OFF: "off",
          NATIVE: "native",
          CHROME: "chrome",
          NOT_ENABLED: "not_enabled",
          NOT_WHITELISTED: "not_whitelisted",
          NOT_PERMITTED: "not_permitted",
          NOT_SUPPORTED: "not_supported",
          NOT_SUCCEEDED: "not_succeeded",
        },
        Mo = new Ai();
      let Io,
        Go = Co.OFF,
        Uo = [],
        Zo = !1,
        To = !1;
      const Bo = {},
        Oo = {},
        Fo = Ts("downloads"),
        Do = new Is(1),
        jo = I({ threads: 3 }),
        Po = I({ threads: 6 });
      let Lo = () => {
        const e = R();
        return (
          ((t) => {
            const n = "string" == typeof t ? [t] : t,
              r = () => {
                n.every((e) => !!kr[e])
                  ? ((Lo = R.Pledge), e.resolve())
                  : wr.push(r);
              };
            n.forEach((e) => {
              if (void 0 === kr[e] && void 0 === br[e]) {
                const t = X(() => {
                  yr[e] ||
                    (delete br[e],
                    ((e) => {
                      yr[e] = !0;
                    })(e),
                    ((e, t) => {
                      let n = 1;
                      const r = () => {
                        0 == --n && t && t();
                      };
                      ("string" == typeof e ? [e] : e).forEach((e) => {
                        n++;
                        try {
                          !(function (e, t) {
                            {
                              const n = document.createElement("script");
                              n.setAttribute("src", e),
                                t &&
                                  ((n.onload = () => t(!0)),
                                  (n.onerror = () => t(!1))),
                                (
                                  document.head ||
                                  document.body ||
                                  document.documentElement ||
                                  document
                                ).appendChild(n);
                            }
                          })(e, (t) => {
                            t ||
                              w.warn("registry: self.load " + e + " failed! "),
                              r();
                          });
                        } catch (t) {
                          w.warn("registry: self.load " + e + " failed! ", t),
                            r();
                        }
                      }),
                        r();
                    })(Le.getURL(e + ".js"), () => {
                      ((e) => {
                        if (!kr[e]) {
                          let t;
                          (kr[e] = !0),
                            delete yr[e],
                            (t = br[e]) && t(),
                            (() => {
                              const e = wr;
                              wr = [];
                              for (const t of e) t();
                            })();
                        }
                      })(e);
                    }));
                }, 0);
                br[e] = () => {
                  L(t), delete br[e];
                };
              }
            }),
              r();
          })(["vendor/saveas/filesaver"]),
          e.promise()
        );
      };
      const No = () =>
          void 0 !== Io
            ? R.Pledge(Io)
            : bt.supported
            ? Mi.has(Mi.permDownloads).then(
                (e) => (
                  (Io = e),
                  w.log("downs: permission to use downloads ->", e),
                  No()
                )
              )
            : ((Io = !0), R.Pledge(Io)),
        Vo = (e) => {
          !(function (e, t) {
            Se.downloads.search(e, t);
          })({ id: e }, (t) => {
            const n = t[0];
            n ? Ho(n) : w.warn("downs: unable to query download ID", e);
          });
        },
        zo = (e, t) => {
          !(function (e, t) {
            Se.downloads.cancel(e, t);
          })(e, () => {
            Vo(e), t && t();
          });
        },
        qo = (e, t) => {
          const n = R();
          let r;
          Qo();
          let {
            name: s,
            url: i,
            method: o,
            saveAs: a,
            data: l,
            headers: c,
            conflictAction: u,
          } = e;
          const { download_id: A } = t;
          u &&
            !{ uniquify: !0, prompt: !0, overwrite: !0 }[u] &&
            (u = "uniquify"),
            (r = {
              filename: s,
              url: i,
              method: o,
              saveAs: a,
              ...(u ? { conflictAction: u } : {}),
              body: l,
            }),
            c &&
              (Array.isArray(c)
                ? w.warn("downs: invalid type of headers property", c)
                : (r.headers = Object.entries(c).map(([e, t]) => ({
                    name: e,
                    value: t,
                  }))));
          const d = Oo[A],
            h = (Oo[A] = {
              ...d,
              type: "chrome",
              download_id: A,
              url: i,
              name: s,
            });
          if (
            ((function (e, t) {
              try {
                return Se.downloads.download(e, t);
              } catch (e) {
                t(void 0, e.message);
              }
            })(r, (e, t) => {
              if (void 0 === e)
                return (
                  n.reject(t),
                  void Mo.emit("error", { id: A, error: t || "unknown" })
                );
              h.browser_download_id = e;
              const r = (Bo[A] = { deferred: n });
              !0 === h.cancel
                ? zo(e)
                : ((r.cancel = (t) => zo(e, t)),
                  (r.interval = W(() => Vo(e), 1e3)));
            }),
            qe.lastError)
          ) {
            const e = qe.lastError.message;
            n.reject(e), Mo.emit("error", { id: A, error: e });
          }
          return n.promise();
        },
        Ho = (e) => {
          var t;
          const { item: n, key: r } = ((e) => {
            let t, n;
            return (
              Object.keys(Oo).every((r) => {
                const s = Oo[r];
                return (
                  !s || s.browser_download_id != e || ((n = r), (t = s), !1)
                );
              }),
              { item: t, key: n }
            );
          })(e.id);
          if (n && r) {
            const { name: s, url: i, download_id: o } = n,
              { interval: a, deferred: l } = Bo[o] || {},
              c = () => {
                a && P(a), delete Oo[r], delete Bo[r], l && l.resolve();
              },
              u =
                (null === (t = e.state) || void 0 === t ? void 0 : t.current) ||
                e.state,
              { totalBytes: A, bytesReceived: d } = e;
            e.error || "interrupted" == u
              ? (w.warn(`downs: download of ${s} (${i}) failed`, e.error),
                Mo.emit("error", {
                  id: o,
                  error: Co.NOT_SUCCEEDED,
                  details: e.error,
                }),
                c())
              : e.endTime || "complete" == u
              ? (w.log(`downs: download of ${s} (${i}) finished`),
                Mo.emit("load", { id: o, info: {} }),
                c())
              : (void 0 === A && void 0 === d) ||
                Mo.emit("progress", {
                  id: o,
                  info: {
                    loaded: d,
                    total: A,
                    estimatedEndTime: e.estimatedEndTime,
                  },
                });
          }
        },
        Qo = () => {
          Io && !To && (At(Ho), (To = !0));
        },
        Wo = (e) => {
          (Go = e),
            Go == Co.CHROME &&
              No().done((e) => {
                e ||
                  Mi.has(Mi.permDownloads)
                    .then((e) => {
                      const t = R();
                      return (
                        Zo || e
                          ? t.resolve({ permission: e, asked: !1 })
                          : Mi.ask(
                              Mi.permDownloads,
                              Dr.getMessage("Browser_API_Downloads"),
                              Dr.getMessage(
                                "Click_here_to_allow_TM_to_start_downloads"
                              )
                            ).done((e) => {
                              t.resolve({ permission: e, asked: !0 });
                            }),
                        (Zo = !0),
                        t.promise()
                      );
                    })
                    .done((e) => {
                      e.permission && e.asked && je();
                    });
              });
        },
        Xo = (e) => {
          Uo = Qt(e);
        },
        Yo = (e) => {
          for (const t of Uo)
            if (t && t.length)
              try {
                let n;
                if ("/" === t[0]) {
                  let e = t.replace(/^\//g, "").replace(/\/$/g, "");
                  "$" !== e[e.length - 1] &&
                    (w.log(`downs: patching $ into ${e}`), (e += "$")),
                    (n = new RegExp(e, "i"));
                } else if ("." === t[0]) {
                  const e = [Pt(t), "$"].join("");
                  n = new RegExp(e, "i");
                } else
                  w.warn(
                    `downs: invalid file extension: "${t}" starts neither with "." nor with "/"`
                  );
                if (n && -1 !== e.search(n))
                  return w.log(`downs: ${t} matched @${e}`), !0;
              } catch (e) {
                w.warn(`downs: can't process ${t}`, e);
              }
          return !1;
        },
        Jo = {
          init: () => {
            const e = () => {
              Wo(un.values.downloads_mode),
                Xo(un.values.downloads_extension_whitelist);
            };
            e(),
              un.addChangeListener(
                ["downloads_extension_whitelist", "downloads_mode"],
                e
              ),
              Do.acquire()
                .then(async () => {
                  for (const { key: e, value: t } of await Fo.list())
                    "chrome" == t.type &&
                      ((Oo[e] = t),
                      (Bo[e] = {
                        cancel: (t) => zo(e, t),
                        interval: W(() => Vo(e), 1e3),
                      }));
                })
                .always(() => Do.release());
          },
          start: (e, t) => {
            const n = t || {},
              r = Xt();
            let s,
              {
                name: i,
                from: { tfd: o, url: a },
              } = e;
            if ((w.log("downs: start", e), !n.internal)) {
              if (Go == Co.OFF)
                return (
                  w.warn("downs: feature is not enabled"),
                  x(1).then(() =>
                    Mo.emit("error", { id: r, error: Co.NOT_ENABLED })
                  ),
                  r
                );
              if (!i || !Yo(i))
                return (
                  w.warn("downs:", i, "is not whitelisted"),
                  x(1).then(() =>
                    Mo.emit("error", { id: r, error: Co.NOT_WHITELISTED })
                  ),
                  r
                );
              0;
            }
            if (o) {
              if (((s = Rs.fromTransferableData(o)), !s))
                return (
                  w.warn("downs: invalid transferable"),
                  x(1).then(() =>
                    Mo.emit("error", { id: r, error: Co.NOT_SUPPORTED })
                  ),
                  r
                );
              a = s.tryObjectUrl || s.tryDataUri || a;
            }
            const l = () => {
                const e = Oo[r];
                if (e && e.cancel)
                  return (
                    x(1).then(() =>
                      Mo.emit("error", { id: r, error: "aborted" })
                    ),
                    R.Breach("aborted")
                  );
              },
              c = i;
            let u;
            c &&
              ((i = ((e, t, n) => {
                void 0 === n && (n = "-");
                return e.replace(/[:<>|~?*\x00-\x1F\uFDD0-\uFDEF"]/g, n);
              })(c)),
              c != i &&
                w.warn(
                  `downs: changed file name from ${c} to ${i} for safety`
                ));
            const A = (Oo[r] = {
              type: "unknown",
              download_id: r,
              url: a,
              name: c,
            });
            return (
              Do.acquire()
                .then(() => Fo.set(r, A).always(() => Do.release()))
                .then(() => {
                  if (n.internal || Go == Co.CHROME || Go == Co.DEFAULT)
                    return No()
                      .then((e) => (u = e))
                      .then(l);
                  u = !1;
                })
                .then(() => {
                  if (s && s.tryBlob) return s.tryBlob;
                  if (a) {
                    const t = Zn(a);
                    if (t && "data:" == t.protocol) return _e(a);
                    if (!u || (!n.internal && Go == Co.DEFAULT))
                      return ((e, t) => {
                        const { internal: n, download_id: r } = t;
                        return Po.add(() => {
                          const t = R(),
                            s = () => {
                              t.reject(),
                                Mo.emit("error", { id: r, error: "aborted" });
                            },
                            i = Oo[r];
                          if (i && i.cancel) s();
                          else {
                            const o = (n) => {
                              if (
                                4 != n.readyState ||
                                (200 != n.status && 0 != n.status) ||
                                n.error
                              ) {
                                const e =
                                  n.error || n.statusText || "xhr_failed";
                                t.reject(e),
                                  Mo.emit("error", { id: r, error: e });
                              } else {
                                const r = qA(n.responseHeaders)["content-type"],
                                  s = new Blob([n.response], {
                                    type:
                                      e.overrideMimeType ||
                                      r ||
                                      "binary/octet-stream",
                                  });
                                t.resolve(s);
                              }
                            };
                            (e.responseType = "blob"),
                              (e.method = e.method || "GET");
                            const a = HA(
                                e,
                                {
                                  onload: o,
                                  onerror: (e) => {
                                    t.reject(),
                                      Mo.emit("error", {
                                        id: r,
                                        error: e.error || "failed",
                                        details: e.statusText,
                                      });
                                  },
                                  onabort: s,
                                  ontimeout: () => {
                                    t.reject(),
                                      Mo.emit("error", {
                                        id: r,
                                        error: "timeout",
                                      });
                                  },
                                  onprogress: (e) => {
                                    e.lengthComputable &&
                                      Mo.emit("progress", {
                                        id: r,
                                        info: {
                                          loaded: e.loaded,
                                          total: e.total,
                                        },
                                      });
                                  },
                                },
                                { internal: n }
                              ),
                              l = {
                                ...i,
                                type: "xhr",
                                name: e.name,
                                url: e.url,
                                download_id: r,
                              };
                            (Oo[r] = l),
                              (Bo[r] = {
                                cancel: a ? a.abort : () => {},
                              });
                          }
                          return t.promise();
                        });
                      })(
                        { url: a, ...e, name: i },
                        { internal: n.internal, download_id: r }
                      );
                  }
                })
                .then((t) => {
                  if (t && u) {
                    let n;
                    return R.Pledge()
                      .then(() => {
                        if (Te.SHARED_OBJECT_URLS)
                          return (n = URL.createObjectURL(t));
                        {
                          const e = R();
                          return (
                            we(t).then((t) => {
                              void 0 === t
                                ? (Mo.emit("error", { id: r, error: "failed" }),
                                  e.reject())
                                : e.resolve(t);
                            }),
                            e.promise()
                          );
                        }
                      })
                      .then((t) =>
                        qo(
                          { url: t, name: i, saveAs: e.saveAs },
                          { download_id: r }
                        ).always(() => {
                          n && URL.revokeObjectURL(n);
                        })
                      );
                  }
                  return t
                    ? Lo().then(async () => {
                        const e = K.saveAs;
                        return e
                          ? jo.add(async () => {
                              e(t, i),
                                await x(500),
                                Mo.emit("load", { id: r, info: {} });
                            })
                          : (Mo.emit("error", { id: r, error: "failed" }),
                            void w.warn("Unable to load saveAs!"));
                      })
                    : a && u
                    ? qo({ url: a, ...e, name: i }, { download_id: r })
                    : void (a && !n.internal && Go == Co.CHROME
                        ? (w.warn("downs: download permission is missing"),
                          Mo.emit("error", { id: r, error: Co.NOT_PERMITTED }))
                        : (w.warn("downs: download failed"),
                          Mo.emit("error", { id: r, error: "failed" })));
                })
                .always(() => {
                  Do.acquire()
                    .then(() => (delete Oo[r], delete Bo[r], Fo.delete(r)))
                    .always(() => {
                      Do.release(), Mo.emit("done", { id: r, info: {} });
                    });
                }),
              r
            );
          },
          cancel: (e) => {
            const t = Oo[e],
              n = Bo[e];
            return !!t && (n && n.cancel ? n.cancel() : (t.cancel = !0), !0);
          },
          set_mode: Wo,
          set_whitelist: Xo,
          is_whitelisted: Yo,
          remove_permission: () => Mi.remove(Mi.permDownloads),
          staticVars: Co,
        },
        Ko = Jo,
        $o = (e, t) => (
          Te.FPI
            ? void 0 !== t && (e.firstPartyDomain = e.firstPartyDomain || t)
            : delete e.firstPartyDomain,
          "sameSite" in e &&
            e.sameSite &&
            (e.sameSite = e.sameSite.toLowerCase()),
          e
        );
      let ea;
      const ta = {
        getAll: (e) => {
          const t = R();
          return ht.getAll($o(e, null), (e) => t.resolve(e)), t.promise();
        },
        remove: (e) => {
          const t = R();
          return (
            ht.remove($o(e), (e) => {
              if (e) t.resolve();
              else {
                const e = qe.lastError;
                t.reject(e ? e.message : "unknown error");
              }
            }),
            t.promise()
          );
        },
        set: (e) => {
          const t = R();
          return (
            ht.set($o(e), (e) => {
              if (e) t.resolve(e);
              else {
                const e = qe.lastError;
                t.reject(e ? e.message : "unknown error");
              }
            }),
            t.promise()
          );
        },
        get fpi() {
          return ea;
        },
      };
      Te.FPI &&
        ht.remove(
          { url: "https://www.tampermonkey.net", name: "doesnotexist" },
          () => {
            qe.lastError && (ea = !0);
          }
        );
      const na = ta;
      let ra;
      const sa = {
          run: (e, t) => {
            let n = 1;
            const r = () => {
              0 == --n && (t && t(), je());
            };
            if ("config" == e) {
              const e = Ot.listValues();
              for (const t of e) {
                if (
                  -1 != t.indexOf(Ze.PREFIX.SCRIPT) ||
                  -1 != t.indexOf(Ze.PREFIX.COND) ||
                  -1 != t.indexOf(Ze.PREFIX.STORE) ||
                  -1 != t.indexOf(Ze.PREFIX.META)
                )
                  return;
                n++, Ot.deleteValue(t).always(r);
              }
            } else
              "factory" == e &&
                (n++,
                Ko.remove_permission().done(r),
                n++,
                Ot.factoryReset().always(r));
            r();
          },
          reset: (e) => {
            sa.run(void 0, e);
          },
          factoryReset: (e) => {
            sa.run("factory", e);
          },
          configReset: (e) => {
            sa.run("config", e);
          },
        },
        ia = sa,
        oa = {
          ePASTEBIN: 1,
          eCHROMESYNC: 2,
          eSYNCFS: 3,
          eGDRIVE: 4,
          eDROPBOX: 5,
          eWEBDAV: 6,
          eYANDEX: 7,
          eONEDRIVE: 8,
          eUNKNOWN: 9,
        };
      let aa,
        la,
        ca = 0;
      const ua = { ts: 0 },
        Aa = {},
        da = I({ threads: 1 }),
        ha = {},
        pa = { comment: !0 },
        fa = !!K.Tests,
        ma = (e, t) =>
          da.add(async () => {
            if (!aa.caps.syncsSource) {
              let t;
              if (!e.url || !(t = Zn(e.url)) || !t.protocol.match(/https?:/))
                return (
                  w.log("sync: skip export due to missing URL", e.name, e.url),
                  !1
                );
            }
            w.log("sync: export", e.name, e.url),
              di.emit("syncProgressEvent", {
                type: "export",
                text: Dr.getMessage(
                  "Export_script_0name0_0uuid0",
                  e.name,
                  e.uuid
                ),
              });
            try {
              return (
                aa.setSource &&
                  t &&
                  (di.emit("syncProgressEvent", {
                    type: "export",
                    text: Dr.getMessage(
                      "Export_script_source_of_0name0",
                      e.name,
                      e.uuid
                    ),
                  }),
                  await aa.setSource(e.uuid, t)),
                di.emit("syncProgressEvent", {
                  type: "export",
                  text: Dr.getMessage(
                    "Export_script_meta_data_of_0name0",
                    e.name,
                    e.uuid
                  ),
                }),
                await aa.setMeta(e, { lastModified: e.lastModified }),
                !0
              );
            } catch (e) {
              return !1;
            }
          }),
        ga = () => {
          const e = Cd.getUidList()
            .map((e) => {
              const t = Cd.getByUid(e);
              if (t.script && t.cond && !t.script.deleted) {
                const e = Xc(t.script);
                return e.lastModified || fa
                  ? t.script.evilness &&
                    t.script.evilness >=
                      Math.min(
                        Wi.SEVERITY_MAX,
                        un.values.script_blacklist_severity
                      )
                    ? void w.warn("sync: ignore evil script", t.script)
                    : e
                  : void w.warn(
                      "sync: script without updated/modified timestamps found",
                      t.script
                    );
              }
            })
            .filter((e) => e);
          return e;
        },
        va = (e, t, n) =>
          n ? Math.floor(e / n) * n < Math.floor(t / n) * n : e < t,
        _a = () => {
          la && (w.verbose("sync: remoteChangeCb()"), ba(500, !0));
        },
        wa = () => {
          const e = R();
          let t = !1;
          return (
            R.Pledge()
              .then(() => {
                if (un.values.sync_type) {
                  if (un.values.sync_enabled) {
                    let e = {};
                    return (
                      un.values.sync_type == oa.eWEBDAV &&
                        (e = {
                          url: un.values.cloud_url || void 0,
                          basic_auth: he(
                            un.values.cloud_user + ":" + un.values.cloud_pass
                          ),
                        }),
                      aa
                        .init(un.values.sync_type, e)
                        .done((e) => {
                          (t = e),
                            e
                              ? aa.addChangeListener(_a)
                              : w.warn("sync: init failed!");
                        })
                        .fail(() => {
                          w.warn("sync: init failed!");
                        })
                    );
                  }
                  return aa.disable(un.values.sync_type);
                }
              })
              .always(() => {
                (la = t), e.resolve(la);
              }),
            e.promise()
          );
        },
        ba = (e, t) => {
          const n = Date.now();
          (e = e || 500),
            (t = ua.force || t),
            ua.to
              ? (L(ua.to),
                ua.ts < n + e &&
                  ((e = ua.ts - n) < 1 && (e = 1),
                  w.verbose(`sync: re-schedule sync for run in ${e} ms`)))
              : w.log(`sync: schedule sync for run in ${e} ms`),
            (ua.force = t),
            (ua.ts = n + e),
            (ua.to = X(() => {
              ((e) => {
                let t = [],
                  n = [],
                  r = 0,
                  s = 0,
                  i = !0;
                const o = (e) => {
                  if (e)
                    for (let t = 0; t < n.length; t++)
                      if (n[t].uuid == e) return n[t];
                  return null;
                };
                R.Pledge()
                  .then(() => {
                    if (void 0 === la && e) return ka();
                  })
                  .then(() =>
                    la
                      ? ca > 0
                        ? (e &&
                            di.once("syncFinished", (t) => {
                              t && ba(50, e);
                            }),
                          R.Breach())
                        : (ca++,
                          w.verbose("sync: start syncing = " + ca),
                          void $s.all("status", {
                            key: "sync_status",
                            class: "information",
                            title: Dr.getMessage("Script_Sync"),
                            text: Dr.getMessage("Sync_is_running"),
                            timeout: 9e5,
                          }))
                      : R.Breach()
                  )
                  .then(
                    () => (
                      (t = ga()),
                      (di.emit("syncProgressEvent", {
                        type: "lookup",
                        text: Dr.getMessage("Lookup_remote_script_list"),
                      }),
                      aa.list())
                        .done((e) => {
                          n = e;
                        })
                        .fail(() => {
                          w.warn("sync: unable to get remotelist!");
                        })
                    )
                  )
                  .then(() => {
                    const e = n
                      .map((e) => {
                        let n;
                        const s = ((e) => {
                          if (e)
                            for (let n = 0; n < t.length; n++)
                              if (t[n].uuid == e) return t[n];
                        })(e.uuid);
                        let i = !1,
                          o = 0;
                        if (s) {
                          if (
                            !e.lastModified &&
                            un.values.sync_type == oa.eCHROMESYNC
                          )
                            for (const [t, n] of Object.entries(pa))
                              if (!0 === n && s.options[t] != e.options[t]) {
                                w.log(
                                  "sync: importable change detected!",
                                  e.uuid,
                                  "key:",
                                  t,
                                  e
                                ),
                                  (i = !0);
                                break;
                              }
                          e.lastModified &&
                            va(s.lastModified, e.lastModified, e.precision) &&
                            ((o = e.lastModified),
                            (i = !0),
                            w.log(
                              "sync: importable change detected!",
                              e.uuid,
                              "local ts:",
                              new Date(s.lastModified),
                              "remote ts:",
                              new Date(e.lastModified),
                              e
                            ));
                        } else
                          (n = ha[e.uuid]) &&
                            e.lastModified &&
                            va(n.lastModified, e.lastModified, e.precision) &&
                            ((o = e.lastModified),
                            (i = !0),
                            w.log(
                              "sync: changed cache entry detected!",
                              e.uuid,
                              "local ts:",
                              new Date(n.lastModified),
                              "remote ts:",
                              new Date(e.lastModified),
                              e
                            ));
                        if ((!s && !n) || i)
                          return () =>
                            R.Pledge()
                              .then(() =>
                                aa.caps.specialMeta
                                  ? (di.emit("syncProgressEvent", {
                                      type: "lookup",
                                      text: Dr.getMessage(
                                        "Lookup_remote_script_0uuid0",
                                        e.uuid
                                      ),
                                    }),
                                    aa.getMeta(e.uuid))
                                  : R.Pledge(e)
                              )
                              .then((e) => {
                                if (!e) return;
                                const { uuid: t, url: a } = e;
                                if (s) {
                                  if (e.options.removed)
                                    r++,
                                      di.emit("syncProgressEvent", {
                                        type: "import",
                                        text: Dr.getMessage(
                                          "Remove_local_script_0name0_0uuid0",
                                          s.name,
                                          s.uuid
                                        ),
                                      }),
                                      w.log(
                                        `sync: remove local script ${t}`,
                                        a
                                      ),
                                      vu.doRemove(s.uuid);
                                  else if (i)
                                    return (
                                      (l = o),
                                      (c = e.lastModified),
                                      ((u = e.precision)
                                        ? Math.floor(l / u) * u !=
                                          Math.floor(c / u) * u
                                        : l != c) &&
                                        (e.lastModified &&
                                          w.warn(
                                            "sync: list and meta data lastModified differ, this will cause extra traffic!",
                                            "file ts:",
                                            new Date(o),
                                            "meta ts:",
                                            new Date(e.lastModified),
                                            e
                                          ),
                                        (e.lastModified = o)),
                                      r++,
                                      w.log(
                                        `sync: update local script ${t}`,
                                        a
                                      ),
                                      di.emit("syncProgressEvent", {
                                        type: "import",
                                        text: Dr.getMessage(
                                          "Update_local_script_0name0_0uuid0",
                                          s.name,
                                          s.uuid
                                        ),
                                      }),
                                      R.Pledge()
                                        .then(() => {
                                          if (
                                            aa.caps.syncsSource &&
                                            aa.getSource
                                          ) {
                                            const n = R();
                                            return (
                                              aa
                                                .getSource(t, void 0)
                                                .then((e) =>
                                                  e
                                                    ? vu.doSave({
                                                        uuid: t,
                                                        src: e,
                                                        ask: !1,
                                                        internal: !0,
                                                        save: !0,
                                                      })
                                                    : R.Breach()
                                                )
                                                .fail(() => {
                                                  w.warn(
                                                    `sync: getting source of ${t} failed`,
                                                    e
                                                  );
                                                })
                                                .always(() => n.resolve()),
                                              n.promise()
                                            );
                                          }
                                        })
                                        .then(() => {
                                          const { script: n } = Cd.getByUid(
                                            s.uuid
                                          );
                                          if (!n)
                                            return (
                                              w.warn(
                                                `sync: getting entry ${t} failed`,
                                                e
                                              ),
                                              R.Breach()
                                            );
                                          for (const [t, r] of Object.entries(
                                            pa
                                          ))
                                            !0 === r &&
                                              (n.options[t] =
                                                e.options[t] || null);
                                          return (
                                            (n.lastModified = e.lastModified),
                                            vu.doModify(n.uuid, n, !1)
                                          );
                                        })
                                    );
                                } else if (s || e.options.removed)
                                  !n && e.options.removed && (ha[t] = e);
                                else {
                                  const n = R();
                                  if (!((a && Aa[a]) || (t && Aa[t])))
                                    return (
                                      ((e) =>
                                        da.add(() => {
                                          const {
                                            uuid: t,
                                            url: n,
                                            lastModified: r,
                                          } = e;
                                          di.emit("syncProgressEvent", {
                                            type: "import",
                                            text: Dr.getMessage(
                                              "Import_remote_script_0uuid0",
                                              e.uuid
                                            ),
                                          }),
                                            w.log("sync: import", t, n);
                                          const s = {
                                              imported: un.values.sync_type,
                                            },
                                            i = {};
                                          for (const [t, n] of Object.entries(
                                            pa
                                          ))
                                            !0 === n && (i[t] = e.options[t]);
                                          const o = {
                                              uuid: t,
                                              ask: !1,
                                              internal: !0,
                                              sync: s,
                                              force_meta: {
                                                lastModified: r,
                                                fileURL: n || void 0,
                                              },
                                              force_options: i,
                                            },
                                            a = { silent_fail: !0 };
                                          return (
                                            aa.caps.syncsSource && aa.getSource
                                              ? aa.getSource(t).then(
                                                  (e) =>
                                                    e
                                                      ? vu.installFromSource(
                                                          e,
                                                          o,
                                                          a
                                                        )
                                                      : (w.warn(
                                                          "sync: import export due to missing source",
                                                          t,
                                                          n
                                                        ),
                                                        R.Breach()),
                                                  () => {
                                                    w.warn(
                                                      "sync: import export due to missing source",
                                                      t,
                                                      n
                                                    );
                                                  }
                                                )
                                              : n
                                              ? vu.installFromUrl(n, o, a)
                                              : (w.log(
                                                  "sync: skip import due to missing URL and source",
                                                  t
                                                ),
                                                R.Breach())
                                          ).done(() => {
                                            yd.removeAll();
                                          });
                                        }))(e)
                                        .done((n) => {
                                          n
                                            ? r++
                                            : (w.warn(
                                                "sync: unable to import",
                                                e
                                              ),
                                              a && (Aa[a] = !0),
                                              (Aa[t] = !0));
                                        })
                                        .fail(() => {
                                          w.warn("sync: unable to load", e),
                                            a && (Aa[a] = !0),
                                            (Aa[t] = !0);
                                        })
                                        .always(() => n.resolve()),
                                      n.promise()
                                    );
                                  w.warn(
                                    "sync: skip previously failed import",
                                    e
                                  );
                                }
                                var l, c, u;
                              });
                      })
                      .filter((e) => e);
                    return R.onebyone(e);
                  })
                  .then(
                    () => (
                      r &&
                        (vu.reorderScripts(),
                        $s.all("status", {
                          key: "sync",
                          class: "information",
                          title: Dr.getMessage("Script_Sync"),
                          text: Dr.getMessage("0count0_changes_imported", r),
                          timeout: 1e4,
                        })),
                      (t = ga()),
                      R.Pledge()
                    )
                  )
                  .then(() => {
                    const e = [];
                    for (let n = 0; n < t.length; n++)
                      e.push(
                        (() => {
                          const e = t[n];
                          let r, i;
                          if (!aa.caps.syncsSource && !e.url) return R.Pledge();
                          const a = o(e.uuid);
                          var l, c, u;
                          if (
                            (a
                              ? (a.lastModified &&
                                  ((l = e.lastModified),
                                  (c = a.lastModified),
                                  !((u = a.precision)
                                    ? Math.floor(l / u) * u >
                                      Math.floor(c / u) * u
                                    : l > c))) ||
                                ((r = !0),
                                w.log(
                                  "sync: exportable change detected!",
                                  e.name,
                                  "remote ts:",
                                  new Date(a.lastModified),
                                  "local ts:",
                                  new Date(e.lastModified),
                                  e
                                ))
                              : w.log(
                                  "sync: export because remotely missing!",
                                  e.name,
                                  "local ts:",
                                  new Date(e.lastModified),
                                  e
                                ),
                            !a ||
                              r ||
                              (aa.caps.syncsSource && !a.sourceAvailable))
                          ) {
                            if (aa.caps.syncsSource) {
                              const t = Cd.getByUid(e.uuid);
                              t.script && t.cond && (i = t.script.textContent);
                            }
                            return ma(e, i).then((e) => {
                              e && s++;
                            });
                          }
                          return R.Pledge();
                        })()
                      );
                    return R.when(e);
                  })
                  .then(() => {
                    i = !0;
                  })
                  .fail(() => {
                    i = !1;
                  })
                  .always(() => {
                    if ((w.log("sync: finished"), 0 != ca)) {
                      if (0 == --ca) {
                        let e = Dr.getMessage(
                          i ? "Sync_finished" : "Sync_failed"
                        );
                        if (
                          ($s.all("status", {
                            key: "sync_status",
                            class: "information",
                            title: Dr.getMessage("Script_Sync"),
                            text: e,
                            timeout: 15e3,
                          }),
                          s)
                        ) {
                          const t = Dr.getMessage(
                            "0count0_changes_exported",
                            s
                          );
                          $s.all("status", {
                            key: "sync",
                            class: "information",
                            title: Dr.getMessage("Script_Sync"),
                            text: t,
                            timeout: 5e3,
                          }),
                            (e = `${e}\n${t}`);
                        }
                        di.emit("syncProgressEvent", {
                          type: "finished",
                          success: i,
                          text: e,
                        }),
                          di.emit("syncFinished", i);
                      }
                    } else w.warn("sync: syncing was already finished");
                  });
              })(ua.force),
                (ua.to = ua.force = void 0);
            }, e));
        };
      let ya = !0;
      const ka = () =>
        R.Pledge().then(() => {
          if (ya) return (ya = !1), wa();
        });
      let Ra;
      const xa = {
        get enabled() {
          return la;
        },
        SYNCED: pa,
        init: async () => {
          Ni.on("sync", () => {
            ka().always(() => {
              la && xa.sync();
            });
          }),
            Ni.schedule("sync", {
              delayInMinutes: 1,
              periodInMinutes: 10,
              keepExistent: !0,
            }),
            (aa = Yc(ze.manifest.version)),
            un.addChangeListener(
              [
                "sync_enabled",
                "sync_type",
                "cloud_url",
                "cloud_user",
                "cloud_pass",
              ],
              (e, t, n) => {
                "sync_type" == e && t && t !== n && aa.disable(t),
                  Ra ||
                    (Ra = X(() => {
                      (Ra = void 0), wa();
                    }, 3e3));
              }
            ),
            di.on(
              "scriptEvent",
              ({ type: e, name: t, script: n, sync: r, changed: s }) => {
                if (!la || !r) return;
                w.verbose(
                  `sync: script ${e} event for ${t} (changed: ${s}, sync: ${r})`
                );
                const i = Xc(n);
                switch (e) {
                  case "added":
                    ma(i, n.textContent);
                    break;
                  case "changed":
                    Ni.schedule("sync", {
                      periodInMinutes: 10,
                      delayInMinutes: 1,
                    });
                    break;
                  case "removed":
                    ((e) => {
                      da.add(
                        () => (
                          di.emit("syncProgressEvent", {
                            type: "export",
                            text: Dr.getMessage(
                              "Remove_remote_script_0name0_0uuid0",
                              e.name,
                              e.uuid
                            ),
                          }),
                          w.log("sync: remove", e.name, e.url),
                          aa.remove(e)
                        )
                      );
                    })(i);
                }
              }
            );
        },
        sync: ba,
        reset: () =>
          R.Pledge()
            .then(() => {
              if (void 0 === la) return ka();
            })
            .then(() => (la ? aa.reset() : R.Breach())),
      };
      K.sycl = xa;
      const Ea = xa,
        Sa = new Ai(),
        Ca = {},
        Ma = {
          set: ({
            tabId: e,
            createdAt: t,
            name: n,
            title: r,
            uuid: s,
            accessKey: i,
            autoClose: o,
            menuId: a,
            scriptName: l,
          }) => {
            Ca[a] = {
              tabId: e,
              createdAt: t,
              name: n,
              title: r,
              uuid: s,
              accessKey: i,
              autoClose: o,
              menuId: a,
              scriptName: l,
            };
          },
          list: () =>
            Object.values(Ca).sort((e, t) => e.createdAt - t.createdAt),
          listByTabId: (e) => {
            const t = {};
            return Ma.list().filter((n) => {
              const r = n.uuid + n.name;
              return n.tabId == e && !t[r] && (t[r] = !0);
            });
          },
          clearByTabId: (e) => {
            for (const t of ((e) => Ma.list().filter((t) => t.tabId == e))(e))
              delete Ca[t.menuId];
          },
          clearById: (e) => {
            delete Ca[e];
          },
          getById: (e) => Ca[e],
          convertToMenuItems: (e) => {
            const t = {},
              n = null == e || null == e ? Ma.list() : Ma.listByTabId(e);
            for (const e of n) {
              const {
                  name: n,
                  title: r,
                  uuid: s,
                  accessKey: i,
                  autoClose: o,
                  menuId: a,
                } = e,
                l = {
                  name: n,
                  title: r,
                  uuid: s,
                  id: a,
                  accessKey: i,
                  autoClose: !1 !== o,
                  image: "menu_cmd",
                  menucmd: !0,
                };
              (t[e.uuid] = t[e.uuid] || []).push(l);
            }
            return t;
          },
        },
        Ia = Ma,
        Ga = {
          mkCompat: (e, t, n, r) => (
            t &&
              ((t.options.compat_wrappedjsobject || r) &&
                (e = Ga.unWrappedJsObjectify(e)),
              (t.options.compat_metadata || r) && (e = Ga.unMetaDataify(e)),
              (t.options.compat_foreach || r) && (e = Ga.unEachify(e))),
            n || (e = e.replace(/(['"])use strict(['"])/g, "$1use strict$2")),
            e
          ),
          findPrototypes: (e) => {
            if (e.includes(".toSource(")) return !0;
            const t = [
              "indexOf",
              "lastIndexOf",
              "filter",
              "forEach",
              "every",
              "map",
              "some",
              "slice",
            ];
            for (const n in t) if (e.includes(`Array.${t[n]}(`)) return !0;
            return !1;
          },
          unEachify: (e) => {
            const t = (e = e.replace(/for each[ \t]*\(/gi, "for each(")).split(
              "for each"
            );
            for (let e = 1; e < t.length; e++) {
              const n = t[e];
              if ("(" != n.substr(0, 1)) {
                t[e] = " each" + t[e];
                continue;
              }
              const r = Dt(n, "(", ")"),
                s = r.split(" ");
              let i = null,
                o = null,
                a = null;
              for (const e in s)
                "" != s[e] &&
                  "var" != s[e] &&
                  (i ? (o ? a || (a = s[e]) : (o = s[e])) : (i = s[e]));
              if (!i || !a) {
                t[e] = " each" + t[e];
                continue;
              }
              const l = "var __kk in " + a;
              let c = "";
              (c += "{\n    if (!" + a + ".hasOwnProperty(__kk)) continue;"),
                (c += " \n    var " + i + " = " + a + "[__kk];"),
                (t[e] = t[e].replace(r, l).replace("{", c));
            }
            return t.join("for");
          },
          unMetaDataify: (e) => {
            let t = e,
              n = e;
            const r = "<><![CDATA[",
              s = "]]></>";
            let i = t.indexOf(r);
            for (; -1 != i; ) {
              const e = t.substr(0, i),
                o = e.lastIndexOf("\n");
              let a = "";
              -1 != o && (a = e.substr(o, e.length - o)),
                (t = t.substr(i, t.length - i));
              const l = a.indexOf("/*"),
                c = a.indexOf("//");
              if (-1 == l && -1 == c) {
                const e = Dt(t, r, s);
                let i = e;
                (i = i.replace(/\\/g, "\\\\")),
                  (i = i.replace(/"/g, '\\"').replace(/\n/g, '\\n" + \n"')),
                  (i = i.replace(/^\n/g, "").replace(/\n$/g, "")),
                  (i = i.replace(/\r/g, ""));
                const o = r + e + s;
                n = n.replace(o, '(new CDATA("' + i + '"))');
              }
              (t = t.substr(1, t.length - 1)), (i = t.indexOf(r));
            }
            return n;
          },
          unWrappedJsObjectify: (e) => {
            const t = e.split("\n");
            for (let e = 0; e < t.length; e++) {
              const n = t[e].indexOf(".wrappedJSObject");
              if (-1 == n) continue;
              const r = t[e].indexOf("//");
              (-1 != r && r < n) ||
                (t[e] = t[e].replace(/\.wrappedJSObject/g, ""));
            }
            return t.join("\n");
          },
        },
        Ua = Ga,
        Za = {
          backgroundControl: ["GM.backgroundControl"],
          addElement: [
            "GM_addElement",
            "GM.addElement",
            "GM_addStyle",
            "GM.addStyle",
          ],
          cookie: ["GM_cookie", "GM.cookie"],
          values: [
            "GM_listValues",
            "GM.listValues",
            "GM_getValue",
            "GM.getValue",
            "GM_addValueChangeListener",
            "GM.addValueChangeListener",
            "GM_removeValueChangeListener",
            "GM.removeValueChangeListener",
            "GM_setValue",
            "GM.setValue",
            "GM_deleteValue",
            "GM.deleteValue",
          ],
          download: ["GM_download", "GM.download"],
          getResource: [
            "GM_getResourceText",
            "GM.getResourceText",
            "GM_getResourceURL",
            "GM.getResourceUrl",
          ],
          tabs: [
            "GM_getTab",
            "GM.getTab",
            "GM_getTabs",
            "GM.getTabs",
            "GM_saveTab",
            "GM.saveTab",
          ],
          info: ["GM_info", "GM.info"],
          log: ["GM_log", "GM.log"],
          notification: ["GM_notification", "GM.notification"],
          openInTab: ["GM_openInTab", "GM.openInTab"],
          menuCommand: [
            "GM_registerMenuCommand",
            "GM.registerMenuCommand",
            "GM_unregisterMenuCommand",
            "GM.unregisterMenuCommand",
          ],
          setClipboard: ["GM_setClipboard", "GM.setClipboard"],
          xmlHttpRequest: ["GM_xmlhttpRequest", "GM.xmlHttpRequest"],
          "window.close": ["window.close"],
          "window.focus": ["window.focus"],
          "window.onurlchange": ["window.onurlchange"],
          webRequest: ["GM_webRequest", "GM.webRequest"],
        },
        Ta = ["unsafeWindow", "GM_info", "GM.info"],
        Ba = Object.entries(Za).reduce((e, t) => {
          const [n, r] = t;
          return r.forEach((t) => (e[t] = [...(e[t] || Ta), n])), e;
        }, {}),
        Oa = Object.keys({ GM: !0, unsafeWindow: !0, ...Ba }).filter(
          (e) => !e.includes(".")
        ),
        Fa = new RegExp(
          "[a-z0-9A-Z_$]\\s*(\\.\\s*|\\[\\s*[\"'`])(" +
            Oa.join("\\b|") +
            "\\b)([\"'`]\\s*\\])?(\\s*)(?!=[^=])(\\S|$)"
        ),
        Da = 2 << 16,
        ja = (e) =>
          (e.length > Da ? e.split("\n") : [e]).some(
            (e) => !!Fa.test(e.length > Da ? e.substr(Da) : e)
          ),
        Pa = {},
        La = {
          bundle: (e, t) => {
            let n,
              r = Pa[e.uuid],
              s = !0;
            if (r) return r;
            let {
              includes: i,
              matches: o,
              requires: a,
              resources: l,
              excludes: c,
              connects: u,
              textContent: A,
              ...d
            } = e;
            const h = JSON.parse(JSON.stringify(e.options));
            let p, f;
            return (
              (h.run_at =
                h.run_at || e.options.override.orig_run_at || "document-idle"),
              (d.options = h),
              (r = no
                .getResources(d.uuid, e.resources)
                .then(
                  (t) => (
                    s &&
                      !t.sync &&
                      (w.log(
                        "ri: uncached @external detected -> fast script start disabled"
                      ),
                      (s = t.sync)),
                    (p = t.elements),
                    no.getRequires(d.uuid, e.requires)
                  )
                )
                .then((e) => {
                  s &&
                    !e.sync &&
                    (w.log(
                      "ri: uncached @external detected -> fast script start disabled"
                    ),
                    (s = e.sync)),
                    (f = e.elements),
                    w.log("run script " + d.name + " @ " + t);
                  const n = { resources: p, requires: f, ...d };
                  return (
                    null === h.compat_powerful_this &&
                      (h.compat_powerful_this =
                        ja(A) || f.some((e) => ja(e.textContent))),
                    ((e, t, n) => {
                      const r = R(),
                        s = [];
                      n.forEach((t) => {
                        let n = t.textContent || "";
                        (n = Ua.mkCompat(
                          n,
                          e.options.compatopts_for_requires ? e : void 0,
                          "off" != un.values.runtime_strict_mode
                        )),
                          s.push({ textContent: n });
                      });
                      const i = Cd.getStorageByUid(e.uuid);
                      let o = Ua.mkCompat(
                        t,
                        e,
                        "off" != un.values.runtime_strict_mode
                      );
                      if (un.values.debug) {
                        const e = o.split("\n");
                        let t,
                          n = !1;
                        for (let r = 0; r < e.length; r++) {
                          const s = e[r];
                          if (
                            !s.match(
                              /^\s*$|^\s*\/\/\s*|^\s*\/\*.*\*\/\s*$|^\s*["']+use strict["']+;*\s*$/
                            )
                          ) {
                            if ((s.match(/^\s*\/\*/) && (n = !0), !n)) {
                              e[r] = "debugger;" + e[r];
                              break;
                            }
                            if (s.match(/\*\/\s*$/)) n = !1;
                            else if (-1 != (t = s.search(/\*\//))) {
                              e[r] = Vt(e[r], t + 2, 0, "debugger;");
                              break;
                            }
                          }
                        }
                        o = e.join("\n");
                      }
                      const a =
                        z(e.name.replace(/[() -]+/g, "-")).replace(/-$/g, "") +
                        ".user.js";
                      let l;
                      l =
                        ze.getURL("userscript.html") +
                        "?" +
                        Dn({ name: a, id: e.uuid });
                      const c = {
                        code: o,
                        storage: i,
                        script: { ...e, requires: s },
                        source_url: l,
                      };
                      return r.resolve(c), r.promise();
                    })(n, A, f)
                  );
                })
                .always(() => {
                  (n = !0), delete Pa[d.uuid];
                })),
              n || (Pa[d.uuid] = r),
              r
            );
          },
        },
        Na = La,
        Va = "root",
        za = ["http://*/*", "https://*/*", "file://*/*"];
      let qa,
        Ha,
        Qa,
        Wa = {},
        Xa = {};
      const Ya = (e, t) => {
          const n = e.id;
          if (Wa[n]) {
            const t = e;
            delete t.id, Ka.update(n, t);
          } else Ka.create(e);
          (Xa[n] = !0), X(t, 1);
        },
        Ja = () => {
          const e = R();
          return (
            Ka.removeAll(() => {
              (qa = void 0), (Wa = {}), e.resolve();
            }),
            e.promise()
          );
        };
      let Ka;
      const $a = (e) => {
          if (!k.late)
            return (
              k.registerLateCallback(() => {
                $a(e);
              }),
              !0
            );
          let { id: t, frameId: n, tab: r, url: s, isMenuCommand: i } = e;
          if (i) {
            const e = Ia.getById(t);
            e
              ? Sa.emit("run", {
                  menuId: e.menuId,
                  event: {
                    keyCode: void 0,
                    button: 0,
                    shiftKey: !1,
                    metaKey: !1,
                    altKey: !1,
                    ctrlKey: !1,
                  },
                })
              : w.warn("bg: Error: unable to find MC id " + t);
          } else {
            const e = Cd.getByUid(t);
            if (!e || !e.script)
              return void w.log("ctxm: unable to find script " + t);
            const i = e.script;
            if (i.deleted) return;
            Na.bundle(i, s || "<unknown>").then((e) => {
              const t = R(),
                i = {};
              let o;
              void 0 !== n ? (n = i.frameId = n) : s ? (s = Fn(s)) : (o = !0);
              const a = ud(r),
                l = {
                  method: "executeScript",
                  url: s,
                  frameId: n,
                  topframe: o,
                  info: Ll(
                    { contexters: [], runners: [e] },
                    s,
                    a,
                    r.cookieStoreId
                  ),
                };
              return tt(r.id, l, i, t.resolve), t.promise();
            });
          }
        },
        el = {
          init: () =>
            !0 === wt.supported
              ? ((Ka = wt),
                Ka.onClicked.addListener((e, t) => {
                  w.debug(e, t),
                    t &&
                      e.menuItemId &&
                      e.parentMenuItemId &&
                      $a &&
                      $a({
                        id: e.menuItemId,
                        tab: t,
                        frameId: e.frameId,
                        url: e.frameUrl || e.pageUrl,
                        isMenuCommand: e.parentMenuItemId != Va,
                      });
                }),
                Ja())
              : R.Pledge(),
          clean: (e) => {
            const t = R();
            return (
              e.forEach((e) => {
                Ka.remove(e, () => {
                  const e = qe.lastError;
                  e && w.warn(e.message), t.resolve();
                });
              }),
              t.promise()
            );
          },
          update: ({ contexters: e, commands: t }) => {
            if (Ha) {
              Qa && Qa.deferred.reject();
              const n = R();
              return (
                (Qa = { contexters: e, commands: t, deferred: n }), n.promise()
              );
            }
            if (!e.length && !t.length) return Ja();
            const n = Object.keys(Wa);
            return (
              (Xa = {}),
              (Ha = R.Pledge()
                .then(
                  () =>
                    qa ||
                    (() => {
                      const e = R();
                      return (
                        Ja().then(() => {
                          const t = (qa = Ka.create(
                            {
                              id: Va,
                              contexts: ["all"],
                              title: "Tampermonkey",
                              type: "normal",
                              documentUrlPatterns: za,
                            },
                            () => {
                              e.resolve(t);
                            }
                          ));
                        }),
                        e.promise()
                      );
                    })()
                )
                .then(() => {
                  if (t.length)
                    return R.when(
                      t.map((e) =>
                        ((e, t) =>
                          R.Pledge().then(() => {
                            const n = R();
                            return (
                              Ya(
                                {
                                  id: e,
                                  parentId: Va,
                                  contexts: ["all"],
                                  title: `🛠 ${t}`,
                                  type: "normal",
                                  documentUrlPatterns: za,
                                },
                                () => n.resolve()
                              ),
                              n.promise()
                            );
                          }))(e.uuid, e.scriptName)
                      )
                    );
                })
                .then(() =>
                  ((e, t) => {
                    const n = [];
                    for (const t of e) {
                      const e = R();
                      Ya(
                        {
                          id: t.uuid,
                          contexts: ["all"],
                          parentId: Va,
                          title: `🖱 ${Dr.getTranslation(t, "name")}`,
                          type: "normal",
                          documentUrlPatterns: za,
                        },
                        () => e.resolve()
                      ),
                        n.push(e.promise());
                    }
                    for (const e of t) {
                      const t = R();
                      let r;
                      try {
                        const t = new RegExp(
                          "^" + Pt(e.scriptName) + "[ -:+/]*"
                        );
                        r = e.name.replace(t, "");
                      } catch (e) {
                        w.warn(e);
                      }
                      const s = {
                        id: e.menuId,
                        contexts: ["all"],
                        parentId: e.uuid,
                        title: `🔧 ${r || e.name}`,
                        type: "normal",
                        documentUrlPatterns: za,
                      };
                      Ya(s, () => t.resolve()), n.push(t.promise());
                    }
                    return R.when(n).then(() => {});
                  })(e, t)
                )
                .always(() => {
                  const e = Wt(Object.keys(Xa), n, "notinfirst");
                  e.length && el.clean(e), (Wa = Xa);
                  const t = Qa;
                  (Ha = Qa = void 0),
                    t && el.update(t).then(t.deferred.resolve);
                })),
              Ha
            );
          },
        },
        tl = el,
        nl = {
          check: (e, t, n) => {
            if (!e && un.values.scriptUpdateCheckPeriod <= 0) return R.Breach();
            let r,
              s,
              i = Pi();
            return !e &&
              Date.now() - i.scripts <
                Math.max(un.values.scriptUpdateCheckPeriod, 36e5)
              ? R.Breach()
              : R.Pledge()
                  .then(() => {
                    const e = () => {
                      s = void 0;
                      const e = Dr.getMessage("Script_Update"),
                        t = Dr.getMessage("Waiting_for_sync_to_finish") + "...";
                      s = Qs(e, t, vs("tampermonkey"), { timeout: 6e4 });
                    };
                    if (Ea.enabled) {
                      const n = R();
                      return (
                        di.once("syncFinished", () => n.resolve()),
                        Ea.sync(50, !1),
                        t && (r = X(e, 500)),
                        n.promise()
                      );
                    }
                  })
                  .then(() => {
                    if (e) return;
                    const t = R(),
                      n = () => {
                        kt(15, (e) => {
                          "active" == e ? X(n, 1e3 * Math.round(7.5)) : r();
                        });
                      },
                      r = () => {
                        let e;
                        nt.supported
                          ? nt.getAll({}, (r) => {
                              r.forEach((t) => {
                                "fullscreen" === t.state && (e = !0);
                              }),
                                e ? X(n, 15e3) : t.resolve();
                            })
                          : t.resolve();
                      };
                    return n(), t.promise();
                  })
                  .then(() => {
                    const o = R();
                    return (
                      r && (L(r), (r = void 0)),
                      s && s.cancel(),
                      ((e, t, n) => {
                        let r = 0,
                          s = 0,
                          i = 0;
                        const o = Dr.getMessage("Script_Update"),
                          a =
                            Dr.getMessage("Check_for_userscripts_updates") +
                            "...";
                        e && Qs(o, a, vs("tampermonkey"), { timeout: 1e4 });
                        const l = (t ? [t] : Cd.getUidList()).map((e) => {
                          let o, a;
                          return (() => {
                            const { script: s, cond: i } = Cd.getByUid(e);
                            if (!s || !i)
                              return (
                                w.warn(
                                  "update: inconsistent script entry",
                                  e,
                                  s,
                                  i
                                ),
                                R.Breach()
                              );
                            if (((o = s), o.deleted)) return R.Breach();
                            const l =
                                (!un.values.scriptUpdateCheckDisabled &&
                                  !o.enabled &&
                                  !t) ||
                                !o.options.check_for_updates,
                              c = !!o.options.user_modified;
                            if (
                              (!n && (l || c)) ||
                              !(a = vu.determineSourceURL(o))
                            )
                              return R.Breach();
                            if (
                              o.evilness &&
                              o.evilness >=
                                Math.min(
                                  Wi.SEVERITY_MAX,
                                  un.values.script_blacklist_severity
                                )
                            )
                              return R.Breach();
                            let u, A;
                            return (u = vu.determineOrigin(o)) &&
                              (A = os[u.token]) &&
                              !A.updates(a)
                              ? R.Breach()
                              : (r++,
                                w.info("update: check for script updates @", e),
                                R.Pledge());
                          })()
                            .then(() => {
                              const e = vu.determineMetaURL(o);
                              if (!e) return R.Pledge(void 0);
                              if ("none" == e)
                                return (
                                  w.debug(
                                    "update: ignore non-updatable script",
                                    o.name
                                  ),
                                  R.Breach()
                                );
                              const t = R(),
                                n = {
                                  method: "GET",
                                  retries: Oe.RETRIES,
                                  timeout: 6e4,
                                  revalidate: !0,
                                  headers: {
                                    Accept: "text/x-userscript-meta, */*",
                                  },
                                  url: e,
                                };
                              return (
                                cd.internal(n, {
                                  ondone: (n) => {
                                    let r;
                                    var s;
                                    4 == n.readyState &&
                                    200 == n.status &&
                                    n.responseText
                                      ? ((s = n.responseText), (r = Kr(s)))
                                      : w.warn(
                                          "update: unable to find meta data @ " +
                                            e +
                                            " req.status = " +
                                            n.status
                                        ),
                                      t.resolve(r);
                                  },
                                }),
                                t.promise()
                              );
                            })
                            .then((e) =>
                              e &&
                              e.version &&
                              o.version &&
                              es(e.version, o.version) != es.eNEWER
                                ? (w.verbose(
                                    "update: version of script " +
                                      o.name +
                                      " has NOT changed."
                                  ),
                                  R.Breach())
                                : (w.verbose(
                                    "update: version of script " +
                                      o.name +
                                      " has changed or doesn't exist -> running version check!"
                                  ),
                                  R.Pledge())
                            )
                            .then(() => {
                              let e;
                              if (a && (e = Zn(a))) {
                                if (e.protocol.match(/(https?|file):/))
                                  return fd(a).fail(() => {
                                    w.warn("update: failed", o.name, a);
                                  });
                                w.warn("update: can't download URL", o.name, a);
                              } else
                                w.warn("update: can't parse URL", o.name, a);
                            })
                            .then((e) => {
                              if (
                                e &&
                                ((e, t) => {
                                  const n = ts(t);
                                  if (!n || !n.name || void 0 === n.version)
                                    return es.eERROR;
                                  let r;
                                  if ((r = Cd.getMetaByUid(e))) {
                                    if (r.system) return;
                                    return n.version == r.version
                                      ? es.eEQUAL
                                      : es(n.version, r.version);
                                  }
                                  return es.eNEWER;
                                })(o.uuid, e) == es.eNEWER
                              ) {
                                s++;
                                const t = {
                                  name: Dr.getTranslation(o, "name"),
                                  url: a,
                                  code: e,
                                };
                                return R.Pledge(t);
                              }
                              return R.Breach();
                            })
                            .then((e) => {
                              if (un.values.notification_silentScriptUpdate)
                                return R.Pledge(e);
                              {
                                const t =
                                    Dr.getMessage(
                                      "There_is_an_update_for_0name0_avaiable_",
                                      e.name
                                    ) +
                                    "\n" +
                                    Dr.getMessage("Click_here_to_install_it_"),
                                  n =
                                    Dr.getMessage(
                                      "Just_another_service_provided_by_your_friendly_script_updater_"
                                    ) + ":",
                                  r = R();
                                return (
                                  Qs(
                                    n,
                                    t,
                                    vs("tampermonkey"),
                                    {
                                      timeout:
                                        un.values
                                          .scriptUpdateHideNotificationAfter,
                                    },
                                    (t) => r.resolve(t.clicked ? e : void 0)
                                  ),
                                  r.promise()
                                );
                              }
                            })
                            .then((t) => {
                              const n = e || o.uuid;
                              return t
                                ? vu
                                    .doSave({
                                      url: t.url,
                                      uuid: n,
                                      replace: !n,
                                      src: t.code,
                                      ask: !un.values
                                        .notification_silentScriptUpdate,
                                    })
                                    .done((e) => {
                                      e && e.installed && i++;
                                    })
                                : R.Breach();
                            });
                        });
                        return (
                          r &&
                            $s.all("status", {
                              key: "script_update",
                              class: "information",
                              title: o,
                              text: a,
                              timeout: 1e4,
                            }),
                          R.sidebyside(l).then(
                            () => (
                              l.length &&
                                0 == s &&
                                (w.debug("No update found"),
                                e &&
                                  Qs(
                                    "Narf!",
                                    Dr.getMessage("No_update_found__sry_"),
                                    vs("tampermonkey"),
                                    { timeout: 1e4 }
                                  ),
                                $s.all("status", {
                                  key: "script_update",
                                  class: "information",
                                  text: Dr.getMessage("No_update_found__sry_"),
                                  timeout: 1e4,
                                })),
                              { found: s, installed: i }
                            )
                          )
                        );
                      })(t, n, !(!e || !n))
                        .done((e) => {
                          o.resolve(e.installed);
                        })
                        .fail(() => {
                          o.resolve(void 0);
                        }),
                      (i = Pi()),
                      (i.scripts = Date.now()),
                      Li(i),
                      o.promise()
                    );
                  });
          },
          init: () => {
            Ni.on("suc", () => {
              nl.check();
            }),
              Ni.schedule("suc", { periodInMinutes: 60, keepExistent: !0 });
          },
        },
        rl = nl;
      K.trup = rl;
      const sl = rl,
        il = {},
        ol = (e, t) => {
          const n = (il[e] = il[e] || {});
          return (n[t] = n[t] || {});
        },
        al = (e) => {
          const t = {};
          for (const n of Object.keys(il).map(Number)) t[n] = il[n][e];
          return t;
        },
        ll = 12096e5,
        cl = ["contributed", "later", "hide"];
      let ul;
      const Al = {
          init: () => {
            let e;
            ul = Ot.getValue(Ze.STORAGE.BEGGING);
            const t = Date.now();
            ul
              ? (e = parseInt(Ot.getValue(Ze.STORAGE.LAST_START, "0"))) &&
                t - e > ll &&
                ((ul.later = { type: "after_pause", ts: t }), Al.save())
              : ((ul = { first_run: { type: "from_init", ts: t } }), Al.save());
          },
          save: () => {
            ul && Ot.setValue(Ze.STORAGE.BEGGING, ul);
          },
          needed: () => {
            const e = Date.now(),
              t = !ul.first_run || ul.first_run.ts + ll < e,
              n = !ul.hide,
              r = !ul.contributed,
              s = !ul.later || ul.later.ts + ll < e;
            if (t && n && r && s) return ul.later ? "l" : "i";
          },
          clicked: (e, t, n) => {
            _r("clicked", e, t + n);
          },
          dialog: {
            shown: (e) => {
              const t = Date.now();
              (ul.dialog = { ts: t, extra: e }), Al.save(), _r("dialog");
            },
          },
          button: (() => {
            const e = {};
            for (const t of cl)
              e[t] = (e, n) => {
                const r = Date.now();
                (ul[t] = { ts: r, type: e, extra: n }),
                  Al.save(),
                  _r("button", t);
              };
            return e;
          })(),
        },
        dl = Al,
        hl = {
          create: (e, t) => {
            const n = e || "",
              r = t || {},
              s = (e) =>
                R.onebyone(e)
                  .fail(() => {
                    w.warn("tree: wait failed!");
                  })
                  .then((e) =>
                    e.filter((e) => e).reduce((e, t) => e.concat(t), [])
                  ),
              i = (e, t) => {
                const n = e.replace(/\.$/, "").split(".");
                let s = l;
                for (; n.length; ) {
                  const i = n.shift();
                  if (void 0 === i) throw Error("invalid path segment");
                  const o = s[i];
                  if (!o)
                    return (
                      w.warn("tree: unable to find", e, r), () => R.Pledge([])
                    );
                  if ("function" == typeof o) return () => o(r, !t);
                  (s = o), n.length || n.unshift("root");
                }
                return w.warn("tree: unable to find", e, r), () => R.Pledge([]);
              },
              o = {
                root: (e) => {
                  const t = R();
                  return (
                    $e(null, (n) => {
                      n && n.id >= 0
                        ? (r.tab = n)
                        : e &&
                          e.tabId &&
                          (r.tab = {
                            id: e.tabId,
                            index: -1,
                            url: "",
                            windowId: -1,
                          });
                      const o = s([
                        i("actions.general"),
                        i("actions.scripts"),
                        i("actions.commands"),
                      ]);
                      t.consume(o);
                    }),
                    t.promise()
                  );
                },
                general: () => {
                  const e = r.tab,
                    t = e ? e.url : null,
                    n =
                      t &&
                      t.length > 4 &&
                      "" == t.substr(0, 4).replace(/file|http/, "")
                        ? t
                        : "",
                    s = [],
                    i = {
                      name: "enabled",
                      id: "enabled",
                      sub_menu_item: !0,
                      pos: "top",
                      items: [],
                      tabId: null == e ? void 0 : e.id,
                    };
                  let o;
                  i.items.push({
                    name: Dr.getMessage("Enabled"),
                    display: un.values.enabled ? void 0 : "greyed",
                    id: "enabled",
                    button: !0,
                    reload: !0,
                    enabler: !0,
                  }),
                    (i.items = i.items.concat(
                      $s
                        .actionStatus()
                        .map((e) => ({ options: e, globalhint: !0 }))
                    )),
                    s.push(i),
                    !t ||
                      !hd(t, !0) ||
                      ((o = hd(t)) &&
                        "manual" != un.values.scriptUrlDetection) ||
                      i.items.push({
                        name: Dr.getMessage(
                          o ? "Install_this_script" : "Try_to_install_as_script"
                        ),
                        image: "script_download",
                        id: "installFromUrl",
                        data: { url: t },
                        button: !0,
                        reload: !0,
                      });
                  const a = {
                    name: "about",
                    id: "about",
                    sub_menu_item: !0,
                    pos: "bottom",
                    items: [],
                  };
                  a.items.push({
                    name: Dr.getMessage("Dashboard"),
                    image: "utilities",
                    url:
                      ze.getURL("options.html") +
                      "#" +
                      ["url=" + he(n), "nav=dashboard"].join("&"),
                    url_alt: (null == e ? void 0 : e.url)
                      ? ze.getURL("options.html") +
                        "#" +
                        [
                          "filter=" + z(e.url),
                          "url=" + he(n),
                          "nav=dashboard",
                        ].join("&")
                      : void 0,
                    newtab: !0,
                  });
                  const l =
                    "version=" + ze.manifest.version + "&ext=" + qe.short_id;
                  return (
                    a.items.push({
                      image: "about",
                      id: "about",
                      urls: [
                        {
                          name: " " + Dr.getMessage("Help"),
                          url: "https://www.tampermonkey.net/faq.php?" + l,
                          newtab: !0,
                        },
                        {
                          name: " " + Dr.getMessage("Changelog"),
                          url:
                            "https://www.tampermonkey.net/changelog.php?" + l,
                          newtab: !0,
                        },
                        { social: !0, newtab: !0 },
                      ],
                    }),
                    s.push(a),
                    R.Pledge(s)
                  );
                },
                scripts: {
                  root: (e) => {
                    const t = r.tab,
                      n = t ? t.url : null,
                      s = [],
                      i = n ? Zn(n) : null,
                      o =
                        i && ["http:", "https:", "file:"].includes(i.protocol)
                          ? Fn(i)
                          : "",
                      a = {
                        name: "scripts",
                        id: "scripts",
                        sub_menu_item: !0,
                        pos: "center",
                        items: [],
                      },
                      l = {},
                      c = {},
                      u = {},
                      A = {},
                      d = {},
                      h = i
                        ? Fe.INTERNAL_PAGE_PROTOCOLS.includes(i.protocol)
                        : null;
                    if (t) {
                      const e = gc(t);
                      Object.keys(e).forEach((t) => {
                        const n = e[t];
                        (A[t] = n),
                          (d[t] = "z" + n.name.toLowerCase() + n.position);
                      });
                      const n = mc(t);
                      Object.keys(n).forEach((e) => {
                        const t = n[e];
                        (l[e] = t.urls), (c[e] = t.count), (u[e] = t.all_time);
                        let r = A[e];
                        if (!r) {
                          const t = Cd.getByUid(e);
                          t.script && t.cond && !t.script.deleted
                            ? (A[e] = r = t.script)
                            : (A[e] = r =
                                {
                                  ...rs(),
                                  uuid: e,
                                  name: Dr.getMessage(
                                    "This_script_was_deleted"
                                  ),
                                  enabled: !0,
                                  deleted: Date.now(),
                                  textContent: "",
                                  resources: [],
                                  requires: [],
                                });
                        }
                        d[e] = "a" + r.name.toLowerCase() + r.position;
                      });
                    }
                    let p;
                    p =
                      "position" == un.values.action_menu_scripts_sort
                        ? (e, t) => e.position - t.position
                        : "name" == un.values.action_menu_scripts_sort
                        ? (e, t) =>
                            e.name.toLowerCase() < t.name.toLowerCase()
                              ? -1
                              : e.name.toLowerCase() > t.name.toLowerCase()
                              ? 1
                              : 0
                        : "enabled" == un.values.action_menu_scripts_sort
                        ? (e, t) =>
                            1e4 * (e.enabled ? 0 : 1) +
                            e.position -
                            (1e4 * (t.enabled ? 0 : 1) + t.position)
                        : (e, t) => d[e.uuid].localeCompare(d[t.uuid]);
                    const f = Object.values(A).sort(p);
                    let m = pu(f, {
                      active_urls: l,
                      active_counts: c,
                      all_time_active_counts: u,
                    });
                    const g = t ? Ia.convertToMenuItems(t.id) : {};
                    let v;
                    un.values.action_menu_scripts_hide_disabled &&
                      (m = m.filter((e) => e.enabled || c[e.uuid])),
                      m.forEach((e) => {
                        let t;
                        (t = g[e.uuid]) && (e.menu_cmds = t);
                      }),
                      !un.values.action_menu_scripts_hide_disabled &&
                      Math.min(
                        un.values.action_menu_columns,
                        (e ? e.available_columns : null) || 99
                      ) > 2
                        ? ((v = {
                            name: "scripts_right",
                            id: "scripts_right",
                            sub_menu_item: !0,
                            pos: "right",
                            items: [],
                          }),
                          m.forEach((e) => {
                            e.enabled || c[e.uuid]
                              ? a.items.push(e)
                              : v.items.push(e);
                          }),
                          s.push(a),
                          v.items.length && s.push(v))
                        : ((v = a), (a.items = a.items.concat(m)), s.push(a)),
                      un.values.enabled &&
                        !m.length &&
                        n &&
                        (h
                          ? a.items.push({
                              name: Dr.getMessage(
                                "Tampermonkey_has_no_access_to_this_page"
                              ),
                              image: "no_script",
                              class: "disabled",
                            })
                          : eu.isAllowed(n)
                          ? a.items.push({
                              name: Dr.getMessage("No_script_is_running"),
                              image: "no_script",
                              class: "disabled",
                            })
                          : a.items.push({
                              name: Dr.getMessage(
                                "This_page_is_blacklisted_at_the_security_settings"
                              ),
                              image: "critical",
                              class: "disabled",
                            }));
                    const _ = Dr.getLocale();
                    if (un.values.enabled) {
                      let e;
                      m.length
                        ? ((e = {
                            name: "scripts_new",
                            id: "scripts_new",
                            sub_menu_item: !0,
                            pos: "center",
                            items: [],
                          }),
                          s.push(e))
                        : (e = a);
                      const t = !!un.values.userscript_search_url,
                        n = un.values.userscript_search_mode;
                      t && o && "click" == n
                        ? e.items.push({
                            name: Dr.getMessage(
                              "Search_for_userscripts_for_this_tab"
                            ),
                            image: "script_search",
                            data: { url: o },
                            id: "script_search",
                            button: !0,
                          })
                        : t && o && ["action_menu", "badge"].includes(n)
                        ? e.items.push({
                            name: Dr.getMessage(
                              "Searching_for_userscripts_for_this_tab"
                            ),
                            image: "script_search",
                            data: { url: o },
                            id: "script_search",
                            class: "disabled",
                            partial: !0,
                            referrer: "actions.script_search",
                          })
                        : e.items.push({
                            name: Dr.getMessage("Get_new_scripts___"),
                            image: "script_search",
                            url:
                              "https://www.tampermonkey.net/scripts.php" +
                              (_ ? "?locale=" + _ : ""),
                            newtab: !0,
                          }),
                        e.items.push({
                          name: Dr.getMessage("Add_new_script___"),
                          image: "script_add",
                          url:
                            ze.getURL("options.html") +
                            "#nav=new-user-script" +
                            (h ? "" : "&url=" + he(o)),
                          newtab: !0,
                        });
                    }
                    return R.Pledge(s);
                  },
                },
                script_search: {
                  root: async (e) => {
                    let t;
                    const n = null == e ? void 0 : e.url;
                    let r, s;
                    return (
                      (t = n ? await xo(n) : { count: 0 }),
                      t.error || !t.url
                        ? ((r = Dr.getMessage(
                            "Search_for_userscripts_for_this_tab"
                          )),
                          (s = { url: n }))
                        : ((r = t.count
                            ? Dr.getMessage(
                                "Found_0count0_available_scripts",
                                t.count
                              )
                            : Dr.getMessage("No_available_scripts")),
                          (s = { result_url: t.url })),
                      [
                        {
                          name: r,
                          data: s,
                          button: !0,
                          image: "script_search",
                          id: "script_search",
                        },
                      ]
                    );
                  },
                },
                commands: () => {
                  const e = [],
                    t = {
                      name: "commands",
                      id: "commands",
                      sub_menu_item: !0,
                      pos: "left",
                      items: [],
                    },
                    n = {
                      name: Dr.getMessage("Utilities"),
                      id: "commands",
                      sub_menu_item: !0,
                      more_menu: !0,
                      pos: "left",
                      items: [],
                    };
                  if (
                    (n.items.push({
                      name: Dr.getMessage("Check_for_userscripts_updates"),
                      id: "run_script_updates",
                      button: !0,
                      image: "update",
                    }),
                    un.values.configMode >= 80 &&
                      n.items.push({
                        name: Dr.getMessage("Report_a_bug"),
                        image: "bug",
                        url: "https://www.tampermonkey.net/bug",
                        newtab: !0,
                      }),
                    un.values.configMode >= 50)
                  ) {
                    let e, t, s, i;
                    ["black", "black+white"].includes(
                      un.values.page_filter_mode
                    ) &&
                      (e = r.tab) &&
                      (t = e.url) &&
                      (s = Zn(t)) &&
                      !Fe.INTERNAL_PAGE_PROTOCOLS.includes(s.protocol) &&
                      (i = s.hostname) &&
                      eu.isAllowed(t) &&
                      n.items.push({
                        name: Dr.getMessage("Blacklist_0domain0", i),
                        image: "no",
                        button: !0,
                        id: "blacklist_page",
                        data: { domain: i },
                      });
                  }
                  return (
                    t.items.push({
                      name: Dr.getMessage("Please_consider_a_contribution"),
                      image: "contrib",
                      button: !0,
                      id: "contrib",
                    }),
                    t.items.push(n),
                    e.push(t),
                    R.Pledge(e)
                  );
                },
              },
              a = {
                root: () =>
                  s([
                    i("options.general"),
                    i("options.verification"),
                    i("options.scripts"),
                    i("options.settings"),
                    i("options.trash"),
                  ]),
                general: function () {
                  let e,
                    t,
                    n = [];
                  return (
                    ze.inIncognitoContext &&
                    "temporary" == un.values.incognito_mode
                      ? n.push({
                          globalhint: !0,
                          options: {
                            id: "incognito",
                            image: "critical",
                            text: Dr.getMessage(
                              "All_modifications_are_only_kept_until_this_incognito_session_is_closed_"
                            ),
                          },
                        })
                      : (e = $s
                          .optionsStatus()
                          .map((e) => ({ globalhint: !0, options: e }))) &&
                        e.length
                      ? (n = n.concat(e))
                      : (t = ui.updateAvailable()) &&
                        n.push({
                          globalhint: !0,
                          options: {
                            id: "extensionupdate",
                            image: "info",
                            class: "information",
                            text: Dr.getMessage(
                              "0name0_0version0_is_available__Please_re_start_your_browser_to_update_",
                              ze.manifest.name,
                              t
                            ),
                          },
                        }),
                    R.Pledge(n)
                  );
                },
                verification: () => {
                  const e = [];
                  return (
                    hs().forEach((t) => {
                      e.push({
                        globalhint: !0,
                        options: {
                          image: "critical",
                          class: "warning",
                          text: t.text,
                          title: t.description,
                          info_url: t.url,
                        },
                      });
                    }),
                    R.Pledge(e)
                  );
                },
                scripts: {
                  root: (e, t) => {
                    const n = R(),
                      r = {
                        name: Dr.getMessage("Installed_userscripts"),
                        main_menu_item: !0,
                        id: "dashboard",
                        items: [],
                      };
                    return (
                      ((null == e ? void 0 : e.complete) || !t
                        ? s(
                            [
                              "options.scripts.userscripts",
                              "options.scripts.new",
                            ].map((e) => i(e))
                          )
                        : ((r.referrer = "options.scripts"),
                          (r.partial = !0),
                          s([i("options.scripts.new")]))
                      )
                        .done((e) => {
                          (r.items = e), n.resolve([r]);
                        })
                        .fail(n.reject),
                      n.promise()
                    );
                  },
                  new: () => {
                    const e = [];
                    return (
                      e.push({
                        id: "new-script",
                        name: Dr.getMessage("New_userscript"),
                        image: "script_add",
                        title: Dr.getMessage("Add_new_script___"),
                        icon: gs("unknown"),
                        nnew: !0,
                        uuid: "new-user-script",
                        position: -1,
                        positionof: Te.MAX_SCRIPTS,
                        enabled: !0,
                        userscript: !0,
                      }),
                      R.Pledge(e)
                    );
                  },
                  userscripts: {
                    root: (e, t) => {
                      const n =
                          (null == e ? void 0 : e.complete) || !t
                            ? void 0
                            : "options.scripts.userscripts",
                        r = vu
                          .determineScriptsToRun()
                          .filter((e) => !e.deleted),
                        s = pu(r, { options_page: !0, referrer: n }),
                        i = s.length,
                        o = Dr.getLocale();
                      return (
                        s.push({
                          id: "no-script-installed",
                          name: Dr.getMessage("No_script_is_installed"),
                          image: "info",
                          class: "disabled",
                          visible: !i,
                        }),
                        s.push({
                          id: "get-some-scripts",
                          name: Dr.getMessage("Get_some_scripts___"),
                          image: "edit_add",
                          url:
                            "https://www.tampermonkey.net/scripts.php" +
                            (o ? "?locale=" + o : ""),
                          newtab: !0,
                          visible: !i,
                        }),
                        R.Pledge(s)
                      );
                    },
                    matches: (e) => {
                      const { filter: t, uuid: n } = e || {};
                      let r;
                      if (!t || !t.code) return R.Pledge([]);
                      const s = /\/(.*)\/(.*)/.exec(t.code);
                      if (!s) return R.Pledge([]);
                      const i = new RegExp(s[1], s[2]);
                      if (n) {
                        const e = Cd.getByUid(n);
                        e.script && e.cond && (r = [e.script]);
                      } else
                        r = vu
                          .determineScriptsToRun()
                          .filter((e) => !e.deleted);
                      if (r) {
                        const e = r
                          .map((e) =>
                            -1 != e.textContent.search(i) ? e.uuid : null
                          )
                          .filter((e) => e);
                        return R.Pledge(e);
                      }
                      return R.Pledge([]);
                    },
                    source: (e) => {
                      if (!(null == e ? void 0 : e.uuid)) return R.Pledge([]);
                      const t = Cd.getByUid(e.uuid);
                      if (t.script && t.cond) {
                        let e;
                        return (
                          (e = un.values.showFixedSrc
                            ? Ua.mkCompat(
                                t.script.textContent,
                                t.script,
                                "off" != un.values.runtime_strict_mode
                              )
                            : t.script.textContent),
                          R.Pledge([e])
                        );
                      }
                      return w.warn("tree: unable to process ", t), R.Breach();
                    },
                    storage: (e) => {
                      if (!(null == e ? void 0 : e.uuid)) return R.Pledge([]);
                      const t = Cd.getStorageByUid(e.uuid);
                      return R.Pledge([t ? t.data : {}]);
                    },
                    external: (e) => {
                      const { uuid: t, url: n } = e || {};
                      if (!t) return R.Pledge([]);
                      const r = Cd.getByUid(t);
                      if (r.script && r.cond) {
                        let e;
                        return (
                          [...r.script.requires, ...r.script.resources].some(
                            (r) => {
                              const s = r.url || Un(r.unsafe_url, r.abs_url);
                              if (!s || s != n) return;
                              const i = no.getElement(t, s);
                              return i && i.data && i.data.content
                                ? ((e = i.data.content), !0)
                                : void 0;
                            }
                          ),
                          R.Pledge([e])
                        );
                      }
                      return w.warn("tree: unable to process ", r), R.Breach();
                    },
                  },
                },
                trash: (() => {
                  const e = () =>
                    "off" === un.values.trash_mode
                      ? []
                      : vu.determineScriptsToRun().filter((e) => e.deleted);
                  return {
                    root: (t, n) => {
                      const r = R(),
                        o = Dr.getMessage("Trash_bin"),
                        a = {
                          name: o,
                          image: "trash",
                          title: o,
                          main_menu_item: !0,
                          hidden: !e().length,
                          id: "trash",
                          items: [],
                        };
                      return (
                        (() => {
                          if ((null == t ? void 0 : t.complete) || !n) {
                            const e = s(
                              ["options.trash.userscripts"].map((e) => i(e))
                            );
                            return e;
                          }
                          return (
                            (a.referrer = "options.trash"),
                            (a.partial = !0),
                            R.Pledge([])
                          );
                        })()
                          .done((e) => {
                            (a.items = e), r.resolve([a]);
                          })
                          .fail(() => r.reject()),
                        r.promise()
                      );
                    },
                    userscripts: {
                      root: (t, n) => {
                        const r =
                            (null == t ? void 0 : t.complete) || !n
                              ? void 0
                              : "options.trash.userscripts",
                          s = pu(e(), { options_page: !0, referrer: r });
                        return R.Pledge(s);
                      },
                    },
                  };
                })(),
                settings: (e, t) => {
                  const n = R(),
                    r = {
                      name: Dr.getMessage("Settings"),
                      main_menu_item: !0,
                      id: "settings",
                      selected_default: !0,
                      items: [],
                    };
                  return (
                    ((null == e ? void 0 : e.complete) || !t
                      ? R.Pledge(
                          (() => {
                            const e = K.Tests,
                              t = {
                                id: "general",
                                name: Dr.getMessage("General"),
                                sub_menu_item: !0,
                                items: [],
                              };
                            t.items.push({
                              name: Dr.getMessage("Config_Mode"),
                              id: "configMode",
                              level: 0,
                              option: !0,
                              select: [
                                { name: Dr.getMessage("Novice"), value: 0 },
                                { name: Dr.getMessage("Beginner"), value: 50 },
                                { name: Dr.getMessage("Advanced"), value: 100 },
                              ],
                              value: un.values.configMode,
                              desc: Dr.getMessage(
                                "Changes_the_number_of_visible_config_options"
                              ),
                            }),
                              t.items.push({
                                name: Dr.getMessage("Language"),
                                id: "i18n",
                                level: 0,
                                option: !0,
                                reload: !0,
                                warning: Dr.getMessage("A_reload_is_required"),
                                select: [
                                  { name: "Browser Default", value: null },
                                  ...Dr.supported,
                                ],
                                value: un.values.i18n,
                                validation: {
                                  image: "info",
                                  opacity: 0.9,
                                  msg: Dr.getMessage(
                                    "Your_language_is_not_supported__Click_here_to_get_intructions_how_to_translate_TM_"
                                  ),
                                  url: "https://www.tampermonkey.net/faq.php#Q500",
                                },
                              }),
                              t.items.push({
                                name: Dr.getMessage(
                                  "Auto_reload_on_script_enabled"
                                ),
                                level: 20,
                                id: "autoReload",
                                option: !0,
                                checkbox: !0,
                                enabled: un.values.autoReload,
                                desc: Dr.getMessage(
                                  "Auto_reload_on_script_enabled_desc"
                                ),
                              }),
                              t.items.push({
                                name: Dr.getMessage("Anonymous_statistics"),
                                level: 0,
                                id: "statistics_enabled",
                                option: !0,
                                checkbox: !0,
                                enabled: !!un.values.statistics_enabled,
                                validation: {
                                  image: "info",
                                  opacity: 0.9,
                                  msg: Dr.getMessage(
                                    "Allow_Tampermonkey_to_collect_anonymous_statistics"
                                  ),
                                  url: "https://www.tampermonkey.net/privacy.php#extension",
                                },
                              }),
                              t.items.push({
                                name: Dr.getMessage("Debug_scripts"),
                                level: 100,
                                id: "debug",
                                option: !0,
                                checkbox: !0,
                                enabled: un.values.debug,
                                desc: "",
                              }),
                              t.items.push({
                                name: Dr.getMessage("Show_fixed_source"),
                                level: 100,
                                id: "showFixedSrc",
                                option: !0,
                                checkbox: !0,
                                enabled: un.values.showFixedSrc,
                                desc: "",
                              }),
                              (["heif"].includes(Pe.short_id) ||
                                un.values.background_control) &&
                                t.items.push({
                                  name: "Allow userscripts to control the background context",
                                  id: "background_control",
                                  level: un.values.background_control ? 0 : 50,
                                  option: !0,
                                  checkbox: !0,
                                  enabled: un.values.background_control,
                                  validation: {
                                    image: "critical",
                                    msg: "Don't use this option unless you know what you are doing!",
                                  },
                                }),
                              t.items.push({
                                name: Dr.getMessage("LogLevel"),
                                id: "logLevel",
                                level: 0,
                                option: !0,
                                select: [
                                  { name: Dr.getMessage("Debug"), value: 80 },
                                  {
                                    name: Dr.getMessage("Info"),
                                    value: 60,
                                  },
                                  { name: Dr.getMessage("Warning"), value: 30 },
                                  { name: Dr.getMessage("Error"), value: 0 },
                                ],
                                value: un.values.logLevel,
                                desc: "",
                              }),
                              t.items.push({
                                name: Dr.getMessage("Trash_Mode"),
                                id: "trash_mode",
                                level: 50,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Enabled"),
                                    value: "on",
                                  },
                                  {
                                    name: Dr.getMessage("Disabled"),
                                    value: "off",
                                  },
                                  {
                                    name: Dr.getMessage("Clean_after_session"),
                                    value: "session",
                                  },
                                ],
                                value: un.values.trash_mode,
                                desc: Dr.getMessage(
                                  "Controls_how_deleted_scripts_are_handled__0enabled0_moves_scripts_to_a_virtual_trash__0disabled0_permanently_deletes_scripts__0cleanAfterSession0_automatically_deletes_all_on_session_end_",
                                  Dr.getMessage("Enabled"),
                                  Dr.getMessage("Disabled"),
                                  Dr.getMessage("Clean_after_session")
                                ),
                              });
                            const n = {
                              id: "script_sync",
                              name: Dr.getMessage("Script_Sync"),
                              sub_menu_item: !0,
                              level: 50,
                              need_save: !0,
                              items: [],
                            };
                            n.items.push({
                              name: Dr.getMessage("Enable_Script_Sync"),
                              id: "sync_enabled",
                              enabler: !0,
                              level: 50,
                              option: !0,
                              checkbox: !0,
                              enabled: un.values.sync_enabled,
                              desc: Dr.getMessage(
                                "Synchronize_your_scripts_across_browsers_and_operation_systems"
                              ),
                            });
                            const r = (() => {
                              const e = [],
                                t = {
                                  reset_sync: !0,
                                  cloud_url: !1,
                                  cloud_user: !1,
                                  cloud_pass: !1,
                                };
                              return (
                                ut.sync.supported &&
                                  e.push({
                                    name: Dr.getMessage("Browser_Sync"),
                                    value: oa.eCHROMESYNC,
                                    enable: t,
                                  }),
                                e.push({
                                  name: Dr.getMessage("Google_Drive"),
                                  value: oa.eGDRIVE,
                                  enable: t,
                                }),
                                e.push({
                                  name: Dr.getMessage("Dropbox"),
                                  value: oa.eDROPBOX,
                                  enable: t,
                                }),
                                e.push({
                                  name: Dr.getMessage("OneDrive"),
                                  value: oa.eONEDRIVE,
                                  enable: t,
                                }),
                                e.push({
                                  name: Dr.getMessage("Yandex_Disk"),
                                  value: oa.eYANDEX,
                                  enable: t,
                                }),
                                e.push({
                                  name: Dr.getMessage("WebDAV"),
                                  value: oa.eWEBDAV,
                                  enable: {
                                    reset_sync: !0,
                                    cloud_url: !0,
                                    cloud_user: !0,
                                    cloud_pass: !0,
                                  },
                                }),
                                e
                              );
                            })();
                            n.items.push({
                              name: Dr.getMessage("Sync_Type"),
                              id: "sync_type",
                              enabler: !0,
                              level: 50,
                              option: !0,
                              select: r,
                              value: un.values.sync_type,
                            }),
                              n.items.push({
                                name: Dr.getMessage("URL"),
                                id: "cloud_url",
                                enabledBy: "sync_type",
                                level: 50,
                                option: !0,
                                text: !0,
                                width: 2,
                                value: un.values.cloud_url,
                              }),
                              n.items.push({
                                name: Dr.getMessage("Login"),
                                id: "cloud_user",
                                enabledBy: "sync_type",
                                level: 50,
                                option: !0,
                                text: !0,
                                width: 2,
                                value: un.values.cloud_user,
                              }),
                              n.items.push({
                                name: Dr.getMessage("Password"),
                                id: "cloud_pass",
                                enabledBy: "sync_type",
                                level: 50,
                                option: !0,
                                text: !0,
                                password: !0,
                                width: 2,
                                value: un.values.cloud_pass,
                              }),
                              n.items.push({
                                name: Dr.getMessage("Sync_Now"),
                                id: "run_sync",
                                enabledBy: "sync_enabled",
                                needsSave: !0,
                                level: 50,
                                button: !0,
                              }),
                              n.items.push({
                                name: Dr.getMessage("Sync_Reset"),
                                id: "reset_sync",
                                enabledBy: "sync_enabled",
                                needsSave: !0,
                                level: 80,
                                button: !0,
                                reload: !0,
                                warning: Dr.getMessage(
                                  "This_will_remove_all_remote_data_from_sync_Ok_"
                                ),
                              }),
                              n.items.push({
                                name: Dr.getMessage("Recent_Sync_Log"),
                                status: !0,
                                event: "syncProgressEvent",
                                id: "sync_status",
                              });
                            const s = {
                              id: "appearance",
                              name: Dr.getMessage("Appearance"),
                              sub_menu_item: !0,
                              need_save: !0,
                              items: [],
                              warning: Dr.getMessage("A_reload_is_required"),
                              reload: !0,
                            };
                            s.items.push({
                              name: Dr.getMessage("Layout"),
                              id: "layout",
                              level: 0,
                              option: !0,
                              select: ps.map((e) => {
                                const { name: t, theme: n, layout: r } = e;
                                return {
                                  name: t,
                                  value: n ? [r, n].join("#") : r,
                                };
                              }),
                              value: un.values.layout,
                              desc: "",
                            }),
                              s.items.push({
                                name: Dr.getMessage("Custom_CSS"),
                                id: "layout_user_css",
                                level: 100,
                                option: !0,
                                input: !0,
                                value: un.values.layout_user_css,
                                desc: Dr.getMessage(
                                  "You_can_add_your_custom_CSS_rules_here_"
                                ),
                              }),
                              s.items.push({
                                name: Dr.getMessage("Update_Notification"),
                                id: "notification_showUpdate",
                                level: 50,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Disabled"),
                                    value: "off",
                                  },
                                  {
                                    name: Dr.getMessage("Show_notification"),
                                    value: "notification",
                                  },
                                  {
                                    name: Dr.getMessage("Open_changelog"),
                                    value: "changelog",
                                  },
                                ],
                                value: un.values.notification_showUpdate,
                                validation:
                                  "off" == un.values.notification_showUpdate
                                    ? {
                                        image: "critical",
                                        msg: Dr.getMessage(
                                          "Are_you_sure_that_you_don_t_want_to_be_notified_of_updates_"
                                        ),
                                      }
                                    : void 0,
                              }),
                              s.items.push({
                                name: Dr.getMessage("Favicon_Service"),
                                id: "favicon_service",
                                level: 50,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Google"),
                                    value: "google",
                                  },
                                  {
                                    name: Dr.getMessage("DuckDuckGo"),
                                    value: "duckduckgo",
                                  },
                                  {
                                    name: Dr.getMessage("Native"),
                                    value: "native",
                                    warning: Dr.getMessage(
                                      "Warning_unsafe_site_warnings_might_appear_"
                                    ),
                                  },
                                ],
                                value: un.values.favicon_service,
                              });
                            const i = {
                              id: "action_menu",
                              name: Dr.getMessage("Action_Menu"),
                              sub_menu_item: !0,
                              need_save: !0,
                              items: [],
                              level: 50,
                            };
                            i.items.push({
                              name: Dr.getMessage("Hide_disabled_scripts"),
                              id: "action_menu_scripts_hide_disabled",
                              level: 100,
                              option: !0,
                              checkbox: !0,
                              enabled:
                                un.values.action_menu_scripts_hide_disabled,
                              desc: "",
                            }),
                              i.items.push({
                                name: Dr.getMessage("Columns"),
                                id: "action_menu_columns",
                                level: 50,
                                option: !0,
                                select: [
                                  { name: Dr.getMessage("1"), value: 1 },
                                  { name: Dr.getMessage("2"), value: 2 },
                                  { name: Dr.getMessage("3"), value: 3 },
                                ],
                                value: un.values.action_menu_columns,
                              }),
                              i.items.push({
                                name: Dr.getMessage("Script_order"),
                                id: "action_menu_scripts_sort",
                                level: 50,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Auto"),
                                    value: "auto",
                                  },
                                  {
                                    name: Dr.getMessage("Position_"),
                                    value: "position",
                                  },
                                  {
                                    name: Dr.getMessage("Name"),
                                    value: "name",
                                  },
                                  {
                                    name: Dr.getMessage("Enabled"),
                                    value: "enabled",
                                  },
                                ],
                                value: un.values.action_menu_scripts_sort,
                              }),
                              i.items.push({
                                name: Dr.getMessage("Icon_badge_info"),
                                id: "appearance_badges",
                                level: 50,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Disabled"),
                                    value: "off",
                                  },
                                  {
                                    name: Dr.getMessage("Running_scripts"),
                                    value: "running",
                                  },
                                  {
                                    name: Dr.getMessage(
                                      "Unique_running_scripts"
                                    ),
                                    value: "running_unique",
                                  },
                                ],
                                value: un.values.appearance_badges,
                              }),
                              i.items.push({
                                name: Dr.getMessage("Icon_badge_color"),
                                id: "appearance_badge_color",
                                option: !0,
                                level: 100,
                                color: !0,
                                value: un.values.appearance_badge_color,
                              });
                            const o = {
                              id: "context_menu",
                              name: Dr.getMessage("Context_Menu"),
                              sub_menu_item: !0,
                              items: [],
                              level: 50,
                            };
                            let a;
                            o.items.push({
                              name: Dr.getMessage("Enable_context_menu"),
                              id: "context_menu_enabled",
                              level: 50,
                              option: !0,
                              checkbox: !0,
                              enabled: un.values.context_menu_enabled,
                              desc: "",
                            }),
                              o.items.push({
                                name: Dr.getMessage(
                                  "Scripts_activated_by_context_menu"
                                ),
                                id: "context_menu_scripts",
                                level: 50,
                                option: !0,
                                checkbox: !0,
                                enabled: un.values.context_menu_scripts,
                                desc: "",
                              }),
                              o.items.push({
                                name: Dr.getMessage("Script_menu_commands"),
                                id: "context_menu_commands",
                                level: 50,
                                option: !0,
                                checkbox: !0,
                                enabled: un.values.context_menu_commands,
                                desc: "",
                              }),
                              un.values.userscript_search_url &&
                                ((a = {
                                  id: "userscript_search",
                                  name: Dr.getMessage("Userscript_Search"),
                                  sub_menu_item: !0,
                                  level: 0,
                                  items: [],
                                  reload: !0,
                                }),
                                a.items.push({
                                  name: Dr.getMessage(
                                    "Userscript_search_integration_mode"
                                  ),
                                  id: "userscript_search_mode",
                                  level: 0,
                                  option: !0,
                                  select: [
                                    {
                                      name: Dr.getMessage("Disabled"),
                                      value: "off",
                                    },
                                    {
                                      name: Dr.getMessage("On_Click"),
                                      value: "click",
                                    },
                                    {
                                      name: Dr.getMessage("On_Action_Menu"),
                                      value: "action_menu",
                                    },
                                    {
                                      name: Dr.getMessage(
                                        "Add_to_icon_badge_text"
                                      ),
                                      value: "badge",
                                    },
                                  ],
                                  value: un.values.userscript_search_mode,
                                  validation: {
                                    image: "info",
                                    opacity: 0.9,
                                    msg: Dr.getMessage(
                                      "In_order_to_search_for_userscripts__0on_action_menu0__and__0icon_badge_number0__automatically_transfer_the_tab_s_url_to_the_search_website__0on_click0_opens_the_search_page_on_click_Please_click_at_this_icon_to_open_the_privacy_policy_",
                                      Dr.getMessage("Add_to_icon_badge_text"),
                                      Dr.getMessage("On_Action_Menu"),
                                      Dr.getMessage("On_Click")
                                    ),
                                    url: So(),
                                  },
                                }));
                            const l = {
                              id: "editor",
                              name: Dr.getMessage("Editor"),
                              sub_menu_item: !0,
                              level: 20,
                              need_save: !0,
                              items: [],
                              warning: Dr.getMessage("A_reload_is_required"),
                              reload: !0,
                            };
                            l.items.push({
                              name: Dr.getMessage("Enable_Editor"),
                              id: "editor_enabled",
                              level: 100,
                              option: !0,
                              checkbox: !0,
                              enabled: un.values.editor_enabled,
                              desc: "",
                            }),
                              l.items.push({
                                name: Dr.getMessage("Theme"),
                                id: "editor_theme",
                                level: 50,
                                option: !0,
                                select: Object.keys(fs).map((e) => ({
                                  name: fs[e] || e,
                                  value: e,
                                })),
                                value: un.values.editor_theme,
                              }),
                              l.items.push({
                                name: Dr.getMessage("Font_Size"),
                                id: "editor_fontSize",
                                level: 50,
                                option: !0,
                                select: [
                                  { name: "50%", value: 50 },
                                  { name: "70%", value: 70 },
                                  { name: "80%", value: 80 },
                                  { name: "90%", value: 90 },
                                  { name: "100%", value: 100 },
                                  { name: "110%", value: 110 },
                                  { name: "120%", value: 120 },
                                  { name: "150%", value: 150 },
                                ],
                                value: un.values.editor_fontSize,
                              }),
                              l.items.push({
                                name: Dr.getMessage("Key_Mapping"),
                                id: "editor_keyMap",
                                level: 50,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Windows"),
                                    value: "windows",
                                  },
                                  {
                                    name: Dr.getMessage("VSCode"),
                                    value: "vscode",
                                  },
                                  {
                                    name: Dr.getMessage("Sublime"),
                                    value: "sublime",
                                  },
                                  {
                                    name: Dr.getMessage("Emacs"),
                                    value: "emacs",
                                  },
                                  { name: Dr.getMessage("Vim"), value: "vim" },
                                ],
                                value: un.values.editor_keyMap,
                              }),
                              l.items.push({
                                name: Dr.getMessage("Indentation_Width"),
                                id: "editor_indentUnit",
                                level: 50,
                                option: !0,
                                select: [
                                  { name: Dr.getMessage("1"), value: 1 },
                                  { name: Dr.getMessage("2"), value: 2 },
                                  { name: Dr.getMessage("3"), value: 3 },
                                  { name: Dr.getMessage("4"), value: 4 },
                                  { name: Dr.getMessage("5"), value: 5 },
                                  { name: Dr.getMessage("6"), value: 6 },
                                  { name: Dr.getMessage("7"), value: 7 },
                                  { name: Dr.getMessage("8"), value: 8 },
                                  { name: Dr.getMessage("9"), value: 9 },
                                  { name: Dr.getMessage("10"), value: 10 },
                                  {
                                    name: Dr.getMessage("11"),
                                    value: 11,
                                  },
                                ],
                                value: un.values.editor_indentUnit,
                                desc: "",
                              }),
                              l.items.push({
                                name: Dr.getMessage("Tab_Size"),
                                id: "editor_tabSize",
                                level: 50,
                                option: !0,
                                select: [
                                  { name: Dr.getMessage("1"), value: 1 },
                                  { name: Dr.getMessage("2"), value: 2 },
                                  { name: Dr.getMessage("3"), value: 3 },
                                  { name: Dr.getMessage("4"), value: 4 },
                                  { name: Dr.getMessage("5"), value: 5 },
                                  { name: Dr.getMessage("6"), value: 6 },
                                  { name: Dr.getMessage("7"), value: 7 },
                                  { name: Dr.getMessage("8"), value: 8 },
                                  { name: Dr.getMessage("9"), value: 9 },
                                  {
                                    name: Dr.getMessage("10"),
                                    value: 10,
                                  },
                                  { name: Dr.getMessage("11"), value: 11 },
                                ],
                                value: un.values.editor_tabSize,
                                desc: "",
                              }),
                              l.items.push({
                                name: Dr.getMessage("Indent_with"),
                                id: "editor_indentWithTabs",
                                level: 50,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Tabs"),
                                    value: "tabs",
                                  },
                                  {
                                    name: Dr.getMessage("Spaces"),
                                    value: "spaces",
                                  },
                                ],
                                value: un.values.editor_indentWithTabs,
                                desc: "",
                              }),
                              l.items.push({
                                name: Dr.getMessage("TabMode"),
                                id: "editor_tabMode",
                                level: 50,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Classic"),
                                    value: "classic",
                                  },
                                  {
                                    name: Dr.getMessage("Smart"),
                                    value: "smart",
                                  },
                                  {
                                    name: Dr.getMessage("Indent"),
                                    value: "indent",
                                  },
                                ],
                                value: un.values.editor_tabMode,
                                desc: "",
                              }),
                              l.items.push({
                                name: Dr.getMessage(
                                  "Highlight_selection_matches"
                                ),
                                id: "editor_highlightSelectionMatches",
                                level: 50,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Cursor"),
                                    value: "cursor",
                                  },
                                  { name: Dr.getMessage("On"), value: "on" },
                                  { name: Dr.getMessage("Off"), value: "off" },
                                ],
                                value:
                                  un.values.editor_highlightSelectionMatches,
                                desc: "",
                              }),
                              l.items.push({
                                name: Dr.getMessage("Line_break"),
                                id: "editor_lineWrapping",
                                level: 50,
                                option: !0,
                                checkbox: !0,
                                enabled: un.values.editor_lineWrapping,
                                desc: "",
                              }),
                              l.items.push({
                                name: Dr.getMessage("Reindent_on_typing"),
                                id: "editor_electricChars",
                                level: 50,
                                option: !0,
                                checkbox: !0,
                                enabled: un.values.editor_electricChars,
                                desc: "",
                              }),
                              l.items.push({
                                name: Dr.getMessage("Enable_autoSave"),
                                id: "editor_autoSave",
                                level: 20,
                                option: !0,
                                checkbox: !0,
                                enabled: un.values.editor_autoSave,
                                desc: "",
                              }),
                              l.items.push({
                                name: Dr.getMessage("Enable_easySave"),
                                id: "editor_easySave",
                                level: 20,
                                option: !0,
                                checkbox: !0,
                                enabled: un.values.editor_easySave,
                                desc: "",
                              }),
                              l.items.push({
                                name: Dr.getMessage(
                                  "Highlight_trailing_whitespace"
                                ),
                                id: "editor_highlightTrailingWhitespace",
                                level: 50,
                                option: !0,
                                checkbox: !0,
                                enabled:
                                  un.values.editor_highlightTrailingWhitespace,
                                desc: "",
                              }),
                              l.items.push({
                                name: Dr.getMessage(
                                  "Trim_trailing_whitespace_from_modified_lines"
                                ),
                                id: "editor_trimTrailingSpacesFromModifiedLines",
                                level: 50,
                                option: !0,
                                checkbox: !0,
                                enabled:
                                  un.values
                                    .editor_trimTrailingSpacesFromModifiedLines,
                                desc: "",
                              }),
                              l.items.push({
                                name: Dr.getMessage(
                                  "Auto_syntax_check_on_typing"
                                ),
                                id: "editor_autoLint",
                                level: 50,
                                option: !0,
                                checkbox: !0,
                                enabled: un.values.editor_autoLint,
                                desc: Dr.getMessage(
                                  "Enable_this_option_to_automatically_check_the_code_on_typing_"
                                ),
                              }),
                              l.items.push({
                                name: Dr.getMessage(
                                  "Auto_syntax_check_max_length"
                                ),
                                id: "editor_autoLintMaxLen",
                                level: 50,
                                option: !0,
                                text: !0,
                                value: un.values.editor_autoLintMaxLen,
                                desc: Dr.getMessage(
                                  "Check_only_scripts_up_to_this_size_automatically_"
                                ),
                              }),
                              l.items.push({
                                name: Dr.getMessage("Custom_Linter_Config"),
                                id: "editor_linter_config",
                                level: 100,
                                option: !0,
                                input: !0,
                                json: !0,
                                value: un.values.editor_linter_config,
                                validation: {
                                  image: "info",
                                  opacity: 0.9,
                                  msg: Dr.getMessage(
                                    "You_can_add_your_custom_linter_config_here_"
                                  ),
                                  url: "https://eslint.org/docs/user-guide/configuring",
                                },
                              });
                            const c = {
                              id: "script_update",
                              name: Dr.getMessage("Script_Update"),
                              sub_menu_item: !0,
                              level: 0,
                              items: [],
                            };
                            c.items.push({
                              name: Dr.getMessage("Check_disabled_scripts"),
                              id: "scriptUpdateCheckDisabled",
                              level: 0,
                              option: !0,
                              checkbox: !0,
                              enabled: un.values.scriptUpdateCheckDisabled,
                              desc: "",
                            }),
                              c.items.push({
                                name: Dr.getMessage(
                                  "Dont_ask_me_for_simple_script_updates"
                                ),
                                id: "notification_silentScriptUpdate",
                                level: 80,
                                option: !0,
                                checkbox: !0,
                                enabled:
                                  un.values.notification_silentScriptUpdate,
                                desc: "",
                              }),
                              c.items.push({
                                name: Dr.getMessage("Check_interval"),
                                id: "scriptUpdateCheckPeriod",
                                level: 0,
                                option: !0,
                                select: [
                                  { name: Dr.getMessage("Never"), value: 0 },
                                  {
                                    name: Dr.getMessage("Every_6_Hours"),
                                    value: 216e5,
                                  },
                                  {
                                    name: Dr.getMessage("Every_12_Hour"),
                                    value: 432e5,
                                  },
                                  {
                                    name: Dr.getMessage("Every_Day"),
                                    value: 864e5,
                                  },
                                  {
                                    name: Dr.getMessage("Every_Week"),
                                    value: 6048e5,
                                  },
                                ],
                                value: un.values.scriptUpdateCheckPeriod,
                                desc: "",
                              }),
                              c.items.push({
                                name: Dr.getMessage("Hide_notification_after"),
                                id: "scriptUpdateHideNotificationAfter",
                                level: 50,
                                option: !0,
                                select: [
                                  { name: Dr.getMessage("Never"), value: 0 },
                                  {
                                    name: Dr.getMessage("15_Seconds"),
                                    value: 15e3,
                                  },
                                  {
                                    name: Dr.getMessage("30_Seconds"),
                                    value: 3e4,
                                  },
                                  {
                                    name: Dr.getMessage("1_Minute"),
                                    value: 6e4,
                                  },
                                  {
                                    name: Dr.getMessage("5_Minutes"),
                                    value: 3e5,
                                  },
                                  {
                                    name: Dr.getMessage("1_Hour"),
                                    value: 36e5,
                                  },
                                ],
                                value:
                                  un.values.scriptUpdateHideNotificationAfter,
                                desc: "",
                              });
                            const u = {
                              id: "externals",
                              name: Dr.getMessage("Externals"),
                              desc: Dr.getMessage("require_and_resource"),
                              sub_menu_item: !0,
                              level: 0,
                              items: [],
                            };
                            u.items.push({
                              name: Dr.getMessage("Update_interval"),
                              id: "external_update_interval",
                              level: 0,
                              option: !0,
                              select: [
                                { name: Dr.getMessage("Always"), value: 1 },
                                {
                                  name: Dr.getMessage("Every_Day"),
                                  value: 864e5,
                                },
                                {
                                  name: Dr.getMessage("Every_Week"),
                                  value: 6048e5,
                                },
                                {
                                  name: Dr.getMessage("Every_Month"),
                                  value: 2592e6,
                                },
                                { name: Dr.getMessage("Never"), value: 0 },
                              ],
                              value: un.values.external_update_interval,
                              desc: "",
                            });
                            const A = {
                              id: "security",
                              name: Dr.getMessage("Security"),
                              sub_menu_item: !0,
                              need_save: !0,
                              level: 50,
                              items: [],
                            };
                            A.items.push({
                              name: Dr.getMessage("Sandbox_Mode"),
                              id: "sandbox_mode",
                              level: 80,
                              option: !0,
                              select: [
                                {
                                  name: Dr.getMessage("Default"),
                                  value: "default",
                                },
                                { name: Dr.getMessage("All"), value: "raw+" },
                                {
                                  name: Dr.getMessage("Force_Raw"),
                                  value: "raw",
                                },
                                ...(["js", "-js", "js+"].includes(
                                  un.values.sandbox_mode
                                )
                                  ? [
                                      {
                                        name: Dr.getMessage("Force_JavaScript"),
                                        value: "js",
                                      },
                                      {
                                        name: Dr.getMessage(
                                          "Raw_and_JavaScript"
                                        ),
                                        value: "-js",
                                      },
                                      {
                                        name: Dr.getMessage(
                                          "JavaScript_and_DOM"
                                        ),
                                        value: "js+",
                                      },
                                    ]
                                  : []),
                                {
                                  name: Dr.getMessage("Force_DOM"),
                                  value: "dom",
                                },
                              ],
                              value: un.values.sandbox_mode,
                              desc: Dr.getMessage(
                                "Configures_which_sandbox_values_are_valid"
                              ),
                              validation: ["dom", "js+", "raw+"].includes(
                                un.values.sandbox_mode
                              )
                                ? {
                                    image: "critical",
                                    msg: Dr.getMessage(
                                      "DOM_mode_is_unsecure__Scripts_can_install_new_scripts_"
                                    ),
                                  }
                                : void 0,
                            });
                            {
                              const e = [
                                { name: Dr.getMessage("Auto"), value: "auto" },
                                {
                                  name: Dr.getMessage(
                                    "Remove__possibly_unsecure_"
                                  ),
                                  value: "remove",
                                },
                                { name: Dr.getMessage("Yes"), value: "yes" },
                                { name: Dr.getMessage("No"), value: "no" },
                              ];
                              A.items.push({
                                name: Dr.getMessage("Add_TM_to_CSP"),
                                id: "webrequest_fixCSP",
                                level: 80,
                                option: !0,
                                select: e,
                                value: un.values.webrequest_fixCSP,
                                desc: Dr.getMessage(
                                  "Tampermonkey_might_not_be_able_to_provide_access_to_the_unsafe_context_when_this_is_disabled"
                                ),
                              }),
                                A.items.push({
                                  name: Dr.getMessage(
                                    "Allow_headers_to_be_modified_by_scripts"
                                  ),
                                  id: "webrequest_modHeaders",
                                  level: 80,
                                  option: !0,
                                  reload: !0,
                                  select: [
                                    {
                                      name: Dr.getMessage("Yes"),
                                      value: "yes",
                                    },
                                    {
                                      name: Dr.getMessage("Auto"),
                                      value: "auto",
                                    },
                                    { name: Dr.getMessage("No"), value: "no" },
                                  ],
                                  value: un.values.webrequest_modHeaders,
                                  warning: Dr.getMessage(
                                    "Tampermonkey_needs_to_be_restarted_to_make_this_change_apply_Do_you_want_to_continue_"
                                  ),
                                  desc: "",
                                });
                            }
                            A.items.push({
                              name: Dr.getMessage(
                                "Default_tab_types_to_run_scripts_in"
                              ),
                              id: "default_tab_types",
                              level: 80,
                              option: !0,
                              reload: !0,
                              select: [
                                {
                                  name: Dr.getMessage("Incognito_tabs"),
                                  value: "incognito",
                                },
                                {
                                  name: Dr.getMessage("Normal_tabs"),
                                  value: "normal",
                                },
                                {
                                  name: Dr.getMessage("All_tabs"),
                                  value: "incognito+normal",
                                },
                              ],
                              value: un.values.default_tab_types,
                            }),
                              Te.ALLOWS_FILE_SCHEME_ACCESS &&
                                A.items.push({
                                  name: Dr.getMessage(
                                    "Script_local_files_access"
                                  ),
                                  id: "script_file_access",
                                  level: 80,
                                  option: !0,
                                  select: [
                                    {
                                      name: Dr.getMessage("All_local_files"),
                                      value: "all",
                                    },
                                    {
                                      name: Dr.getMessage(
                                        "require_and_resource"
                                      ),
                                      value: "externals",
                                    },
                                    {
                                      name: Dr.getMessage("Disabled"),
                                      value: "off",
                                    },
                                  ],
                                  value: un.values.script_file_access,
                                }),
                              A.items.push({
                                name: Dr.getMessage(
                                  "Allow_communication_with_cooperate_pages"
                                ),
                                id: "external_connect",
                                level: 80,
                                option: !0,
                                reload: !0,
                                select: [
                                  {
                                    name: Dr.getMessage(
                                      "Tampermonkey_and_script_version"
                                    ),
                                    value: "all",
                                  },
                                  {
                                    name: Dr.getMessage("Tampermonkey_version"),
                                    value: "version",
                                  },
                                  {
                                    name: Dr.getMessage("Disabled"),
                                    value: "off",
                                  },
                                ],
                                value: un.values.external_connect,
                                desc: Dr.getMessage(
                                  "This_option_allows_the_Tampermonkey_homepage_and_some_script_hosting_pages_to_determine_the_Tampermonkey_version_and_whether_a_script_is_installed_"
                                ),
                              }),
                              A.items.push({
                                name: Dr.getMessage("Subresource_Integrity"),
                                id: "require_sri_mode",
                                level: 80,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Disabled"),
                                    value: "ignore",
                                  },
                                  {
                                    name: Dr.getMessage(
                                      "Validate_if_supported"
                                    ),
                                    value: "supported",
                                  },
                                  {
                                    name: Dr.getMessage("Validate_if_given"),
                                    value: "given",
                                  },
                                  {
                                    name: Dr.getMessage("Enforce"),
                                    value: "enforce",
                                  },
                                ],
                                value: un.values.require_sri_mode,
                                desc: Dr.getMessage(
                                  "Script_authors_can_secure_external_resources_by_adding_a_SRI_hash_to_the_URL_"
                                ),
                              });
                            let d = [];
                            (un.values.configMode >= 80 ||
                              ["off", "casual"].includes(
                                un.values.connect_mode
                              )) &&
                              (d = d.concat([
                                {
                                  name: Dr.getMessage("Disabled"),
                                  value: "off",
                                },
                                {
                                  name: Dr.getMessage("Casual"),
                                  value: "casual",
                                },
                              ])),
                              (d = d.concat([
                                {
                                  name: Dr.getMessage("Ask_if_unknown"),
                                  value: "ask",
                                },
                                {
                                  name: Dr.getMessage("Strict"),
                                  value: "strict",
                                },
                                {
                                  name: Dr.getMessage("Always_ask"),
                                  value: "paranoid",
                                },
                              ])),
                              A.items.push({
                                name: Dr.getMessage("Script_Include_Mode"),
                                id: "script_include_mode",
                                level: 50,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Disabled"),
                                    value: "off",
                                  },
                                  {
                                    name: Dr.getMessage("Treat_like__match"),
                                    value: "match",
                                  },
                                  {
                                    name: Dr.getMessage("Unsafe"),
                                    value: "unsafe",
                                  },
                                  {
                                    name: Dr.getMessage("Default"),
                                    value: "default",
                                  },
                                ],
                                value: un.values.script_include_mode,
                                desc: Dr.getMessage(
                                  "Using__include_is_potentially_unsafe_and_may_be_obsolete_soon___0off0_disables__include_completely__0match0__is_safe__but_may_not_compatible_the_script_developers_intention__0unsafe0__mostly_keeps_the_legacy_behavior_0default0__means__0used_default0",
                                  Dr.getMessage("Disabled"),
                                  Dr.getMessage("Treat_like__match"),
                                  Dr.getMessage("Unsafe"),
                                  Dr.getMessage("Default"),
                                  Dr.getMessage("Unsafe")
                                ),
                              }),
                              A.items.push({
                                name: Dr.getMessage("connect_mode"),
                                id: "connect_mode",
                                level: 50,
                                option: !0,
                                select: d,
                                value: un.values.connect_mode,
                                desc: "",
                              }),
                              Te.INCOGNITO_MODE &&
                                !ze.inIncognitoContext &&
                                A.items.push({
                                  name: Dr.getMessage(
                                    "Store_data_in_incognito_mode"
                                  ),
                                  id: "incognito_mode",
                                  level: 50,
                                  option: !0,
                                  select: [
                                    {
                                      name: Dr.getMessage("Temporary"),
                                      value: "temporary",
                                    },
                                    {
                                      name: Dr.getMessage("Permanent"),
                                      value: "permanent",
                                    },
                                  ],
                                  value: un.values.incognito_mode,
                                  validation:
                                    "temporary" == un.values.incognito_mode
                                      ? void 0
                                      : {
                                          image: "critical",
                                          msg: "Permanent mode is still a BETA feature!",
                                        },
                                }),
                              A.items.push({
                                name: Dr.getMessage("Page_Filter_Mode"),
                                id: "page_filter_mode",
                                level: 50,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Disabled"),
                                    value: "off",
                                  },
                                  {
                                    name: Dr.getMessage("Blacklist"),
                                    value: "black",
                                  },
                                  {
                                    name: Dr.getMessage("Whitelist"),
                                    value: "white",
                                  },
                                  {
                                    name: Dr.getMessage("Both"),
                                    value: "black+white",
                                  },
                                ],
                                value: un.values.page_filter_mode,
                                desc: "",
                              }),
                              A.items.push({
                                name: Dr.getMessage("Whitelisted_Pages"),
                                id: "page_whitelist",
                                level: 50,
                                option: !0,
                                input: !0,
                                array: !0,
                                value: un.values.page_whitelist,
                                desc: "",
                              }),
                              A.items.push({
                                name: Dr.getMessage("Blacklisted_Pages"),
                                id: "forbiddenPages",
                                level: 50,
                                option: !0,
                                input: !0,
                                array: !0,
                                value: un.values.forbiddenPages,
                                desc: "",
                              });
                            const h = {
                              id: "blackcheck",
                              name: Dr.getMessage("BlackCheck"),
                              sub_menu_item: !0,
                              need_save: !0,
                              level: 50,
                              items: [],
                            };
                            let p;
                            h.items.push({
                              name: Dr.getMessage("Script_Blacklist_Source"),
                              id: "script_blacklist_type",
                              level: 50,
                              option: !0,
                              select: [
                                {
                                  name: Dr.getMessage("Disabled"),
                                  value: "off",
                                },
                                {
                                  name: Dr.getMessage("Server_And_Manual"),
                                  value: "server",
                                },
                                {
                                  name: Dr.getMessage("Only_Manual"),
                                  value: "only_manual",
                                },
                              ],
                              value: un.values.script_blacklist_type,
                            }),
                              h.items.push({
                                name: Dr.getMessage("Blacklist_Severity"),
                                id: "script_blacklist_severity",
                                level: 50,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("severity_1"),
                                    value: 1,
                                  },
                                  {
                                    name: Dr.getMessage("severity_2"),
                                    value: 2,
                                  },
                                  {
                                    name: Dr.getMessage("severity_3"),
                                    value: 3,
                                  },
                                  {
                                    name: Dr.getMessage("severity_4"),
                                    value: 4,
                                  },
                                  {
                                    name: Dr.getMessage("severity_5"),
                                    value: 5,
                                  },
                                  {
                                    name: Dr.getMessage("severity_6"),
                                    value: 6,
                                  },
                                  {
                                    name: Dr.getMessage("severity_7"),
                                    value: 7,
                                  },
                                  {
                                    name: Dr.getMessage("severity_8"),
                                    value: 8,
                                  },
                                  {
                                    name: Dr.getMessage("severity_9"),
                                    value: 9,
                                  },
                                  {
                                    name: Dr.getMessage("severity_10"),
                                    value: Wi.SEVERITY_MAX,
                                  },
                                ],
                                value: un.values.script_blacklist_severity,
                              }),
                              h.items.push({
                                name: Dr.getMessage("Manual_Script_Blacklist"),
                                id: "require_blacklist",
                                level: 50,
                                option: !0,
                                input: !0,
                                array: !0,
                                value: un.values.require_blacklist,
                                desc: "",
                              });
                            {
                              const e = [
                                "exe",
                                "sh",
                                "crx",
                                "com",
                                "bat",
                                "scr",
                              ]
                                .map((e) => "name." + e)
                                .some((e) => Ko.is_whitelisted(e));
                              (p = {
                                id: "downloads",
                                name: Dr.getMessage("Downloads") + " BETA",
                                sub_menu_item: !0,
                                need_save: !0,
                                level: 50,
                                items: [],
                              }),
                                p.items.push({
                                  name: Dr.getMessage("Download_Mode"),
                                  id: "downloads_mode",
                                  level: 50,
                                  option: !0,
                                  select: [
                                    {
                                      name: Dr.getMessage("Default"),
                                      value: Ko.staticVars.DEFAULT,
                                    },
                                    {
                                      name: Dr.getMessage("Disabled"),
                                      value: Ko.staticVars.OFF,
                                    },
                                    {
                                      name: Dr.getMessage("Native"),
                                      value: Ko.staticVars.NATIVE,
                                    },
                                    {
                                      name: Dr.getMessage("Browser_API"),
                                      value: Ko.staticVars.CHROME,
                                    },
                                  ].filter((e) => e.value),
                                  value: un.values.downloads_mode,
                                  desc: Dr.getMessage(
                                    "The_Browser_API_mode_requires_a_special_permission_"
                                  ),
                                }),
                                p.items.push({
                                  name: Dr.getMessage(
                                    "Whitelisted_File_Extensions"
                                  ),
                                  id: "downloads_extension_whitelist",
                                  level: 50,
                                  option: !0,
                                  input: !0,
                                  array: !0,
                                  value:
                                    un.values.downloads_extension_whitelist,
                                  desc: Dr.getMessage(
                                    "Only_files_with_these_extensions_can_be_saved_to_the_harddisk_Be_careful_to_not_allow_file_extensions_that_represent_executables_at_your_operating_system_"
                                  ),
                                  validation: e
                                    ? {
                                        image: "critical",
                                        msg: Dr.getMessage(
                                          "Your_whitelist_seems_to_include_executable_files_This_means_your_userscripts_may_download_malware_or_spyware_to_your_harddisk_"
                                        ),
                                      }
                                    : void 0,
                                });
                            }
                            const f = {
                              id: "experimental",
                              name: Dr.getMessage("Experimental"),
                              sub_menu_item: !0,
                              level: 80,
                              items: [],
                            };
                            Te.FAST_EXEC_SUPPORT &&
                              f.items.push({
                                name: Dr.getMessage("Inject_Mode"),
                                id: "runtime_inject_mode",
                                level: 80,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Default"),
                                    value: "default",
                                  },
                                  {
                                    name: Dr.getMessage("Instant"),
                                    value: "instant",
                                  },
                                  {
                                    name: Dr.getMessage("Normal"),
                                    value: "normal",
                                  },
                                ],
                                value: un.values.runtime_inject_mode,
                              }),
                              f.items.push({
                                name: Dr.getMessage("strict_mode"),
                                id: "runtime_strict_mode",
                                level: 80,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Default"),
                                    value: "byscript",
                                  },
                                  {
                                    name: Dr.getMessage("Always"),
                                    value: "on",
                                  },
                                  {
                                    name: Dr.getMessage("Disabled"),
                                    value: "off",
                                  },
                                ],
                                value: un.values.runtime_strict_mode,
                              }),
                              f.items.push({
                                name: Dr.getMessage("top_level_await"),
                                id: "runtime_top_level_await",
                                level: 80,
                                option: !0,
                                select: [
                                  {
                                    name: Dr.getMessage("Default"),
                                    value: "default",
                                  },
                                  {
                                    name: Dr.getMessage("Enabled"),
                                    value: "on",
                                  },
                                  {
                                    name: Dr.getMessage("Disabled"),
                                    value: "off",
                                  },
                                ],
                                value: un.values.runtime_top_level_await,
                              }),
                              rt.filterResponseData &&
                                f.items.push({
                                  name: Dr.getMessage(
                                    "Add_Tampermonkey_to_the_site_s_content_csp"
                                  ),
                                  id: "webrequest_fixContentCSP",
                                  level: 80,
                                  option: !0,
                                  select: [
                                    {
                                      name: Dr.getMessage("Yes"),
                                      value: "yes",
                                    },
                                    { name: Dr.getMessage("No"), value: "no" },
                                  ],
                                  value: un.values.webrequest_fixContentCSP,
                                  warning:
                                    "Warning: enabling this option is may break pages!",
                                });
                            const m = {
                              id: "userscripts",
                              name: Dr.getMessage("Userscripts"),
                              sub_menu_item: !0,
                              need_save: !0,
                              level: 80,
                              items: [],
                            };
                            m.items.push({
                              name: Dr.getMessage("Script_URL_detection"),
                              id: "scriptUrlDetection",
                              level: 80,
                              option: !0,
                              select: [
                                { name: Dr.getMessage("Auto"), value: "auto" },
                                {
                                  name: Dr.getMessage("Disabled"),
                                  value: "manual",
                                },
                              ],
                              value: un.values.scriptUrlDetection,
                            }),
                              m.items.push({
                                name: Dr.getMessage("New_script_template_"),
                                id: "script_templates",
                                level: 80,
                                option: !0,
                                input: !0,
                                array: !0,
                                named: !0,
                                value: un.values.script_templates,
                              });
                            const g = {
                              id: "reset",
                              name: Dr.getMessage("Reset_Section"),
                              sub_menu_item: !0,
                              level: 50,
                              items: [],
                            };
                            return (
                              g.items.push({
                                name: Dr.getMessage("Restart_Tampermonkey"),
                                id: "reset_simple",
                                level: 50,
                                button: !0,
                                reload: !0,
                                warning: Dr.getMessage(
                                  "This_will_restart_Tampermonkey_Ok_"
                                ),
                              }),
                              g.items.push({
                                name: Dr.getMessage("Factory_Reset"),
                                id: "reset_factory",
                                level: 80,
                                button: !0,
                                reload: !0,
                                warning: Dr.getMessage(
                                  "This_will_remove_all_scripts_and_reset_all_settings_Ok_"
                                ),
                              }),
                              e &&
                                g.items.push({
                                  name: "Install Tests",
                                  id: "install_tests",
                                  level: 80,
                                  button: !0,
                                  reload: !1,
                                  ignore: !0,
                                  warning:
                                    "This will install a lot of test scripts!",
                                }),
                              [
                                t,
                                s,
                                i,
                                o,
                                a,
                                c,
                                u,
                                n,
                                l,
                                A,
                                h,
                                p,
                                m,
                                f,
                                g,
                              ].filter((e) => e)
                            );
                          })()
                        )
                      : ((r.referrer = "options.settings"), R.Pledge([]))
                    )
                      .done((e) => {
                        (r.items = e), n.resolve([r]);
                      })
                      .fail(n.reject),
                    n.promise()
                  );
                },
              },
              l = { actions: o, options: a };
            return w.debug("tree: loading", n, r), i(n, !0)();
          },
          level: (e) => e.replace(/\.$/, "").split(".").length,
        },
        pl = hl,
        fl = {};
      let ml;
      const gl = ({ tabId: e, frameId: t, url: n }) => {
          const r = fl[e];
          r &&
            r.forEach((r) => {
              r({ tabId: e, frameId: t, url: n });
            });
        },
        vl = (e, t) => {
          (fl[e] = fl[e] || []),
            fl[e].push(t),
            !ml &&
              Object.keys(fl).length &&
              (st && it && it.addDynamicListener(gl), (ml = !0));
        },
        _l = (e, t) => {
          let n;
          const r = fl[e];
          r && (n = r.indexOf(t)) > -1 && r.splice(n, 1),
            0 === r.length && delete fl[e];
        };
      var wl = e(462),
        bl = e.n(wl);
      const yl = (() => {
          let e,
            t,
            n = !1;
          const r = () => {
            const e = R();
            return (t = e), e;
          };
          return {
            write: () => {
              const t = R();
              return (n = !1), (e = new (bl())()), t.resolve(e), t.promise();
            },
            open: (s) => {
              const i = r();
              return (
                (n = !0),
                bl()
                  .loadAsync(s)
                  .then(
                    (t) => {
                      (e = t), i.resolve(e);
                    },
                    (e) => {
                      t && t.reject(e), i.reject(e);
                    }
                  ),
                i.promise()
              );
            },
            entries: () => {
              const t = r(),
                n = e.files,
                s = Object.keys(n)
                  .map((e) => {
                    const t = n[e];
                    if (t && !t.dir) return { filename: t.name };
                  })
                  .filter((e) => e);
              return t.resolve(s), t.promise();
            },
            get: (t) => {
              const n = r(),
                s = e.file(t.filename);
              return (
                s
                  ? s.async("arraybuffer").then((e) => {
                      n.resolve(e);
                    })
                  : n.resolve(),
                n.promise()
              );
            },
            put: (t, n, s) => {
              const i = r();
              try {
                e.file(t, n, { date: s ? new Date(s) : void 0 }), i.resolve();
              } catch (e) {
                i.reject(e);
              }
              return i.promise();
            },
            end: () => {
              const t = r();
              return (
                n
                  ? t.reject()
                  : e
                      .generateAsync({
                        type: "blob",
                        compression: "DEFLATE",
                        comment: "Created by Tampermonkey",
                      })
                      .then(
                        (e) => t.resolve(e),
                        (e) => t.reject(e)
                      ),
                t.promise()
              );
            },
          };
        })(),
        kl = {
          zip: {
            create: function (e, t) {
              const n = R();
              return (
                R.Pledge()
                  .then(() => yl.write())
                  .then(() => {
                    const t = R(),
                      r = {},
                      s = (e, t) => {
                        let n = [e, t].join(".");
                        if (r[n]) {
                          let i;
                          do {
                            (i = e + " (" + r[n] + ")"),
                              (n = [i, t].join(".")),
                              r[n]++;
                          } while (r[n]);
                          return s(i, t);
                        }
                        return (r[n] = 1), n;
                      },
                      i = e.length,
                      o = () => {
                        if (!e.length) return t.resolve();
                        const r = e.shift();
                        if (!r) return t.resolve();
                        const a = r.meta.name.replace(/[\\/$*?|]/g, "-"),
                          l = s(a, "user.js"),
                          c = s(a, "options.json"),
                          u = s(a, "storage.json"),
                          A = {
                            options: r.options,
                            settings: r.settings,
                            meta: r.meta,
                          },
                          d = JSON.stringify(A),
                          h = r.storage ? JSON.stringify(r.storage) : null;
                        n.notify(
                          "Zip: " + Math.floor(((i - e.length) / i) * 100) + "%"
                        ),
                          yl
                            .put(l, r.source, r.meta.modified)
                            .then(() => yl.put(c, d))
                            .then(() => (h ? yl.put(u, h) : R.Pledge()))
                            .then(() => {
                              if (!r.resources.length && !r.requires.length)
                                return R.Pledge();
                              const e = [];
                              return (
                                ["resources", "requires"].forEach((t) => {
                                  const n = r[t];
                                  n &&
                                    n.length &&
                                    n.forEach((n) => {
                                      if (void 0 === n.source) return;
                                      const r = n.meta.name.replace(
                                          /[\\/$*?|]/g,
                                          "-"
                                        ),
                                        s = ve(t + n.meta.url),
                                        i = [l, s, r].join("-"),
                                        o = JSON.stringify(n.meta),
                                        a = me(n.source, {
                                          encoding:
                                            "resources" == t ? void 0 : "UTF-8",
                                        }),
                                        c = yl
                                          .put(i, a)
                                          .then(() =>
                                            yl.put(i + "." + t + ".json", o)
                                          );
                                      e.push(c);
                                    });
                                }),
                                R.when(e)
                              );
                            })
                            .fail(() => {
                              w.log("porter: add to zip failed");
                            })
                            .always(async () => {
                              await S(1e3), o();
                            });
                      };
                    return o(), t.promise();
                  })
                  .then(() =>
                    t
                      ? yl.put("Tampermonkey.global.json", JSON.stringify(t))
                      : R.Pledge()
                  )
                  .then(() => yl.end())
                  .done((e) => {
                    n.resolve(e);
                  })
                  .fail(() => {
                    n.reject();
                  }),
                n.promise()
              );
            },
            read: function (e) {
              const t = R();
              let n;
              return (
                R.Pledge()
                  .then(() => yl.open(e))
                  .then(() => yl.entries())
                  .then((e) => {
                    const r = R(),
                      s = {},
                      i = {},
                      o = e.length,
                      a = () => {
                        const l = e.shift();
                        if (l)
                          yl.get(l)
                            .done((e) => {
                              let t = l.filename.match(
                                /((.*)\.(storage\.json)|(.*)\.(options\.json)|(.*)\.(global\.json)|(.*)\.(user\.js)|(.*)\.user\.js-[0-9a-f]+-.*\.(resources\.json)|(.*)\.user\.js-[0-9a-f]+-.*\.(requires\.json))$/
                              );
                              if (
                                (t && (t = t.slice(1).filter((e) => e)),
                                !e || !t || t.length < 3)
                              )
                                i[l.filename] = e;
                              else
                                try {
                                  const r = t[1],
                                    i = t[2],
                                    o = fe(e, "UTF-8");
                                  if ("global.json" == i) n = JSON.parse(o);
                                  else {
                                    const e = s[r] || {
                                      resources: {},
                                      requires: {},
                                    };
                                    (s[r] = e),
                                      "user.js" == i
                                        ? (e.source = o)
                                        : "options.json" == i
                                        ? (e.options = JSON.parse(o))
                                        : "resources.json" == i
                                        ? (e.resources[l.filename] = {
                                            name: l.filename,
                                            data: JSON.parse(o),
                                          })
                                        : "requires.json" == i
                                        ? (e.requires[l.filename] = {
                                            name: l.filename,
                                            data: JSON.parse(o),
                                          })
                                        : "storage.json" == i &&
                                          (e.storage = JSON.parse(o));
                                  }
                                } catch (e) {
                                  w.warn("porter: read from zip failed", e);
                                }
                            })
                            .always(async () => {
                              t.notify(
                                "Zip: " +
                                  Math.floor(((o - e.length) / o) * 100) +
                                  "%"
                              ),
                                await S(1e3),
                                a();
                            });
                        else {
                          const e = [];
                          for (const [t, n] of Object.entries(s)) {
                            const { options: r, source: s, storage: o } = n;
                            if (!s) {
                              w.warn(`porter: invalid script ${t}`);
                              continue;
                            }
                            const a = { requires: [], resources: [] };
                            ["resources", "requires"].forEach((e) => {
                              for (const t of Object.values(n[e])) {
                                const n = t.name.replace("." + e + ".json", ""),
                                  r = i[n];
                                r &&
                                  a[e].push({
                                    meta: t.data,
                                    source:
                                      fe(r, {
                                        encoding:
                                          "resources" == e ? void 0 : "UTF-8",
                                      }) || void 0,
                                  });
                              }
                            });
                            const l = { ...a, ...r, source: s, storage: o };
                            e.push(l);
                          }
                          r.resolve({ scripts: e, global_settings: n });
                        }
                      };
                    return a(), r.promise();
                  })
                  .done((e) => {
                    t.resolve(e);
                  })
                  .fail(() => {
                    t.reject();
                  }),
                t.promise()
              );
            },
          },
          json: {
            create: function (e, t) {
              const n = R(),
                r = {
                  created_by: "Tampermonkey",
                  version: "1",
                  scripts: [],
                  settings: t,
                };
              return (
                e.forEach((e) => {
                  const t = {
                    name: e.meta.name,
                    options: e.options,
                    storage: e.storage,
                    enabled: e.settings.enabled,
                    position: e.settings.position,
                    file_url: e.meta.file_url,
                    uuid: e.meta.uuid,
                    source: he(Ae(e.source)),
                  };
                  ["resources", "requires"].forEach((n) => {
                    const r = e[n];
                    if (!r || !r.length) return;
                    const s = (t[n] = []);
                    r.forEach((e) => {
                      if (void 0 === e.source) return;
                      const t = e.meta,
                        n = he(Ae(e.source));
                      s.push({ meta: t, source: n });
                    });
                  }),
                    r.scripts.push(t);
                }),
                n.resolve(JSON.stringify(r)),
                n.promise()
              );
            },
            read: function (e) {
              const t = R(),
                n = (e, r) => {
                  if (e.trim()) {
                    let s = null;
                    try {
                      s = JSON.parse(e);
                      const n = (e) => {
                          if (e && e.length)
                            return e.map((e) => ({
                              meta: e.meta,
                              source: e.source ? de(pe(e.source)) : e.source,
                            }));
                        },
                        r = s.scripts.map((e) => ({
                          meta: {
                            uuid: e.uuid,
                            name: e.name,
                            file_url: e.file_url,
                          },
                          settings: {
                            enabled: e.enabled,
                            position: e.position,
                          },
                          options: e.options,
                          storage: e.storage,
                          source: de(pe(e.source)),
                          resources: n(e.resources) || [],
                          requires: n(e.requires) || [],
                        }));
                      return t.resolve({
                        scripts: r,
                        global_settings: s.settings,
                      });
                    } catch (t) {
                      if (!r) {
                        const t = "<body>",
                          r = "</body>";
                        if (-1 != e.indexOf(t)) {
                          const s = e.indexOf(t),
                            i = e.lastIndexOf(r);
                          if (-1 != s && -1 != i)
                            return (
                              (e = e.substr(s + t.length, i - (s + t.length))),
                              n(e, !0)
                            );
                        }
                      }
                    }
                  }
                  t.reject();
                };
              return n(e), t.promise();
            },
          },
        },
        Rl = kl,
        xl = (e, t, n) => {
          const r = `${Ze.PREFIX.MISC_CONFIG}${e}.${t}`,
            s = {
              get: (e) =>
                R(({ resolve: s }) => {
                  let i = {};
                  const o = void 0 === e || Array.isArray(e) ? e : [e];
                  let a = Ot.getValue(r, null);
                  if (null === a && n && ae) {
                    const e = n[t];
                    if (e)
                      try {
                        a = JSON.parse(ae.getItem(e) || "");
                      } catch (e) {}
                  }
                  if (null !== a)
                    if (o) for (const e of o) i[e] = a[e];
                    else i = a;
                  s(i);
                }).promise(),
              set: (e) => {
                const s = Ot.getValue(r, {});
                Object.entries(e).forEach(([e, t]) => {
                  null === t ? delete s[e] : void 0 !== t && (s[e] = t);
                });
                const i = n ? n[t] : null;
                if (i && ae)
                  try {
                    ae.setItem(i, JSON.stringify(s));
                  } catch (e) {}
                return Ot.setValue(r, s);
              },
              delete: (e) => {
                const t = (Array.isArray(e) ? e : [e]).reduce(
                  (e, t) => ((e[t] = null), e),
                  {}
                );
                return s.set(t);
              },
              clear: () => {
                const e = n ? n[t] : null;
                return e && ae && ae.removeItem(e), Ot.deleteValue(r);
              },
            };
          return s;
        },
        El = Xt(),
        Sl = (() => {
          const e = {
              allow: { script: "window.close" },
              exec: (e, t, n) => {
                const r = t && t.tab ? t.tab.id : null;
                var s, i;
                r
                  ? ((s = { windowType: "normal" }),
                    (i = (e) => {
                      if (e.length <= 1) {
                        const e = "refused to close last tab!";
                        w.warn("mh:", e), n({ error: e });
                      } else
                        Ke(r, () => {
                          const e = qe.lastError;
                          n({ error: e ? e.message : void 0 });
                        });
                    }),
                    Se.tabs.query(s, i))
                  : n({ error: "internal error" });
              },
            },
            t = {
              allow: { extpage: !0 },
              exec: (e, t, n) => {
                const { key: r } = e;
                r && ($s.removeAll(r), ae && r === qi && ae.removeItem(qi)),
                  n({});
              },
            },
            n = {
              allow: { extpage: !0 },
              exec: (e, t, n) => {
                ("options" == t.extpage || "options" == e.origin
                  ? R.Pledge(t.tab)
                  : md()
                ).then((t) => {
                  let r, s, i;
                  if (
                    e.uuid &&
                    (r = Cd.getByUid(e.uuid)) &&
                    r.script &&
                    r.cond
                  ) {
                    let n;
                    (s = vu.determineOrigin(r.script)),
                      "hoster" == e.to && s
                        ? (i = s)
                        : (n =
                            r.script.supportURL ||
                            (null == s ? void 0 : s.issue_url) ||
                            (null == s ? void 0 : s.url)) &&
                          (i = { issue_url: n }),
                      i &&
                        (mr(r.script.name, "m"),
                        Ye(
                          {
                            url: i.abuse_url || i.issue_url,
                            active: !0,
                            parent: t,
                          },
                          () => {}
                        ));
                  }
                  n({});
                });
              },
            },
            r = {
              allow: { extpage: !0 },
              exec: (e, t, n) => {
                if ("dialog" == e.action) dl.dialog.shown(e.extra);
                else if ("clicked" == e.action) {
                  let t, n;
                  e.extra && ((t = e.extra.amount), (n = e.extra.currency)),
                    dl.clicked(e.type, t || "?", n || "?");
                } else if (dl.button[e.action]) {
                  const t = dl.button[e.action];
                  t && t(e.type, e.extra);
                } else w.warn("mh: Warning: unknown request ", e);
                n({});
              },
            },
            s = {
              allow: { extpage: !0 },
              exec: async (e, t, n) => {
                const r = "options" == t.extpage || "options" == e.origin,
                  s = () => n({});
                switch (e.name) {
                  case "reset_simple":
                    ia.reset(s);
                    break;
                  case "reset_factory":
                    ia.factoryReset(s);
                    break;
                  case "reset_sync":
                    Ea.reset().always(s);
                    break;
                  case "run_sync":
                    di.once("syncFinished", () => s()), Ea.sync(1, !0);
                    break;
                  case "install_tests": {
                    const e = "chrome",
                      t = K.Tests.framework.prepare(vu, Cd, e, Ge(), "", s);
                    t && w.error(t);
                    break;
                  }
                  case "enabled": {
                    const { name: t } = e;
                    un.setValue(t, !un.values[t]).always(s);
                    break;
                  }
                  case "installFromUrl": {
                    const {
                      data: { url: t, source: i, transferable: o },
                    } = e;
                    let a;
                    if (o) {
                      const e = Rs.fromTransferableData(o);
                      if (!e) throw new Error("Invalid Transferable");
                      const n = await e.toBlob();
                      if (!n) throw new Error("Invalid Transferable");
                      const r = await be(n, "utf-8");
                      a = vu.installFromSource(r, { url: t });
                    } else
                      a = i
                        ? vu.installFromSource(i, { url: t })
                        : vu.installFromUrl(t);
                    a.done(() => {
                      r
                        ? pl.create("options.scripts").done((e) => {
                            const t = {
                              success: !0,
                              items: e,
                              options: un.snapshot,
                            };
                            n(t);
                          })
                        : s();
                    }).fail(() => s());
                    break;
                  }
                  case "externals_delete": {
                    const { safe_url: t, scriptuid: r } = e;
                    no.cleanElement(r, t),
                      pl
                        .create("options.scripts")
                        .done((e) => {
                          n({ items: e, options: un.snapshot });
                        })
                        .fail((e) => {
                          n({
                            error: e || "unknown error",
                            options: un.snapshot,
                          });
                        });
                    break;
                  }
                  case "focus_tab": {
                    const { tabid: t } = e;
                    Sl.focusTab.exec(
                      {},
                      {
                        tab: { id: t, url: "", index: -1, windowId: -1 },
                        url: "",
                        frameId: 0,
                        id: ze.manifest.id,
                      },
                      s
                    );
                    break;
                  }
                  case "run_script_updates": {
                    const { scriptuid: t } = e;
                    if (t) {
                      let e;
                      sl.check(!0, !1, t)
                        .done((t) => {
                          e = t;
                        })
                        .always(() => {
                          n({ scriptuid: t, updatable: e });
                        });
                    } else sl.check(!0, !0), s();
                    break;
                  }
                  case "blacklist_page": {
                    const { data: t } = e,
                      n = t.domain;
                    if (!n) throw new Error("Blacklisted domain is missing!");
                    const r = "/" + _n(`*://*.${n}/*`, !0) + "/";
                    un.setValue(
                      "forbiddenPages",
                      un.values.forbiddenPages.concat([r])
                    ).always(s);
                    break;
                  }
                  case "script_search": {
                    const { data: t } = e,
                      { url: n, result_url: r } = t;
                    if (n) {
                      const e = { url: Eo(n), active: !0 };
                      Ye(e, s);
                    } else {
                      if (!r) throw new Error("Search URL is missing!");
                      Ye({ url: r, active: !0 }, s);
                    }
                    break;
                  }
                  case "contrib": {
                    const e = {
                      url: ze.getURL("options.html") + "#contribute",
                      active: !0,
                    };
                    Ye(e, s);
                    break;
                  }
                  case "enable_stats":
                    un.setValue("statistics_enabled", !0).always(s);
                    break;
                  case "disable_stats":
                    un.setValue("statistics_enabled", !1).always(s);
                    break;
                  default:
                    w.warn("mh: Warning: unknown button " + name), s();
                }
              },
            },
            i = {
              allow: { extpage: !0 },
              exec: async (e, t, n) => {
                const { action: r, realm: s, key: i, config: o } = e,
                  a = xl(s, i, "cloud" == s ? go : void 0);
                if ("get" == r) n({ config: await a.get() });
                else {
                  if ("set" != r) throw new Error("Invalid action");
                  if (o) {
                    if ((await a.set(o), "cloud" == s)) {
                      const e = a,
                        t = await e.get();
                      (l = i),
                        fo.includes(l)
                          ? mo.emit("credentials", { type: i, credentials: t })
                          : w.warn("mh+miscConfig[cloud]: invalid key");
                    }
                  } else await a.clear();
                }
                var l;
                n();
              },
            },
            o = {
              allow: { extpage: !0 },
              exec: (e, t, n) => {
                for (const t of e.uuids) vu.doRemove(t, !0);
                vu.reorderScripts(),
                  R.onebyone([
                    () => pl.create("options.scripts"),
                    () => pl.create("options.trash"),
                  ])
                    .then((e) =>
                      e.filter((e) => e).reduce((e, t) => e.concat(t), [])
                    )
                    .done((e) => {
                      const t = { items: e, options: un.snapshot };
                      n(t);
                    })
                    .fail((e) => {
                      n({ error: e || "unknown error", options: un.snapshot });
                    });
              },
            },
            a = {
              allow: { extpage: !0 },
              exec: (e, t, n) => {
                debugger;
                const r = void 0 === e.reload || !!e.reload,
                  s = "options" == t.extpage || "options" == e.origin,
                  i = (t) => {
                    s
                      ? r
                        ? R.onebyone([
                            () => pl.create("options.scripts"),
                            () => pl.create("options.trash"),
                          ])
                            .then((e) =>
                              e
                                .filter((e) => e)
                                .reduce((e, t) => e.concat(t), [])
                            )
                            .done((e) => {
                              const r = {
                                ...t,
                                items: e,
                                options: un.snapshot,
                              };
                              n(r);
                            })
                            .fail((e) => {
                              n({
                                error: e || "unknown error",
                                options: un.snapshot,
                              });
                            })
                        : n({})
                      : $e(null, (t) => {
                          pl
                            .create("actions")
                            .done((e) => {
                              n({
                                items: e,
                                i18n: un.values.i18n,
                                options: { enabled: un.values.enabled },
                              });
                            })
                            .fail(() => {
                              n({
                                items: [],
                                i18n: un.values.i18n,
                                options: { enabled: un.values.enabled },
                              });
                            }),
                            !t ||
                              t.id < 0 ||
                              (e.uuid &&
                                un.values.autoReload &&
                                tt(t.id, { method: "reload" }, { frameId: 0 }));
                        });
                  };
                if (e.clean) {
                  const t = e.uuid;
                  if (!t)
                    return void n({
                      error: "uuid missing",
                      options: un.snapshot,
                    });
                  w.debug("mh: clean userscript " + t);
                  const r = Cd.getByUid(t),
                    s = (e) => {
                      pl.create("options.scripts")
                        .done((r) => {
                          const s = {
                            cleaned: e.installed,
                            items: r,
                            options: un.snapshot,
                          };
                          n(s),
                            e.installed &&
                              Cd.notifyStorageListeners(
                                { uuid: t },
                                void 0,
                                (e) => {
                                  e({ storage: Cd.getStorageByUid(t).data });
                                }
                              );
                        })
                        .fail((e) => {
                          n({
                            error: e || "unknown error",
                            options: un.snapshot,
                          });
                        });
                    };
                  r.script && r.cond
                    ? vu
                        .doSave({
                          name: e.name,
                          uuid: t,
                          src: r.script.textContent,
                          clean: !0,
                          ask: !1,
                          internal: !0,
                          save: !0,
                        })
                        .always((e) => {
                          s(e || { installed: !1 });
                        })
                    : (w.error(
                        Dr.getMessage("fatal_error") + " (" + t + ")!!!"
                      ),
                      s({ installed: !1 }));
                } else if (e.code) {
                  let t = e.uuid;
                  if (!t)
                    return void n({
                      error: "uuid missing",
                      options: un.snapshot,
                    });
                  let s = (e) => n(e);
                  r &&
                    (s = (e) => {
                      vu.reorderScripts(), i(e);
                    }),
                    e.new_script && (t = Xt()),
                    vu
                      .doSave({
                        name: e.name,
                        uuid: t,
                        force_url: e.force_url,
                        src: e.code,
                        ask: !un.values.editor_easySave,
                        lastModTime: e.lastModTime,
                        save: !0,
                      })
                      .always((e) => {
                        s(e || { installed: !1 });
                      });
                } else if (e.auto_save) i({});
                else {
                  const t = e.uuids || (e.uuid ? [e.uuid] : []);
                  for (const n of t)
                    e.restore ? Cd.restoreByUid(n) : vu.doRemove(n, !1);
                  vu.reorderScripts(), i({});
                }
              },
            },
            l = {
              allow: { extpage: !0, script: "values" },
              exec: (e, t, n) => {
                if (t.tab) {
                  if (e.uuid) {
                    const {
                      uuid: t,
                      id: n,
                      value: r,
                      key: s,
                      removed: i,
                      ts: o,
                    } = e;
                    Cd.setStorageByUidAndNotify(t, o, n, s, r, i);
                  }
                } else
                  w.warn("storage: unable to save storage due to empty tabID!");
                n({});
              },
            },
            c = {
              allow: { extpage: !0 },
              exec: (e, t, n) => {
                bi.onMessage(e.data).always((e) => {
                  const t = un.values.i18n,
                    r = un.snapshot;
                  n({ i18n: t, options: r, message: e });
                });
              },
            },
            u = {
              allow: { extpage: !0 },
              exec: (e, t, n) => {
                const r = Ia.getById(e.id);
                r
                  ? (w.verbose("mh: MC exec " + r.menuId),
                    Sa.emit("run", { menuId: r.menuId, event: e.event }))
                  : w.warn("mh: Error: unable to find MC id " + e.id),
                  n({});
              },
            },
            A = {
              allow: { script: "cookie" },
              exec: (e, t, n) => {
                var r;
                const s = [
                    "expirationDate",
                    "domain",
                    "httpOnly",
                    "secure",
                    "name",
                    "path",
                    "sameSite",
                    "value",
                  ],
                  i = [...s, "url"],
                  o = [...s, "session", "hostOnly"],
                  a = e.location || t.url || void 0,
                  l = e.details.url ? Un(e.details.url, a) || e.details.url : a,
                  c = t.tab ? t.tab.cookieStoreId : void 0;
                let u;
                if (
                  (na.fpi &&
                    a &&
                    (u =
                      null === (r = Zn(a)) || void 0 === r ? void 0 : r.domain),
                  ["iikm", "dhdg", "fire"].includes(qe.short_id))
                )
                  n({ data: { error: "not supported" } });
                else if (l)
                  if (eu.isAllowed(Fn(l)))
                    if (vu.scriptWillRun(e.uuid, l))
                      if ("list" == e.action) {
                        const t = e.details;
                        na.getAll({
                          url: l,
                          domain: t.domain,
                          name: t.name,
                          path: t.path,
                          firstPartyDomain: u ? null : void 0,
                          storeId: c,
                        }).done((e) => {
                          const t = e.map((e) => {
                            const t = o.reduce(
                              (t, n) => ({ ...t, [n]: e[n] }),
                              {}
                            );
                            return t;
                          });
                          n({ data: { cookies: t } });
                        });
                      } else if ("delete" == e.action) {
                        const t = e.details;
                        na.remove({
                          url: l,
                          name: t.name,
                          firstPartyDomain: u,
                          storeId: c,
                        })
                          .done(() => {
                            n({ data: { success: !0 } });
                          })
                          .fail((e) => {
                            n({ data: { error: e } });
                          });
                      } else if ("set" == e.action) {
                        const t = { firstPartyDomain: u, storeId: c },
                          r = e.details;
                        i.forEach((e) => {
                          const n = r[e];
                          void 0 !== n &&
                            (t[e] =
                              "value" === e || "name" === e ? String(n) : n);
                        }),
                          (t.url = t.url || l),
                          na
                            .set(t)
                            .done(() => n({ data: { success: !0 } }))
                            .fail((e) => n({ data: { error: e } }));
                      } else n({ data: { error: "unknown action" } });
                    else
                      n({
                        data: {
                          error:
                            "the URL needs to be included by the scripts @include or @match tag",
                        },
                      });
                  else
                    n({
                      data: {
                        error: "the URL is filtered by the security settings",
                      },
                    });
                else n({ data: { error: "invalid URL" } });
              },
            };
          return {
            ping: {
              allow: { insecure: !0 },
              exec: (e, t, n) => {
                n({
                  pong: !0,
                  instanceID: El,
                  config: { layout: un.values.layout, dark: qe.isDarkMode() },
                });
              },
            },
            newTab: {
              allow: { extpage: !0 },
              exec: (e, t, n) => {
                ("options" == t.extpage || "options" == e.origin
                  ? R.Pledge(t.tab)
                  : md()
                ).then((r) => {
                  Ye({ url: e.url, parent: r }, (r) => {
                    if (!r)
                      return void w.warn("mh: unable to create tab", t, e);
                    const s = { tabId: r.id };
                    n(s);
                  });
                });
              },
            },
            tabs: {
              allow: { script: "tabs" },
              exec: (e, t, n) => {
                "get" == e.action
                  ? t.tab && e.uuid
                    ? n({ data: ol(t.tab.id, e.uuid) })
                    : (w.warn("mh: unable to process request", t, e),
                      n({ data: null }))
                  : "list" == e.action
                  ? e.uuid
                    ? n({ data: al(e.uuid) })
                    : (w.warn("mh: unable to process request", t, e),
                      n({ data: null }))
                  : "set" == e.action
                  ? (t.tab && e.uuid
                      ? ((e, t, n) => {
                          const r = (il[e] = il[e] || {}),
                            s = {};
                          n && (Object.assign(s, n), (r[t] = s));
                        })(t.tab.id, e.uuid, e.tab)
                      : w.warn("mh: unable to process request", t, e),
                    n({}))
                  : n({ error: "unknown action" });
              },
            },
            focusTab: {
              allow: { script: "window.focus" },
              exec: (e, t, n) => {
                const r = t && t.tab ? t.tab.id : null;
                r
                  ? Je(r, { active: !0 }, () => {
                      const e = qe.lastError;
                      n({ error: e ? e.message : void 0 });
                    })
                  : n({ error: "internal error" });
              },
            },
            closeTab: e,
            setOption: {
              allow: {
                extpage: !0,
              },
              exec: (e, t, n) => {
                const r = "options" == t.extpage || "options" == e.origin;
                un.setValue(e.name, e.value).always(() => {
                  r
                    ? pl
                        .create("options.settings")
                        .done((e) => {
                          const t = { items: e, options: un.snapshot };
                          n(t);
                        })
                        .fail((e) => {
                          n({
                            error: e || "unknown error",
                            options: un.snapshot,
                          });
                        })
                    : n({});
                });
              },
            },
            reportAnIssue: n,
            clearHint: t,
            begEvent: r,
            buttonPress: s,
            imageUrlToTransferable: {
              allow: { extpage: !0 },
              exec: async (e, t, n) => {
                const r = e.url;
                let s;
                r && (s = await Cs(r)),
                  n({
                    transferable: s ? await s.toTransferableData() : void 0,
                  });
              },
            },
            loadTree: {
              allow: { extpage: !0 },
              exec: (e, t, n) => {
                pl.create(e.referrer, {
                  complete: e.complete,
                  url: e.url,
                  uuid: e.uuid,
                  filter: e.filter,
                  tabId: e.tabId,
                })
                  .done((t) => {
                    const r = { items: t },
                      s =
                        1 == pl.level(e.referrer)
                          ? {
                              i18n: un.values.i18n,
                              options: un.snapshot,
                              xhr: JA(),
                              begging: dl.needed(),
                            }
                          : {},
                      i = Object.assign(r, s);
                    n(i);
                  })
                  .fail((e) => {
                    n({ error: e || "unknown error", options: un.snapshot });
                  });
              },
            },
            miscConfig: i,
            modifyScriptOptions: {
              allow: { extpage: !0 },
              exec: (e, t, n) => {
                if (!e.uuid) return void n({});
                const r = "options" == t.extpage || "options" == e.origin;
                let s = null == e.reload || 1 == e.reload,
                  i = !1;
                const o = Cd.getByUid(e.uuid, !0),
                  a = () => {
                    s
                      ? (void 0 !== e.position &&
                          vu.reorderScripts(e.uuid, e.position),
                        r
                          ? Sl.loadTree.exec(
                              { referrer: "options.scripts" },
                              t,
                              n
                            )
                          : $e(null, (t) => {
                              pl
                                .create("actions")
                                .done((e) => {
                                  const t = {
                                    items: e,
                                    i18n: un.values.i18n,
                                    options: { enabled: un.values.enabled },
                                  };
                                  n(t);
                                })
                                .fail(() => {
                                  const e = {
                                    items: [],
                                    i18n: un.values.i18n,
                                    options: { enabled: un.values.enabled },
                                  };
                                  n(e);
                                }),
                                !t ||
                                  t.id < 0 ||
                                  (e.uuid &&
                                    un.values.autoReload &&
                                    tt(
                                      t.id,
                                      { method: "reload" },
                                      { frameId: 0 }
                                    ));
                            }))
                      : n({});
                  };
                if (o.script && o.cond)
                  if (
                    e.whitewash &&
                    o.script.evilness == Wi.SEVERITY_FOISTED_SCRIPT
                  )
                    (s = !0),
                      o.script && o.cond
                        ? vu
                            .doSave({
                              uuid: e.uuid,
                              src: o.script.textContent,
                              force_settings: { enabled: !0 },
                              whitewash: !0,
                              save: !0,
                            })
                            .always(a)
                        : (w.error(
                            Dr.getMessage("fatal_error") +
                              " (" +
                              e.uuid +
                              ")!!!"
                          ),
                          a());
                  else {
                    let t = !1;
                    const r = rs(),
                      s = ["includes", "excludes", "matches"],
                      l = ["connects", "blockers"],
                      c = o.script.options;
                    Object.keys(r.options).forEach((t) => {
                      const n = e[t];
                      void 0 !== n &&
                        ((c[t] = n), (i = i || !0 === Ea.SYNCED[t]));
                    });
                    const u = c.override;
                    Object.keys(r.options.override).forEach((n) => {
                      if (-1 == n.indexOf("merge_")) return;
                      const r = e[n];
                      void 0 !== r && ((u[n] = r), (t = !0));
                    }),
                      s.forEach((n) => {
                        const r = e[n];
                        void 0 !== r && ((t = !0), (u["use_" + n] = r));
                      }),
                      l.forEach((t) => {
                        const n = e[t];
                        void 0 !== n && (u["use_" + t] = n);
                      }),
                      e.add_excludes &&
                        ((c.override.use_excludes =
                          c.override.use_excludes.concat(e.add_excludes)),
                        (t = !0)),
                      t && (o.script = vu.mergeCludes(o.script)),
                      e.temp_connects &&
                        uu.setSessionConnects(o.script.uuid, e.temp_connects),
                      void 0 !== e.enabled && (o.script.enabled = e.enabled),
                      i && (o.script.lastModified = Date.now()),
                      void 0 !== e.file_url &&
                        (o.script.downloadURL = e.file_url),
                      vu
                        .doModify(o.script.uuid, o.script, i)
                        .done(a)
                        .fail(() => {
                          n({});
                        });
                  }
                else n({});
              },
            },
            purgeScripts: o,
            saveScript: a,
            saveExternal: {
              allow: { extpage: !0 },
              exec: (e, t, n) => {
                no.setElement(
                  e.uuid,
                  e.url,
                  {
                    content: e.code || "",
                    meta: e.mimetype || "text/javascript",
                  },
                  !0
                ),
                  pl
                    .create("options.scripts")
                    .done((e) => {
                      const t = { success: !0, items: e, options: un.snapshot };
                      n(t);
                    })
                    .fail((e) => {
                      const t = {
                        error: e || "unknown error",
                        options: un.snapshot,
                      };
                      n(t);
                    });
              },
            },
            saveStorageKey: l,
            download: {
              allow: { extpage: !0 },
              exec: (e, t, n) => {
                Ul.download.exec(
                  {
                    postMessage: (e) => {
                      (e.error || e.load) && n(e);
                    },
                    onMessage: () => null,
                    onDisconnect: () => null,
                    disconnect: () => null,
                  },
                  e,
                  t
                );
              },
            },
            askCom: c,
            execMenuCmd: u,
            unLoad: {
              allow: { script: [] },
              exec: (e, t) => {
                if (!e.topframe) {
                  w.verbose("mh: unload check " + e.id + " url: " + e.url);
                  const n = dd(t, e);
                  e.id &&
                    t.tab &&
                    n &&
                    hi.emit("unload", {
                      tabId: t.tab.id,
                      sender: n,
                      url: t.tab.url,
                    });
                }
                return !1;
              },
            },
            prepare: {
              allow: { script: [] },
              exec: (e, t, n) => {
                if (t.tab) {
                  const r = dd(t, e);
                  if (!r) return w.error("mh: unknown frameId", t, e);
                  const s = Fn(e.url);
                  e.cleanup
                    ? (bc(t.tab.id, r, s),
                      Ec.setIcon(t.tab.id),
                      Ec.setBadge(t.tab.id),
                      n({}))
                    : kc(t.tab.id, r, s, ud(t.tab), (r) => {
                        const s = r
                          ? Ll(r, e.url, ud(t.tab), t.tab.cookieStoreId)
                          : { fast: !0 };
                        n(s), Ec.setIcon(t.tab.id), Ec.setBadge(t.tab.id);
                      });
                } else n({});
              },
            },
            contextmenu: {
              allow: { script: [] },
              exec: (e, t, n) => {
                const { tab: r } = t;
                if (r && un.values.context_menu_enabled) {
                  const n = dd(t, e);
                  if (!n) return w.error("mh: unknown frameId", t, e);
                  const s = Fn(e.url);
                  let i = [],
                    o = [];
                  un.values.context_menu_scripts &&
                    (i = Pl(n, s, ud(t.tab)).contexters),
                    un.values.context_menu_commands &&
                      (o = Ia.listByTabId(r.id)),
                    tl.update({ contexters: i, commands: o });
                }
                n({});
              },
            },
            clipboard: {
              allow: { script: "setClipboard", extpage: !0 },
              exec: (e, t, n) => {
                pt
                  ? pt.set({ mimetype: e.mimetype, content: e.content }, () => {
                      n({ success: !0 });
                    })
                  : n({ error: "unsupported" });
              },
            },
            determineScriptsToRun: {
              allow: { extpage: !0 },
              exec: (e, t, n) => {
                n({
                  scripts: vu
                    .determineScriptsToRun(e.url)
                    .filter((e) => !e.deleted)
                    .map((e) => e.uuid),
                });
              },
            },
            externalMessage: {
              allow: { insecure: !0 },
              exec: (e, t, n) => Gl(e.request, t, n),
            },
            cookie: A,
          };
        })(),
        Cl = (e) => {
          const t = qe.id,
            n = (!Fe.HAS_SENDER_ID && e.tab) || e.id === t;
          let r;
          const s = Fe.INTERNAL_PAGE_PROTOCOLS[0],
            i = s ? s + "//" : null,
            o = qe.getInternalPageRegexp(),
            a = e.url ? e.url : e.tab ? e.tab.url : null,
            l = e.origin;
          let c = n && (!a || (!!i && 0 == a.indexOf(i))) && (!l || l === $);
          if (c || !i) {
            if (a) {
              const e = a.match(o);
              e && 2 == e.length && (r = e[1]);
            } else r = "*";
            !i && r && (c = !0);
          }
          return { id_valid: n, url: a, page: r, extpage: c };
        },
        Ml = (e, t) => {
          const { uuid: n } = e;
          if (void 0 === t) return !1;
          const r = Qt(t);
          if (0 === r.length) return !0;
          if (!n) return !1;
          const s = r
            .map((e) => {
              const t = Za[e];
              if (t) return [...t];
            })
            .filter((e) => void 0 !== e);
          return ((e, t) => {
            const n = Qt(t),
              { script: r, cond: s } = Cd.getByUid(e);
            if (r && s && r.grant.length) {
              const { grant: e } = r;
              return n.some((t) => e.includes(t));
            }
            return !1;
          })(n, [].concat(...s));
        },
        Il = (e, t, n) => {
          if (!k.late)
            return (
              k.registerLateCallback(() => {
                Il(e, t, n);
              }),
              !0
            );
          w.verbose("mh: request ", e, " sender: ", t);
          const r = Sl[e.method];
          if (!r) return w.warn("mh: unknown method " + e.method), !1;
          if (!r.allow || !r.exec)
            return w.warn("mh: invalid implementation of " + e.method), !1;
          const s = Cl(t),
            i = s.extpage,
            o = s.page,
            a = s.id_valid;
          w.verbose("mh: request page:", o, "extpage:", i),
            i ? (t.extpage = o) : delete e.origin;
          const l = "options" == o,
            c = a && !i;
          let u = !0;
          if (
            "background" == o ||
            r.allow.insecure ||
            (r.allow.extpage && i) ||
            (r.allow.options && l) ||
            (c && Ml(e, r.allow.script))
          ) {
            const s = r.exec(e, t, (e) => {
              if (((u = !1), n(e), qe.lastError)) return qe.lastError.message;
            });
            return (!1 !== u && !1 !== s) || void 0;
          }
          return (
            (!1 === e.topframe && (i || l)) ||
              w.warn(
                "mh: this context doesn't have the permission to call \"" +
                  e.method +
                  '"',
                s
              ),
            !1
          );
        },
        Gl = (e, t, n) => {
          let r, s;
          if (
            "off" != un.values.external_connect &&
            (r = t.url) &&
            eu.isAllowed(r)
          ) {
            for (const [t, n] of Object.entries(Tl)) {
              const i = wd({ match: [t] });
              if (i && bd(r, i) && (n.includes("*") || n.includes(e.method))) {
                s = !0;
                break;
              }
            }
            if (s)
              if ("getVersion" == e.method)
                n({ version: ze.manifest.version, id: qe.short_id });
              else if ("openOptions" == e.method) {
                let r = e.params || "";
                r && !r.startsWith("#") && (r = `#${r}`),
                  Je(
                    t.tab.id,
                    { url: ze.getURL("options.html") + r, active: !0 },
                    () => n({})
                  );
              } else if ("all" != un.values.external_connect)
                w.warn(
                  "mh: calling external method " +
                    e.method +
                    " is not permitted to " +
                    r +
                    " by the user"
                );
              else if ("isInstalled" == e.method) {
                let t,
                  r,
                  s,
                  i,
                  o = !1;
                const a = e.script.name,
                  l = e.script.namespace;
                (r = Cd.getUidsByName(a, l)[0]) &&
                  (t = Cd.getByUid(r)) &&
                  t.script &&
                  ((o = !0), (i = t.script.enabled), (s = t.script.version)),
                  n({ name: a, installed: o, enabled: i, version: s });
              } else w.warn("mh: unknown external method " + e.method);
            else
              w.warn(
                "mh: calling external method " +
                  e.method +
                  " is not permitted to " +
                  r
              );
          }
        },
        Ul = (() => {
          const e = {
              allow: { script: "xmlHttpRequest" },
              exec: (e, t, n) => {
                const {
                  disconnect: r,
                  postMessage: s,
                  onMessage: i,
                  onDisconnect: o,
                } = e;
                let a = !1;
                const l = t.details.anonymous;
                ["iikm", "dhdg", "fire"].includes(qe.short_id) &&
                  (w.warn(
                    "mh: xhr.details.redirect is available in beta versions only"
                  ),
                  delete t.details.redirect);
                const c = n.tab ? n.tab.cookieStoreId : void 0,
                  u = (e) => {
                    r();
                    const t = e.response;
                    t && t.responseHeaders;
                  };
                t.details.partialSize =
                  t.details.partialSize || Oe.PARTIAL_SIZE;
                const A = Object.assign(
                  {},
                  ...Object.keys(t.callbacks).map((e) => {
                    const n = "ondone" === e;
                    if (t.callbacks[e] || n || "onload" === e)
                      return {
                        [e]: (t) => {
                          const r = {
                            data: (t = t || {}).response || {},
                            exception: t.exception,
                            [e]: !0,
                          };
                          s(r), n && u(t);
                        },
                      };
                  })
                );
                let d;
                A.ondone || (A.ondone = (e) => u(e));
                const h = t.location || n.url || void 0;
                t.details.url = Un(t.details.url, h) || t.details.url;
                const p = t.details.responseType;
                (void 0 !== p && OA.includes(p)) ||
                  delete t.details.responseType,
                  Te.WEBREQUEST_XHR_SUPPORT &&
                    "no" != un.values.webrequest_modHeaders &&
                    ((t.details.headers = t.details.headers || {}),
                    (t.details.headers.internal = t.uuid),
                    Fe.SENDS_ORIGIN &&
                      !Object.keys(t.details.headers)
                        .map((e) => e.toLowerCase())
                        .includes("origin") &&
                      (t.details.headers.origin = null)),
                  (() => {
                    const e = t.details.cookie;
                    if (e && t.details.url) {
                      let n;
                      return (
                        (n = l
                          ? R.Pledge([])
                          : na.getAll({
                              url: t.details.url,
                              storeId: c,
                              firstPartyDomain: void 0,
                            })),
                        n.then((n) => {
                          const r = n
                            .map((e) => e.name + "=" + z(e.value))
                            .concat(e ? [e] : [])
                            .join(";");
                          delete t.details.cookie,
                            (t.details.headers = t.details.headers || {}),
                            (t.details.headers.cookie = r);
                        })
                      );
                    }
                    return R.Pledge();
                  })().then(() => {
                    var e;
                    if (a) {
                      const e = {
                        response: VA("aborted"),
                        exception: "aborted",
                      };
                      return A.onabort && A.onabort(e), void A.ondone(e);
                    }
                    let r;
                    if (
                      t.details.url &&
                      (r =
                        null === (e = Zn(t.details.url)) || void 0 === e
                          ? void 0
                          : e.protocol) &&
                      ["file:"].concat(Fe.INTERNAL_PAGE_PROTOCOLS).includes(r)
                    ) {
                      const e = (e) => {
                        const n =
                            'Refused to connect to "' +
                            t.details.url +
                            '": ' +
                            e,
                          r = VA(n);
                        ["onerror", "ondone"].forEach((e) => {
                          const t = A[e];
                          t && t({ response: r, exception: n });
                        });
                      };
                      if ("file:" == r) {
                        let n, r;
                        if (
                          (Te.ALLOWS_FILE_SCHEME_ACCESS &&
                            ("all" == un.values.script_file_access
                              ? (n = !0)
                              : "externals" != un.values.script_file_access ||
                                ((r = Cd.getByUid(t.uuid)) &&
                                  r.script &&
                                  r.cond &&
                                  [...r.script.resources, ...r.script.requires]
                                    .map((e) => Un(e.unsafe_url, e.abs_url))
                                    .includes(t.details.url) &&
                                  (n = !0))),
                          !n)
                        )
                          return e("Access to this local file is forbidden!");
                      }
                      dt(
                        t.details.url,
                        (e) => {
                          const t = fe(e),
                            n = A.onpartial;
                          if (n) {
                            const e = Yt(t || "", Oe.PARTIAL_SIZE);
                            e.forEach((t, r) => {
                              n({
                                response: {
                                  partial: t,
                                  index: r,
                                  length: e.length,
                                },
                              });
                            });
                          }
                          const r = {
                            readyState: 4,
                            responseHeaders: "",
                            status: 0,
                            statusText: "",
                          };
                          ["onload", "ondone"].forEach((e) => {
                            const t = A[e];
                            t && t({ response: r });
                          });
                        },
                        e
                      );
                    } else {
                      const e = { foreign_context: m, no_blob: t.no_blob };
                      d = uu.exec(t.details, t.uuid, n || {}, e, A);
                    }
                  });
                const f = () => {
                  a || (d ? d.abort() : (a = !0));
                };
                i((e) => {
                  e.cancel && f();
                }),
                  o(f);
              },
            },
            t = {
              allow: { script: "download" },
              exec: (e, t, n) => {
                const {
                  disconnect: r,
                  postMessage: s,
                  onMessage: i,
                  onDisconnect: o,
                } = e;
                let a,
                  l = e;
                if ("details" in t) {
                  const e = t.details;
                  if (e.from.url) {
                    const r = t.location || n.url || void 0;
                    e.from.url = Un(e.from.url, r) || e.from.url;
                  }
                  a = Ko.start(e, { internal: !!n.extpage });
                } else a = t.id;
                const c = (e) => {
                    l && s({ id: a, load: !0, data: e.info });
                  },
                  u = (e) => {
                    l && s({ id: a, progress: !0, data: e.info });
                  },
                  A = (e) => {
                    l && s({ id: a, error: !0, data: e });
                  },
                  d = (e) => {
                    l && s({ id: a, timeout: !0, data: e });
                  },
                  h = () => {
                    l && r(),
                      (l = null),
                      Mo.off("load", c),
                      Mo.off("progress", u),
                      Mo.off("error", A),
                      Mo.off("timeout", d),
                      Mo.off("done", h);
                  };
                Mo.on("load", c, { id: a }),
                  Mo.on("progress", u, { id: a }),
                  Mo.on("error", A, { id: a }),
                  Mo.on("timeout", d, { id: a }),
                  Mo.on("done", h, { id: a }),
                  i((e) => {
                    e.cancel && Ko.cancel(a);
                  }),
                  o(() => {
                    l = null;
                  });
              },
            },
            n = {
              allow: { script: "values" },
              exec: (e, t, n) => {
                const { postMessage: r, onMessage: s, onDisconnect: i } = e;
                n.tab
                  ? (w.verbose("storage: " + t.uuid + " " + t.id),
                    Cd.addStorageListener(
                      n.tab.id,
                      t.id,
                      t.uuid,
                      Date.now(),
                      (e) => r(e)
                    ),
                    s((t) => {
                      "saveStorageKey" === t.method
                        ? Sl.saveStorageKey.exec(t, n, (t) => e && r(t))
                        : w.warn("storage: unknown message", t);
                    }),
                    i(() => {
                      w.verbose(
                        "storage disconnectHandler " + t.uuid + " " + t.id
                      ),
                        Cd.removeStorageListeners(
                          { uuid: t.uuid, id: t.id },
                          !1
                        );
                    }))
                  : (w.verbose(
                      "storage: unable to load storage due to empty tabID!",
                      t
                    ),
                    r({ error: "missing tab id" }));
              },
            },
            r = {
              allow: { script: "openInTab" },
              exec: (e, t, n) => {
                const { postMessage: r, onMessage: s, onDisconnect: i } = e;
                let o,
                  a = e;
                const l = ["active"];
                let c = null;
                const u = [];
                let A;
                const d = (e) => {
                  e.tabId === c &&
                    (hi.off("remove", d), a && r({ closed: !0 }));
                };
                R.Pledge()
                  .then(() => {
                    const e = R();
                    if ("details" in t) {
                      const r = { url: t.details.url };
                      if ((o = t.details.options)) {
                        for (const e of l) void 0 !== o[e] && (r[e] = o[e]);
                        o.incognito
                          ? (r.incognito = !0)
                          : (o.insert && (r.index = n.tab.index + 1),
                            o.setParent
                              ? (r.parent = n.tab)
                              : (r.parent = { windowId: n.tab.windowId }));
                      }
                      Ye(r, async (t) => {
                        t && ((c = t.id), await Dc(c), e.resolve());
                      }),
                        qe.lastError && e.reject();
                    } else
                      jc(t.tabId).then((n) => {
                        n && ((c = t.tabId), e.resolve());
                      });
                    return e.promise();
                  })
                  .then(() => {
                    a &&
                      (null === c
                        ? r({ success: !1 })
                        : ((A = !1),
                          hi.on("remove", d),
                          u.push(() => hi.off("remove", d)),
                          r({ success: !0, tabId: c })));
                  }),
                  s((e) => {
                    if (null === c || A) return;
                    const { close: t, focus: n, name: s } = e;
                    if (n)
                      Je(c, { active: !0 }, () => {
                        const e = qe.lastError;
                        e && w.warn("tab.focus", e.message);
                      });
                    else if (t)
                      Ke(c, () => {
                        const e = qe.lastError;
                        e ? w.warn("tab.close", e.message) : (A = !0);
                      });
                    else if (void 0 !== s) {
                      const e = 5;
                      let t = 0;
                      const n = () => {
                        if (null === c) return;
                        const i = c,
                          o = ({ tabId: o }) => {
                            o === i &&
                              (a(),
                              tt(
                                i,
                                {
                                  method: "setForeignAttr",
                                  attr: "name",
                                  value: s,
                                },
                                { frameId: 0 },
                                (i) => {
                                  i
                                    ? r({ name: s })
                                    : t++ < e
                                    ? X(n, 100 * t)
                                    : w.warn("foreignAttr: error setting attr");
                                }
                              ));
                          };
                        hi.on("complete", o), hi.on("commited", o);
                        const a = () => {
                          hi.off("complete", o), hi.off("commited", o);
                        };
                        u.push(a);
                      };
                      n();
                    }
                  }),
                  i(() => {
                    u.forEach((e) => e()), (a = null);
                  });
              },
            },
            s = {
              allow: { script: "notification", extpage: !0 },
              exec: (e, t, n) => {
                const { postMessage: r, onMessage: s, onDisconnect: i } = e;
                if ("canceled" in t)
                  return void w.warn("notification: unexpected request", t);
                const o = t.image ? t.image : vs("tampermonkey");
                let a,
                  l = !1;
                const {
                    highlight: c,
                    title: u,
                    text: A,
                    timeout: d,
                    silent: h,
                    url: p,
                    tag: f,
                    id: m,
                  } = t,
                  g = (e) => {
                    l || ((l = !0), $e(null, (t) => Ye({ url: e, parent: t })));
                  };
                let v, _;
                s((e) => {
                  _ && a && "canceled" in e && !e.canceled && g(a);
                }),
                  i(() => {
                    !v || p || f || v(), (v = void 0);
                  }),
                  (() => {
                    const e = R();
                    return (
                      c && n.tab
                        ? (function (e, t) {
                            if (e && e.tabs) {
                              const n =
                                  e.tabs instanceof Array ? e.tabs : [e.tabs],
                                r = [];
                              let s;
                              const i = () => {
                                if (!n.length)
                                  return Se.tabs.highlight(
                                    { windowId: s, tabs: r },
                                    () => {
                                      Se.windows.update(
                                        s,
                                        { focused: !0 },
                                        () => {
                                          t && t();
                                        }
                                      );
                                    }
                                  );
                                {
                                  const e = n.pop();
                                  Se.tabs.get(e, (e) => {
                                    void 0 === s && (s = e.windowId),
                                      e.windowId === s && r.push(e.index),
                                      i();
                                  });
                                }
                              };
                              i();
                            } else t && t();
                          })({ tabs: n.tab.id }, () => e.resolve())
                        : e.resolve(),
                      e.promise()
                    );
                  })()
                    .then(() => {
                      const e = R();
                      return (
                        A
                          ? ((a = p),
                            (v = Qs(
                              u,
                              A,
                              o,
                              { timeout: d, silent: h, notificationId: m },
                              (t) => e.resolve(t.clicked)
                            ).cancel))
                          : e.resolve(),
                        e.promise()
                      );
                    })
                    .always((e) => {
                      _ = e;
                      const t = r({ clicked: _, notificationId: m });
                      _ && t && a && g(a);
                    });
              },
            },
            i = {
              allow: { extpage: !0 },
              exec: async (e, t) => {
                const { postMessage: n, onDisconnect: r } = e;
                let s = e;
                const i = void 0 === t.reload || !!t.reload;
                let o,
                  a,
                  l,
                  { data: c, json: u, code: A, url: d } = t;
                if (d)
                  try {
                    s && n({ progress: Dr.getMessage("Loading") }),
                      (l = await pd(d));
                  } catch (e) {
                    return void n({
                      error: Dr.getMessage(
                        "Unable_to_load_script_from_url_0url0",
                        d
                      ),
                    });
                  }
                if (c || l) {
                  if (l) {
                    s && n({ progress: Dr.getMessage("Decoding") });
                    try {
                      c = await ge(l);
                    } catch (e) {}
                  }
                  if (c)
                    try {
                      a = await Rl.zip.read(c).progress((e) => {
                        s && n({ progress: e });
                      });
                    } catch (e) {}
                  if (!a) {
                    if (l)
                      try {
                        u = await ge(l, { encoding: "UTF-8" });
                      } catch (e) {}
                    u = c;
                  }
                }
                if (u && !A && !a)
                  try {
                    a = await Rl.json.read(u);
                  } catch (e) {
                    try {
                      A = de(u);
                    } catch (e) {
                      A = u;
                    }
                  }
                if (a) {
                  const e = {
                    scripts: Object.values(a.scripts).map((e) =>
                      ((e) => {
                        const t = e.meta || {},
                          n = e.settings || {},
                          r = (e) => ({
                            url: e.meta.url,
                            sri: e.meta.sri,
                            ts: e.meta.ts || null,
                            mimetype: e.meta.mimetype,
                            modified: e.meta.modified,
                            content: e.source,
                          });
                        return {
                          source: e.source,
                          name: t.name,
                          uuid: t.uuid,
                          file_url: t.file_url,
                          options: e.options,
                          storage: e.storage || { ts: 0, data: {} },
                          lastModified: t.modified,
                          enabled: n.enabled,
                          position: n.position,
                          resources: e.resources ? e.resources.map(r) : [],
                          requires: e.requires ? e.requires.map(r) : [],
                        };
                      })(e)
                    ),
                    global_settings: a.global_settings,
                  };
                  o = vu
                    .importFromJson(e)
                    .then((e) => ({ reload: !!e.global_settings, success: !0 }))
                    .fail(() => {
                      n({ error: Dr.getMessage("Unable_to_parse_this_") });
                    });
                } else {
                  if (!A)
                    return void n({
                      error: Dr.getMessage("Unable_to_parse_this_"),
                    });
                  o = vu
                    .installFromSource(A, { force_url: d }, { silent_fail: !0 })
                    .fail((e) => {
                      var t;
                      const r =
                        ((null === (t = null == e ? void 0 : e.messages) ||
                        void 0 === t
                          ? void 0
                          : t.errors) || [])[0] ||
                        Dr.getMessage("Unable_to_parse_this_");
                      n({ error: r });
                    })
                    .then((e) => ({ installed: e ? 1 : 0, success: !0 }));
                }
                o.done((e) => {
                  i && !e.reload
                    ? pl
                        .create("options.scripts")
                        .done((t) => {
                          const r = { ...e, items: t };
                          n(r);
                        })
                        .fail((e) => {
                          n({
                            error:
                              e ||
                              Dr.getMessage("An_error_occured_during_import_"),
                          });
                        })
                    : n(e);
                }),
                  r(() => {
                    s = null;
                  });
              },
            };
          return {
            keepAlive: {
              allow: { script: [] },
              exec: (e) => {
                e.onMessage(() => {});
              },
            },
            xhr: e,
            download: t,
            webRequest: {
              allow: { script: "webRequest" },
              exec: (e, t, n) => {
                const { postMessage: r } = e,
                  s = n.tab.id,
                  i = dd(n);
                if (!i) return w.error("mh: unknown frameId", n, t);
                void 0 !== s &&
                  i &&
                  _c(s, i, t.uuid, t.rules, (e) => {
                    r(e);
                  });
              },
            },
            addStorageListener: n,
            exportToJson: {
              allow: { extpage: !0 },
              exec: (e, t) => {
                const { postMessage: n } = e;
                vu.exportToJson(t.ids, t.options)
                  .done((e) => {
                    const t = JSON.stringify(e);
                    Yt(t, Oe.PARTIAL_SIZE).forEach((e) => n({ partial: e })),
                      n({
                        done: !0,
                      });
                  })
                  .fail((e) => {
                    n({ error: e || "serialization error" });
                  });
              },
            },
            openInTab: r,
            notification: s,
            registerMenuCommand: {
              allow: { script: "menuCommand" },
              exec: (e, t, n) => {
                const { postMessage: r, onDisconnect: s } = e;
                if (n.tab) {
                  w.verbose("registerMenuCommand: add " + t.menuId);
                  const {
                      name: e,
                      uuid: i,
                      accessKey: o,
                      autoClose: a,
                      menuId: l,
                      title: c,
                      createdAt: u,
                    } = t,
                    A = n.tab.id;
                  let d;
                  const h = Cd.getByUid(i);
                  d =
                    h.script && h.cond
                      ? Dr.getTranslation(h.script, "name")
                      : Dr.getMessage("This_script_was_deleted");
                  const p = (e) => {
                    r({ method: "run", menuId: l, event: e.event });
                  };
                  Sa.on("run", p, { menuId: l }),
                    Ia.set({
                      tabId: A,
                      createdAt: u,
                      name: e,
                      title: c,
                      uuid: i,
                      accessKey: o,
                      autoClose: a,
                      menuId: l,
                      scriptName: d,
                    }),
                    $s.actionPage("update"),
                    s(() => {
                      const e = Sa.listening("run", { menuId: l });
                      w.verbose(`registerMenuCommand: unreg ${l} -> ${e}`),
                        1 === e && (Ia.clearById(l), $s.actionPage("update")),
                        Sa.off("run", p);
                    });
                } else
                  w.warn("Unable to register menu cmd due to empty tabID!");
              },
            },
            observeUrlChanges: {
              allow: { script: "window.onurlchange" },
              exec: (e, t, n) => {
                const { postMessage: r, onDisconnect: s } = e,
                  i = n.frameId,
                  o = n.tab.id,
                  a = (e) => {
                    e.tabId == o && e.frameId == i && r({ url: e.url });
                  };
                vl(o, a),
                  s(() => {
                    _l(o, a);
                  });
              },
            },
            tabWatch: {
              allow: { extpage: !0 },
              exec: (e, t, n) => {
                const { disconnect: r, postMessage: s, onDisconnect: i } = e,
                  { active: o, url: a, filter: l } = t,
                  c = Lc.openAndWatch(
                    {
                      url: a,
                      active: o,
                      filter: l ? new RegExp(l) : void 0,
                      index: (n.tab.index || 0) + 1,
                      parent: n.tab,
                    },
                    (e) => {
                      e ? s({ tab: e }) : (u(), r());
                    }
                  ),
                  u = () => {
                    c.cancel();
                  };
                i(u);
              },
            },
            syncInfo: {
              allow: { extpage: !0 },
              exec: (e) => {
                const { postMessage: t, onDisconnect: n } = e,
                  r = (e) => t({ info: e });
                di.on("syncProgressEvent", r),
                  n(() => {
                    di.off("syncProgressEvent", r);
                  });
              },
            },
            importEx: i,
            backgroundControl: {
              allow: { script: [] },
              exec: async (e, t) => {
                const { postMessage: n } = e;
                let r;
                un.values.background_control
                  ? "restart" in t && t.restart
                    ? je(0, !1)
                    : (r = "unsupported action")
                  : (r = "not supported"),
                  n({ error: r });
              },
            },
          };
        })(),
        Zl = (() => {
          const e = (e, t) => {
            t.messageId &&
              e.postMessage({
                messageId: t.messageId,
                ack: !0,
                method: t.method,
              });
          };
          return (t) => {
            let n;
            const r = (s) => {
              k.ensureLate(() => {
                if (n) n(s);
                else if (void 0 !== s.method) {
                  const i = ((t, n) => {
                    const r = t.sender;
                    w.verbose(
                      "mh: connect.method " +
                        n.method +
                        " contextId " +
                        n.id +
                        " tabId: " +
                        (r.tab ? r.tab.id : "unknown!!!")
                    );
                    const s = Ul[n.method];
                    if (!s) return w.warn("mh: unknown method " + n.method), !1;
                    if (!s.allow || !s.exec)
                      return (
                        w.warn("mh: invalid implementation of " + n.method), !1
                      );
                    const i = Cl(r),
                      o = i.extpage,
                      a = i.page,
                      l = "options" == a,
                      c = i.id_valid && !o;
                    if (
                      "background" == a ||
                      s.allow.insecure ||
                      (o && s.allow.extpage) ||
                      (l && s.allow.options) ||
                      (c && Ml(n, s.allow.script))
                    ) {
                      let i;
                      return (
                        e(t, n),
                        s.exec(
                          {
                            postMessage: (e) => {
                              try {
                                t.postMessage(e);
                              } catch (n) {
                                return (
                                  w.debug(
                                    "mh: Error sending port (" +
                                      t.name +
                                      ") message",
                                    e,
                                    n
                                  ),
                                  n.message || n
                                );
                              }
                            },
                            disconnect: () => t.disconnect(),
                            onMessage: (n) => {
                              if (!1 === i)
                                throw Error(
                                  "port message listener registration must be done synchronously"
                                );
                              i = (r) => {
                                e(t, r), n(r, t);
                              };
                            },
                            onDisconnect: (e) => t.onDisconnect.addListener(e),
                          },
                          n,
                          { ...r, extpage: o ? a : void 0 }
                        ),
                        (i = i || !1),
                        i
                      );
                    }
                    return (
                      (!1 === n.topframe && (o || l)) ||
                        w.warn(
                          "mh: this context doesn't have the permission to call \"" +
                            n.method +
                            '"'
                        ),
                      !1
                    );
                  })(t, s);
                  i ? (n = i) : t.onMessage.removeListener(r);
                } else w.warn("mh: invalid request", s);
              });
            };
            t.onMessage.addListener(r);
          };
        })(),
        Tl = {
          "*://*.tampermonkey.net/*": ["getVersion", "openOptions"],
          "*://*.greasyfork.org/*": ["*"],
          "*://*.sleazyfork.org/*": ["*"],
          "*://*.openuserjs.org/*": ["*"],
          "*://*.userstyles.org/*": ["*"],
          "*://*.userscript.zone/*": ["*"],
        },
        Bl = (() => {
          const e = {
            exec: async (e, t, n, r) => {
              if (!e) throw Error("invalid port");
              const s = "options.scripts.userscripts",
                { action: i, messageId: o } = t,
                a = (e, t, n) =>
                  r({ messageId: e, error: { number: t, message: n } });
              try {
                if ("options" == i)
                  r({
                    messageId: o,
                    allow: ["options", "list", "get", "patch"],
                  });
                else if ("list" == i) {
                  const e = (await pl.create(s)).filter((e) => e.userscript),
                    t = {
                      messageId: o,
                      list: e.map((e) => {
                        const {
                            uuid: t,
                            namespace: n,
                            name: r,
                            requires: s,
                            storage_key_count: i,
                          } = e,
                          o = `${z(t)}`;
                        return {
                          namespace: n || "",
                          name: r,
                          path: `${o}/source`,
                          requires: s
                            .filter((e) => e.url)
                            .map((e) => `${o}/external/${z(e.url)}`),
                          storage: i ? `${o}/storage` : void 0,
                        };
                      }),
                    };
                  r(t);
                } else if ("get" == i) {
                  const { path: e, ifNotModifiedSince: n } = t,
                    [i, l, c] = e.split("/").map((e) => V(e));
                  if (!["source", "storage", "external"].includes(l))
                    return a(o, 404, "Not found");
                  try {
                    let e, t;
                    if ("storage" === l) e = Cd.getStorageByUid(i).ts;
                    else if ("source" === l) {
                      const { script: t, cond: n } = Cd.getByUid(i);
                      if (!t || !n) return a(o, 404, "Not found");
                      e = t.lastModified;
                    } else if (c) {
                      const t = no.getElement(i, c);
                      t && (e = t.ts);
                    }
                    if (!n || !e || e > n) {
                      const e = (
                        await pl.create(`${s}.${l}`, { uuid: i, url: c })
                      )[0];
                      if (void 0 === e) return a(o, 404, "Not found");
                      if ("string" == typeof e) t = e;
                      else {
                        const n = {};
                        Object.keys(e).forEach((t) => {
                          n[t] = Re(e[t]);
                        }),
                          (t = ((e) => {
                            const t = `__undefined__${Xt()}`;
                            return JSON.stringify(
                              e,
                              (e, n) => (void 0 === n ? t : n),
                              void 0
                            ).replace(new RegExp(`"${t}"`, "g"), "undefined");
                          })(n));
                      }
                    }
                    r({ messageId: o, value: t, lastModified: e });
                  } catch (e) {
                    return a(o, 404, "Not found");
                  }
                } else if ("patch" === i) {
                  const { path: e, value: n, lastModified: s } = t,
                    [i, l, c] = e.split("/").map((e) => V(e));
                  if (!i || "string" != typeof n)
                    return a(o, 400, "Bad Request");
                  const { script: u, cond: A } = Cd.getByUid(i);
                  if (!u || !A) return a(o, 404, "Not found");
                  if ("source" == l) {
                    if (void 0 !== c) return a(o, 400, "Bad Request");
                    vu.doSave({
                      name: u.name,
                      uuid: i,
                      src: n,
                      ask: !un.values.editor_easySave,
                      external: !0,
                      save: !0,
                      ...(s ? { force_meta: { lastModified: s } } : {}),
                    })
                      .done(() => {
                        r({ messageId: o });
                      })
                      .fail(() => {
                        a(o, 400, "Bad Request");
                      });
                  } else if ("storage" == l) {
                    if (void 0 !== c) return a(o, 400, "Bad Request");
                    const e = s || Date.now();
                    try {
                      const t = Cd.getStorageByUid(i).data,
                        r = Object.entries(JSON.parse(n)).reduce(
                          (e, [t, n]) => ((e[t] = xe(n)), e),
                          {}
                        );
                      ((t, n) => {
                        const r = Object.keys(n),
                          s = Object.keys(t);
                        r.concat(s)
                          .filter((e, t, n) => n.lastIndexOf(e) === t)
                          .forEach((o) => {
                            r.includes(o)
                              ? s.includes(o)
                                ? n[o] !== t[o] &&
                                  ((t, n, r) => {
                                    Cd.setStorageByUidAndNotify(
                                      i,
                                      e,
                                      void 0,
                                      t,
                                      r
                                    );
                                  })(o, t[o], n[o])
                                : ((t, n) => {
                                    Cd.setStorageByUidAndNotify(
                                      i,
                                      e,
                                      void 0,
                                      t,
                                      n
                                    );
                                  })(o, n[o])
                              : ((t) => {
                                  Cd.setStorageByUidAndNotify(
                                    i,
                                    e,
                                    void 0,
                                    t,
                                    void 0,
                                    !0
                                  );
                                })(o, t[o]);
                          });
                      })(t, r);
                    } catch (e) {
                      return a(o, 400, "Bad Request");
                    }
                    r({ messageId: o });
                  } else {
                    if ("external" != l) return a(o, 404, "Not found");
                    {
                      const e = no.getElement(i, c);
                      if (!e) return a(o, 404, "Not found");
                      const t = e.data.meta || "text/javascript";
                      await no.setElement(
                        i,
                        c,
                        { content: n, meta: t, lastModified: s },
                        !0
                      ),
                        r({ messageId: o });
                    }
                  }
                } else {
                  if ("put" === i || "delete" == i)
                    return a(o, 405, "Method Not Allowed");
                  w.warn(`emh: unknown action ${i}`), e.disconnect();
                }
              } catch (e) {
                return a(o, 500, "Internal error");
              }
            },
          };
          return { userscripts: e };
        })(),
        Ol = [
          "editor-firefox@tampermonkey.net",
          "hohmicmmlneppdcbkhepamlgfdokipcd",
          "lieodnapokbjkkdkhdljlllmgkmdokcm",
        ],
        Fl = (e) => {
          k.late
            ? e.onMessage.addListener((t) => {
                void 0 !== t.method &&
                  ((e, t) => {
                    const { sender: n } = e,
                      { id: r } = n;
                    if (!Ol.includes(r)) return void e.disconnect();
                    w.verbose(
                      "emh: connect.method " +
                        t.method +
                        " contextId " +
                        t.id +
                        " tabId: " +
                        (n.tab ? n.tab.id : "unknown!!!"),
                      t
                    );
                    const s = Bl[t.method] || {},
                      { exec: i } = s;
                    if (!i)
                      return w.warn("emh: unknown method " + t.method), !1;
                    const o = i(e, t, n, (t) => {
                      try {
                        e.postMessage(t);
                      } catch (n) {
                        w.debug(
                          `emh: error sending message to port[${e.name}]`,
                          t,
                          n
                        );
                      }
                    });
                    "function" == typeof o && e.onDisconnect.addListener(o),
                      w.verbose("emh: connect.method " + t.method + " end!");
                  })(e, t);
              })
            : k.registerLateCallback(() => {
                Zl(e);
              });
        };
      let Dl;
      const jl = {
          init: () => {
            ze.onMessage.addListener(Il),
              ze.onConnect.addListener(Zl),
              ze.onConnectExternal.addListener(Fl);
          },
          get externally_connectable_reg() {
            return (
              Dl ||
                (Dl = wd({
                  match: Object.keys(Tl),
                })),
              Dl
            );
          },
          externally_connectable: Tl,
        },
        Pl = (e, t, n, r) => {
          const s = e.id + "#" + (n ? "i" : "n") + (r ? "a" : "e") + "#" + t,
            i = yd.get(s);
          let o = i ? JSON.parse(i) : void 0;
          if (!o) {
            const i = [],
              a = [],
              l = [],
              c = [],
              u = {};
            if (t) {
              const s = vu.determineScriptsToRun(t, !0, !r || void 0);
              for (const t of s)
                if (!t.deleted) {
                  if (
                    (w.verbose("check " + t.name + " for enabled:" + t.enabled),
                    void 0 !== n &&
                      !(t.options.tab_types || un.values.default_tab_types)
                        .split("+")
                        .includes(n ? "incognito" : "normal"))
                  )
                    continue;
                  (Ad(e) ||
                    (!0 !== t.options.noframes &&
                      (null !== t.options.noframes ||
                        !0 !== t.options.override.orig_noframes))) &&
                    (t.evilness &&
                    t.evilness >=
                      Math.min(
                        Wi.SEVERITY_MAX,
                        un.values.script_blacklist_severity
                      )
                      ? l.push(t)
                      : t.enabled
                      ? ((u[t.uuid] = t.name),
                        vu.isContexter(t) ? c.push(t) : i.push(t))
                      : a.push(t));
                }
            }
            (o = {
              contexters: c,
              runners: i,
              disabled: a,
              evilness: l,
              script_map: u,
            }),
              t && yd.set(s, JSON.stringify(o));
          }
          return o;
        },
        Ll = (e, t, n, r) => {
          const { runners: s, contexters: i } = e,
            o =
              [
                {
                  m: "native",
                  t: [Ko.staticVars.DEFAULT, Ko.staticVars.NATIVE],
                },
                {
                  m: "disabled",
                  t: [Ko.staticVars.OFF],
                },
                { m: "browser", t: [Ko.staticVars.CHROME] },
              ]
                .filter((e) => {
                  if (e.t.includes(un.values.downloads_mode)) return !0;
                })
                .map((e) => e.m)[0] || "disabled",
            {
              js: a,
              dom: l,
              raw: c,
            } = ((e) => {
              let t, n, r;
              switch (e) {
                case "raw+":
                  r = t = n = !0;
                  break;
                case "default":
                case "-js":
                  (r = t = !0), (n = !1);
                  break;
                case "js+":
                  (t = n = !0), (r = !1);
                  break;
                case "js":
                  (t = !0), (r = n = !1);
                  break;
                case "dom":
                  (n = !0), (t = r = !1);
                  break;
                case "raw":
                  (r = !0), (n = t = !1);
              }
              return { js: t, dom: n, raw: r };
            })(un.values.sandbox_mode),
            u = ra,
            A = (e) => {
              const t = [],
                n = [],
                r = [];
              return (
                e.forEach((e) => {
                  let t, s;
                  e.script
                    ? ((t = e.script.options.sandbox), (s = e.script.name))
                    : ((t = e.options.sandbox), (s = e.name));
                  const i = "raw" === t || null === t,
                    o = "JavaScript" === t,
                    a = "DOM" === t,
                    u = () =>
                      w.info(
                        `content: script "${s}" wants to be executed inside a ${
                          t || "raw"
                        }-level sandbox, but this mode is currently disabled at the security settings`
                      );
                  a && l
                    ? r.push(e)
                    : ((o || a) && u(),
                      c
                        ? n.push(e)
                        : (i && u(),
                          l
                            ? r.push(e)
                            : w.warn(
                                `content: script "${s}" can't be executed`
                              )));
                }),
                {
                  dom: r.length ? r : void 0,
                  raw: n.length ? n : void 0,
                  js: t.length ? t : void 0,
                }
              );
            },
            d =
              !n &&
              "off" != un.values.external_connect &&
              bd(t, jl.externally_connectable_reg),
            h = {
              scripts: A(s || []),
              contexters: A(
                (i || []).map((e) =>
                  ((e) => {
                    const {
                      uuid: t,
                      options: n,
                      name: r,
                      name_i18n: s,
                      description: i,
                      description_i18n: o,
                    } = e;
                    return {
                      uuid: t,
                      options: n,
                      name: r,
                      name_i18n: s,
                      description: i,
                      description_i18n: o,
                    };
                  })(e)
                )
              ),
              external_connect: d,
              nonce: e.nonce,
              originalURL: t,
              injectMode: un.values.runtime_inject_mode,
              contentMode: un.values.runtime_content_mode,
              inIncognitoContext: n,
              isFirstPartyIsolation: na.fpi,
              container: r,
              userAgent: u,
              downloadMode: o,
              relaxedCsp: un.values.webrequest_fixCSP,
              sandboxMode: un.values.sandbox_mode,
              enforce_strict_mode: "on" == un.values.runtime_strict_mode,
              top_level_await: ["default", "on"].includes(
                un.values.runtime_top_level_await
              ),
              measure_scripts: un.values.debug,
              logLevel: un.values.logLevel,
              version: ze.manifest.version,
            };
          return h;
        },
        Nl = "tm_content",
        Vl = {
          js: [{ file: "page.js" }, { file: "content.js" }],
          matches: ["<all_urls>"],
          runAt: "document_start",
          allFrames: !0,
        };
      let zl;
      const ql = async () => {
          ["instant"].includes(un.values.runtime_inject_mode)
            ? await (async () => {
                await new f((e) => {
                  zl.onPageChanged.removeRules(void 0, () => e());
                });
              })()
            : await (async () => {
                await new f((e) => {
                  zl.onPageChanged.getRules([Nl], async (t) => {
                    if (t.length) return e();
                    zl.onPageChanged.addRules(
                      [
                        {
                          id: Nl,
                          conditions: [
                            new zl.PageStateMatcher({
                              pageUrl: { urlContains: "://" },
                            }),
                          ],
                          actions: [
                            new zl.RequestContentScript({
                              js: Vl.js.map((e) => e.file),
                            }),
                          ],
                        },
                      ],
                      () => e()
                    );
                  });
                });
              })();
        },
        Hl = new Is(1);
      let Ql = 1;
      const Wl = Ql++,
        Xl = Ql++,
        Yl = Ql++,
        Jl = Ql++,
        Kl = Ql++,
        $l = Ql++,
        ec = (Ql++, Ql++),
        tc = Ql++,
        nc = Ts("execInfo"),
        rc = {},
        sc = G({ retimeout_on_get: !0, timeout: 300, check_interval: 120 }),
        ic = {},
        oc = (e) => {
          const t = `${e}`;
          delete ic[e], delete rc[e], sc.remove(t), nc.delete(t);
        },
        ac = (e) => {
          const t = rc[e];
          if (t) return t;
          {
            const t = { map: {}, scripts: {}, searched: {} };
            return (rc[e] = t), t;
          }
        },
        lc = (e, t, n, r) => cc(e, t, n, r),
        cc = (e, t, n, r, s, i) => {
          const o = ac(e);
          if (void 0 !== s && n) o.searched[n] = s;
          else if (void 0 !== i) o.forbidden = !0;
          else if (t) {
            const e = t.id;
            let s = o.map[e];
            void 0 === s &&
              (s = o.map[e] = { active: !0, sender: t, scripts: [], urls: [] }),
              r
                ? (s.scripts.push(r.uuid), (o.scripts[r.uuid] = r.name))
                : (s.active = !1),
              n && !s.urls.includes(n) && s.urls.push(n);
          } else w.warn("setExecInfo: sender missing");
          ((e) => {
            const t = `${e}`,
              n = rc[e];
            n ? nc.set(t, n) : nc.delete(t);
          })(e);
        },
        uc = (e, t) => {
          const n = `${e}`,
            r = sc.get(n);
          if (r) return r;
          if (!t) {
            const e = { scripts: {}, objurl: {}, running: 0, disabled: 0 };
            return sc.set(n, e), e;
          }
        },
        Ac = (e, t, n) => {
          let r = ic[e];
          if (
            (r || n || ((r = { frames: {}, requests: {} }), (ic[e] = r)), r)
          ) {
            const e = t.id,
              n = r.frames;
            n[e] || (n[e] = { sender: t, state: Wl });
          }
          return r;
        },
        dc = function (e, t, n, r) {
          let s;
          return (
            eu.isAllowed(n)
              ? (s = Pl(t, n, r))
              : (w.log(
                  "This URL is filtered by the security settings:",
                  n,
                  "-> Do nothing!"
                ),
                vc(e, t),
                (s = {
                  contexters: [],
                  runners: [],
                  disabled: [],
                  evilness: [],
                  script_map: {},
                })),
            s.runners.forEach((n) => {
              n.webRequest &&
                n.webRequest.length &&
                _c(e, t, n.uuid, n.webRequest);
            }),
            s
          );
        },
        hc = (e, t) => {
          un.values.userscript_search_url &&
            "badge" == un.values.userscript_search_mode &&
            void 0 === ac(t).searched[e] &&
            xo(e).then((n) => {
              ((e, t, n) => {
                cc(e, void 0, t, void 0, n);
              })(t, e, n.count),
                Ec.setBadge(t);
            });
        };
      let pc, fc;
      const mc = (e) => {
          const t = ac(e.id),
            { scripts: n, map: r } = t,
            s = {};
          for (const e of Object.keys(n)) {
            let t = [],
              n = 0,
              i = [];
            Object.values(r).forEach(({ active: r, scripts: s, urls: o }) => {
              (i = i.concat(o)),
                r && (t = t.concat(s.filter((t) => t == e))),
                (n += s.filter((t) => t == e).length);
            });
            const o = Ft(t).length;
            s[e] = { count: o, all_time: n, urls: i };
          }
          return s;
        },
        gc = (e) => {
          const t = {},
            n = ac(e.id),
            { map: r } = n;
          for (const { sender: n, urls: s } of Object.values(r))
            for (const r of s) {
              if (
                (w.verbose(`Found at info[${e.id}] -> ${r}`), !eu.isAllowed(r))
              )
                continue;
              const {
                runners: s,
                contexters: i,
                disabled: o,
                evilness: a,
              } = Pl(n, r, ud(e), !0);
              [s, i, o, a].forEach((e) => {
                e.forEach((e) => {
                  t[e.uuid] = e;
                });
              });
            }
          return t;
        },
        vc = (e, t) => {
          Ad(t) &&
            ((e) => {
              cc(e, void 0, void 0, void 0, void 0, !0);
            })(e);
        },
        _c = (e, t, n, r, s) => {
          const i = t.frameId;
          if (void 0 === i) return;
          const o = [];
          r.forEach((e) => {
            const t =
                "string" == typeof e.selector
                  ? { include: [e.selector] }
                  : e.selector,
              n = ["include", "match", "exclude"].reduce((e, n) => {
                const r = t[n];
                return r && (e[n] = "string" == typeof r ? [r] : r), e;
              }, {}),
              r = e.action;
            let s;
            if ("string" == typeof r) s = "cancel" === r ? { cancel: !0 } : {};
            else {
              const { cancel: e, redirect: t } = r;
              s =
                "string" == typeof t
                  ? { redirect: { url: t } }
                  : { cancel: e, redirect: t };
            }
            o.push({ selector: n, action: s });
          }),
            ((e, n, r, s) => {
              const o = Ac(e, t);
              (o.requests[i] || (o.requests[i] = {}))[r] = s;
            })(e, 0, n, {
              id: n + "@" + e + ":" + t.id + "#" + Date.now(),
              rules: o,
              uuid: n,
              callback: s,
            });
        },
        wc = (e, t) => {
          const n = ac(e),
            { map: r, searched: s } = n;
          let i = 0,
            o = 0,
            a = [];
          for (const { active: e, scripts: n, urls: l } of Object.values(r)) {
            for (const e of l) {
              const t = s[e];
              void 0 !== t && (o = t);
            }
            e && ((i += n.length), t && (a = a.concat(n)));
          }
          return {
            running: i,
            searched: o,
            unique: a.length ? Ft(a).length : 0,
          };
        },
        bc = (e, t, n) => {
          if (Ac(e, t, !0)) {
            if (n) {
              const t = Fn(n),
                r = uc(e, !0);
              r && delete r.scripts[t];
            }
            const r = ((e, t) => {
              const n = uc(e),
                r = n.objurl[t.id];
              return void 0 !== r && delete n.objurl[t.id], r;
            })(e, t);
            r && URL.revokeObjectURL(r);
          }
        };
      hi.on("active", ({ tabId: e, windowId: t }) => {
        (pc = t),
          (fc = e),
          $e(t, (t) => {
            t && t.id == e && hc(t.url, e);
          });
      }),
        hi.on("reset", ({ tabId: e }) => {
          let t;
          if (Te.FAST_EXEC_SUPPORT && (t = ic[e]))
            for (const { sender: n } of Object.values(t.frames)) bc(e, n);
          oc(e);
        });
      const yc = (e, t, n, r) => {
        if (!un.values.enabled) return;
        const s = t.id,
          i = Ac(e, t).frames[s],
          o = i.state || Wl,
          a = Fn(n);
        let l;
        const c = uc(e);
        return (
          (l = c.scripts[a]),
          o < Jl &&
            ((uc(e).scripts[n] = l),
            (l = l || dc(e, t, a, r)),
            (i.state = Jl),
            (c.scripts[a] = l)),
          l
        );
      };
      hi.on(
        "response",
        ({ tabId: e, sender: t, url: n, incognito: r, cookieStoreId: s }) => {
          if (!un.values.enabled) return;
          const i = Ac(e, t),
            o = t.id,
            a = i.frames[o];
          (a.state || Wl) < Yl && ((a.state = Yl), yc(e, t, n, r));
        }
      ),
        hi.on("commited", ({ tabId: e, sender: t, url: n }) => {
          if (
            !un.values.enabled ||
            !["https:", "http:", "file:"].some((e) => n.startsWith(e))
          )
            return;
          const r = Ac(e, t),
            s = t.id,
            i = r.frames[s];
          (i.state || Wl) >= Xl || (i.state = Xl);
        }),
        hi.on(
          "loading",
          ({ tabId: e, sender: t, url: n, incognito: r, cookieStoreId: s }) => {
            if (
              !un.values.enabled ||
              !["https:", "http:", "file:"].some((e) => n.startsWith(e))
            )
              return;
            const i = Ac(e, t),
              o = t.id,
              a = i.frames[o];
            (a.cookieStoreId = a.cookieStoreId || s),
              (a.isIncognito = a.isIncognito || r),
              (a.state || Wl) >= Kl || (a.state = Kl);
          }
        );
      const kc = (e, t, n, r, s) => {
        if (!un.values.enabled) return;
        const i = Ac(e, t),
          o = t.id,
          a = i.frames[o],
          l = Fn(n),
          c = uc(e);
        let u = c.scripts[l];
        if (
          !u &&
          (w.log(
            "tv: lazy init @ events.prepare(" + e + ", " + o + ", " + n + ")"
          ),
          (u = c.scripts[l] = dc(e, t, l, r)),
          !u)
        )
          return void w.warn("tv: no script run info for tab " + e + " @ " + l);
        const A = a.state;
        (a.state = $l),
          A != $l &&
            (function (e, t, n, r) {
              const s = Object.entries(n);
              if (s.length)
                for (const [n, i] of s) lc(e, t, r, { uuid: n, name: i });
              else cc(e, t, r);
            })(e, t, u.script_map, l);
        const { contexters: d, nonce: h } = u,
          p = s
            ? (r) => {
                bc(e, t, n);
                const i =
                  r || d.length
                    ? { runners: r, contexters: d, nonce: h }
                    : void 0;
                s(i);
              }
            : void 0,
          f = (function (e, t, n, r, s) {
            const i = [];
            for (const e of r) i.push(Na.bundle(e, n));
            let o;
            return (
              R.when(i)
                .then((e) => e.filter((e) => e))
                .always((e) => {
                  s ? s(e) : (o = e);
                }),
              o
            );
          })(0, 0, l, u.runners, p);
        return f || d.length
          ? { runners: f, contexters: d, nonce: h }
          : u.runners.length || d.length
          ? { count: u.runners.length || d.length, nonce: h }
          : void 0;
      };
      hi.on("complete", ({ tabId: e, sender: t, url: n }) => {
        if (
          !un.values.enabled ||
          !["https:", "http:", "file:"].some((e) => n.startsWith(e))
        )
          return;
        const r = Ac(e, t),
          s = t.id,
          i = r.frames[s];
        i.state, (i.state = ec), Ad(t) && fc == e && hc(n, e);
      }),
        hi.on("unload", ({ tabId: e, sender: t }) => {
          Te.FAST_EXEC_SUPPORT && bc(e, t);
          const n = Ac(e, t),
            r = t.id;
          (n.frames[r].state = tc),
            ((e, t) => {
              cc(e, t);
            })(e, t),
            delete n.frames[r];
        }),
        hi.on("remove", ({ tabId: e }) => {
          const t = ic[e];
          Te.FAST_EXEC_SUPPORT &&
            t &&
            Object.values(t.frames).forEach((t) => {
              bc(e, t.sender);
            }),
            oc(e);
        });
      const Rc = () => {
          qe.lastError && qe.lastError;
        },
        xc = {
          init: () => {
            xc.setIcon();
            let e = un.values.appearance_badge_color || "#ee3131";
            var t;
            "#" !== e[0] && (e = "#" + e),
              (function (e) {
                if (ot.setBadgeBackgroundColor) ot.setBadgeBackgroundColor(e);
              })({ color: e }),
              (e = un.values.appearance_badge_text_color || "#ffffff"),
              "#" !== e[0] && (e = "#" + e),
              (t = { color: e }),
              ot.setBadgeTextColor && ot.setBadgeTextColor(t);
          },
          setIcon: (e) => {
            let t,
              n,
              r = !1;
            if (void 0 !== e) {
              const t = ((e) => ac(e).forbidden)(e);
              void 0 !== t && (r = t);
            }
            r
              ? ((t = "_forbidden"),
                (n = Dr.getMessage(
                  "At_least_one_part_of_this_page_is_listed_at_the_forbidden_pages_setting_"
                )))
              : (t = un.values.enabled && void 0 !== e ? "" : "_grey"),
              w.debug("badge: set icon " + t);
            const s = { path: ze.getURL("images/icon" + t + ".png") },
              i = { title: n || ze.manifest.name };
            void 0 !== e && ((s.tabId = e), (i.tabId = e));
            try {
              at(s, Rc), lt(i);
            } catch (e) {
              w.warn("bg: ERROR while setIcon! " + e.message);
            }
          },
          setBadge: (e) => {
            let t = 0;
            "off" == un.values.appearance_badges
              ? (t = 0)
              : "running" == un.values.appearance_badges
              ? e && (t = wc(e).running || 0)
              : "running_unique" == un.values.appearance_badges &&
                e &&
                (t = wc(e, !0).unique || 0);
            let n = t ? `${t}` : "";
            if (
              un.values.userscript_search_url &&
              "badge" == un.values.userscript_search_mode
            ) {
              const r = wc(e).searched || 0;
              if (r > 0) {
                let e = "";
                (e =
                  t > 999
                    ? ""
                    : t > 99 || `${n}+${r}`.length > 4
                    ? "+"
                    : `${r}`),
                  (n = `${n}+${e}`);
              }
            }
            w.debug("badge: set " + n),
              (function (e) {
                if (ot.setBadgeText) ot.setBadgeText(e);
              })({ text: n, tabId: e });
          },
        },
        Ec = xc,
        Sc = [],
        Cc = {},
        Mc = Ts("closeableTabs"),
        Ic = new Is(1);
      Ic.acquire()
        .then(async () => {
          const e = await Mc.list();
          await f.all(
            e.map(({ key: e }) =>
              gd(+e).then((t) => {
                t ? (Cc[+e] = !0) : Mc.delete(e);
              })
            )
          );
        })
        .always(() => Ic.release());
      const Gc =
          (ae
            ? parseInt(ae.getItem("inactive_tab_done_timeout") || "")
            : null) || 1e3,
        Uc = (e, ...t) => {
          k.late
            ? hi.emit("active", e)
            : X(() => {
                Uc(e, ...t);
              }, 100);
        },
        Zc = (e, t, n) => {
          if (!k.late)
            return void X(() => {
              Zc(e, t, n);
            }, 100);
          const r = n.pendingUrl || n.url;
          "auto" == un.values.scriptUrlDetection &&
            hd(r) &&
            vu.installFromUrl(r, {}, { silent_fail: !0 });
          const s = dd({ frameId: 0 }, { topframe: !0 });
          r
            ? "loading" == t.status
              ? hi.emit("loading", {
                  tabId: e,
                  sender: s,
                  url: r,
                  incognito: ud(n),
                  cookieStoreId: n.cookieStoreId,
                })
              : "complete" == t.status &&
                hi.emit("complete", { tabId: e, sender: s, url: r })
            : w.warn("tabUpdates: no tab url set! ", n),
            Sc.forEach((e) => {
              e({ reason: "updated", status: t.status }, n);
            });
        },
        Tc = (e) => {
          if ((hi.emit("remove", { tabId: e }), Cc[e]))
            return Ic.acquire()
              .then(async () => {
                delete Cc[e], await Mc.delete(e.toString());
              })
              .always(() => Ic.release());
          Sc.forEach((t) => {
            t({ reason: "removed" }, { id: e });
          });
        },
        Bc = (e, t) => {
          Tc(t),
            Ec.setIcon(e),
            Ec.setBadge(e),
            Sc.forEach((t) => {
              t({ reason: "replaced" }, { id: e });
            });
        },
        Oc = (e) => {
          if (!k.late)
            return void X(() => {
              Oc(e);
            }, 100);
          const { url: t, tabId: n } = e,
            r = dd(e, { topframe: !0 });
          hi.emit("commited", { tabId: n, sender: r, url: t }),
            Ad(r) &&
              Sc.forEach((e) => {
                e({ reason: "commited" }, { url: t, id: n });
              });
        },
        Fc = (e) => {
          const { tabId: t } = e,
            n = dd(e);
          n && Ad(n) && hi.emit("reset", { tabId: t, early: !0 });
        },
        Dc = (e) =>
          Ic.acquire()
            .then(async () => {
              Cc[e] || ((Cc[e] = !0), await Mc.set(e.toString(), !0));
            })
            .always(() => Ic.release()),
        jc = (e) =>
          Ic.acquire()
            .then(() => !!Cc[e])
            .always(() => Ic.release()),
        Pc = {
          init: () => {
            Qe(Zc),
              Xe(Tc),
              We(Bc),
              He(Uc),
              st &&
                ((function (e) {
                  if (Se.webNavigation.onCommitted)
                    Se.webNavigation.onCommitted.addListener(e);
                })(Oc),
                (function (e, t) {
                  if (Se.webNavigation.onBeforeNavigate)
                    Se.webNavigation.onBeforeNavigate.addListener(e, t);
                })(Fc, {
                  url: [
                    {
                      schemes: ["http", "https"],
                    },
                  ],
                }));
          },
          openAndWatch: function (e, t) {
            let n, r;
            const {
                filter: s,
                url: i,
                active: o,
                index: a,
                parent: l,
                openerTabId: c,
                windowId: u,
                incognito: A,
              } = e,
              d = (e, i) => {
                ((void 0 !== n && i.id === n) ||
                  (s && i.url && s.exec(i.url))) &&
                  (["updated", "commited"].includes(e.reason)
                    ? t(i)
                    : "removed" == e.reason &&
                      (r && (L(r), (r = void 0)), Pc.removeListener(d), t()));
              };
            return (
              Ye(
                {
                  url: i,
                  active: o,
                  index: a,
                  parent: l,
                  openerTabId: c,
                  windowId: u,
                  incognito: A,
                },
                (s) => {
                  s
                    ? ((n = s.id),
                      !1 === e.active &&
                        (r = X(() => {
                          (r = void 0), Je(s.id, { active: !0 }, () => null);
                        }, Gc)),
                      t(s))
                    : w.warn("tab.create failed", e, s);
                }
              ),
              Pc.addListener(d),
              {
                cancel: () => {
                  Pc.removeListener(d),
                    void 0 !== n &&
                      Ke(n, () => {
                        const e = qe.lastError;
                        e ? w.warn("tab.close", e.message) : (n = void 0);
                      });
                },
              }
            );
          },
          addListener: (e) => {
            Sc.push(e);
          },
          removeListener: (e) => {
            let t;
            Sc && (t = Sc.indexOf(e)) > -1 && Sc.splice(t, 1);
          },
        },
        Lc = Pc;
      let Nc = 0,
        Vc = [],
        zc = !1;
      const qc = (() => {
        const e = (e) => {
            const t = e.type,
              n = e.id,
              r = ".meta.json",
              s = ".user.js";
            let i, o;
            const a = (e) => {
                let t;
                return R.Pledge()
                  .then(() => {
                    if (!o) return (t = !0), l();
                  })
                  .then(() => {
                    if (o && void 0 === o[e] && !t) return l();
                  })
                  .then(() =>
                    o
                      ? ((o[e] = o[e] || void 0), o[e])
                      : (w.warn("si: unable to list remote list!"), R.Breach())
                  );
              },
              l = (e) =>
                i.list(e).then((e) => {
                  o = {};
                  const t = {},
                    n = {};
                  let i, a;
                  const l = Date.now();
                  return (
                    e.map((e) => {
                      const { name: c, modified: u } = e;
                      if (!o) return;
                      o[c] = e;
                      const A = new RegExp(r + "$"),
                        d = new RegExp(s + "$");
                      if (u > l) w.log("si: ignore future list item", l, e);
                      else if ((i = !!c.match(A)) || (a = !!c.match(d))) {
                        let r;
                        if (i) {
                          r = c.replace(A, "");
                          const n = u,
                            { precision: s } = e;
                          t[r] = {
                            uuid: r,
                            options: {},
                            url: void 0,
                            precision: s,
                            lastModified: n,
                          };
                        } else a && ((r = c.replace(d, "")), (n[r] = !!e));
                      }
                    }),
                    Object.keys(t)
                      .map((e) => {
                        const r = t[e];
                        return r && (r.sourceAvailable = n[e]), r;
                      })
                      .filter((e) => e)
                  );
                });
            let c;
            const u = {
              init: (e) => {
                const o = (c = Xt());
                return (
                  (i = ho[t]({ ...e, path: "sync" })),
                  R.Pledge().then(
                    () => (
                      i.changes.listen().progress((e) => {
                        o === c &&
                          ((e, t) => {
                            if (t != Nc) return;
                            const n = e.name;
                            w.log("si: cloud file changed", n, e),
                              (n.endsWith(r) || n.endsWith(s)) &&
                                Vc.forEach((e) => {
                                  e(n);
                                });
                          })(e, n);
                      }),
                      !0
                    )
                  )
                );
              },
              disable: () => {
                var e;
                return (
                  (c = void 0),
                  (null === (e = null == i ? void 0 : i.changes) || void 0 === e
                    ? void 0
                    : e.stop()) || R.Pledge()
                );
              },
              list: l,
              setSource: (e, t) => {
                const n = e + s;
                return a(n).then((e) => {
                  let r;
                  return R.Pledge(!1)
                    .then(() => {
                      if (e && i.compare) return i.compare(e, t);
                    })
                    .then((s) =>
                      s
                        ? (w.log(
                            "si: remote source data matches, skip upload of",
                            n
                          ),
                          R.Pledge())
                        : ((r = new Blob([t], { type: "text/plain" })),
                          o && delete o[n],
                          i.put(e || n, r))
                    );
                });
              },
              getSource: (e, t) => {
                const n = e + s;
                return a(n).then((r) =>
                  r
                    ? R.Pledge(!1)
                        .then(() => {
                          if (t && i.compare) return i.compare(r, t);
                        })
                        .then((e) =>
                          e
                            ? (w.log(
                                "si: remote source data matches, skip download of",
                                n
                              ),
                              R.Pledge(t))
                            : i.get(r).then((e) => be(e, "utf-8"))
                        )
                    : (w.warn("si: list cache does not contain this UUID", e),
                      R.Breach())
                );
              },
              getMeta: (e) =>
                a(e + r).then((t) =>
                  t
                    ? i
                        .get(t)
                        .then((e) => be(e, "utf-8"))
                        .then((n) => {
                          let r;
                          if (
                            (r = ((e) => {
                              let t;
                              try {
                                t = JSON.parse(e);
                              } catch (e) {}
                              if (t && t.uuid) return t;
                              w.log(
                                "si: unable to parse extended info of " + void 0
                              );
                            })(n)) &&
                            (r.uuid = e)
                          ) {
                            let {
                              options: n,
                              url: s,
                              precision: i,
                              lastModified: o,
                            } = r;
                            return (
                              (o = t.modified || o || 0),
                              (i = t.precision || i),
                              (n = n || {}),
                              {
                                ...r,
                                uuid: e,
                                url: s,
                                options: n,
                                precision: i,
                                lastModified: o,
                              }
                            );
                          }
                        })
                    : R.Breach()
                ),
              setMeta: (e, t) => {
                const n = new Blob([JSON.stringify(e)], { type: "text/plain" }),
                  s = e.uuid + r;
                return a(s).then((e) => i.put(e || s, n, t));
              },
              remove: (e) => {
                const t = e.uuid + r;
                e.options.removed = Date.now();
                const n = new Blob([JSON.stringify(e)], { type: "text/plain" });
                return i.put(t, n).then(() => {
                  const t = e.uuid + s;
                  return a(t).then((e) => {
                    if (e) return o && delete o[t], i.delete(e);
                  });
                });
              },
              reset: () =>
                i
                  .list(!0)
                  .then((e) =>
                    e.filter((e) => {
                      const t = new RegExp(r + "$"),
                        n = new RegExp(s + "$");
                      return e.name.match(t) || e.name.match(n);
                    })
                  )
                  .then((e) => {
                    const t = [];
                    return (
                      e.forEach((e) => {
                        t.push(
                          (() => {
                            const t = R();
                            return (
                              i.delete(e).always(() => {
                                t.resolve();
                              }),
                              t.promise()
                            );
                          })()
                        );
                      }),
                      R.when(t).always(() => {
                        o = void 0;
                      })
                    );
                  })
                  .then(() => {}),
              getRemoteUrl: function (e) {
                if (i.getRemoteUrl) return i.getRemoteUrl(e.uuid + s);
              },
              getRemoteDomains: function () {
                if (i.getRemoteDomains) return i.getRemoteDomains();
              },
            };
            return u;
          },
          t = e({ type: "drive", id: oa.eGDRIVE }),
          n = e({ type: "dropbox", id: oa.eDROPBOX }),
          r = e({ type: "onedrive", id: oa.eONEDRIVE }),
          s = e({ type: "webdav", id: oa.eWEBDAV }),
          i = e({ type: "yandex", id: oa.eYANDEX }),
          o = (() => {
            let e,
              t = !1;
            const n = (t, n) => {
                Nc == oa.eCHROMESYNC &&
                  "sync" == n &&
                  R.Pledge().then(() => {
                    const r = new RegExp(e + "$");
                    t &&
                      Object.keys(t).forEach((e) => {
                        const s = t[e],
                          o = s.newValue;
                        if (
                          (w.log(
                            'si: storage key "%s" in namespace "%s" changed. Old value was "%s", new value is "%s".',
                            e,
                            n,
                            s.oldValue,
                            s.newValue
                          ),
                          -1 != e.search(r))
                        )
                          for (let t = 0; t < Vc.length; t++)
                            if (l[e]);
                            else {
                              const n = i(o, e);
                              n && Vc[t](e, n);
                            }
                      });
                  });
              },
              r = (e) => {
                const t = R();
                let n = [];
                return (
                  e
                    ? s()
                        .done((r) => {
                          (n = r.filter((t) => t.item.uuid == e)), t.resolve(n);
                        })
                        .fail((e) => {
                          t.reject(e);
                        })
                    : t.resolve(n),
                  t.promise()
                );
              },
              s = () =>
                Qc(() => {
                  const t = R(),
                    n = new RegExp(e + "$");
                  return (
                    ut.sync.get(null, (e) => {
                      const r = [];
                      e &&
                        Object.entries(e).forEach(([e, t]) => {
                          if (-1 == e.search(n)) return;
                          const s = i(t, e);
                          s && r.push({ key: e, item: s });
                        }),
                        t.resolve(r);
                    }),
                    t.promise()
                  );
                }),
              i = (e, t) => {
                let n;
                try {
                  n = JSON.parse(e);
                } catch (e) {}
                if (n && (n.url || n.options)) return n;
                w.log("si: unable to parse extended info of " + t);
              },
              o = (e) =>
                e.then((e) => {
                  const t = {};
                  if (
                    (e = e.filter((e) => {
                      if (!t[e.key]) return (t[e.key] = !0), !0;
                    })).length > 1
                  ) {
                    const t = R(),
                      n = [],
                      r = e.pop();
                    return (
                      e.forEach((e) => {
                        n.push(c(e.key));
                      }),
                      R.when(n).done(() => {
                        t.resolve(r);
                      }),
                      t.promise()
                    );
                  }
                  return R.Pledge(e[0]);
                });
            let a,
              l = {};
            const c = (e) => {
                const t = R();
                return (
                  ut.sync.remove(e, () => {
                    const e = qe.lastError;
                    e ? t.reject(e) : t.resolve();
                  }),
                  t.promise()
                );
              },
              u = () => {
                const e = R();
                return (
                  ut.sync.set(l, () => {
                    const t = qe.lastError;
                    t ? e.reject(t) : ((l = {}), e.resolve());
                  }),
                  e.promise()
                );
              },
              A = () =>
                R.Pledge()
                  .then(() => s())
                  .then((t) => {
                    const n = new RegExp(e + "$"),
                      r = [];
                    return (
                      t.forEach((e) => {
                        const t = e.key,
                          s = e.item,
                          o = t.replace(n, "");
                        let a;
                        if (((a = l[t] ? i(l[t], t) : s), !a)) return;
                        const c = a.options || {};
                        r.push({
                          uuid: c.removed ? o : a.uuid,
                          lastModified: c.removed || a.lastModified,
                          url: a.url,
                          options: c,
                        });
                      }),
                      R.Pledge(r)
                    );
                  }),
              d = {
                init: function () {
                  let r = !0;
                  if (!t)
                    try {
                      ut.onChanged.addListener(n), (t = !0);
                    } catch (e) {
                      w.warn(
                        "si: error registering sync callback: " + e.message
                      ),
                        (r = !1);
                    }
                  return (e = "@v2"), R.Pledge(r);
                },
                disable: () => R.Pledge(),
                list: A,
                setMeta: (t, n) => {
                  const s = R();
                  return (
                    o(r(t.uuid)).done((r) => {
                      let i;
                      i = r ? r.key : t.uuid + e;
                      const { uuid: o, options: c, url: A } = t,
                        d = (null == n ? void 0 : n.lastModified) || 0,
                        h = {
                          ...((null == r ? void 0 : r.item) || {}),
                          url: A,
                          options: c || {},
                          uuid: o,
                          lastModified: d,
                        };
                      (l[i] = JSON.stringify(h)),
                        a && L(a),
                        (a = X(u, 3e3)),
                        s.resolve();
                    }),
                    s.promise()
                  );
                },
                getMeta: (e) =>
                  A().then((t) => {
                    let n;
                    return (
                      t.some((t) => {
                        if (t.uuid == e) return (n = t), !0;
                      }),
                      n
                    );
                  }),
                remove: (t) => {
                  const n = R();
                  return (
                    o(r(t.uuid)).done((r) => {
                      let s;
                      s = r ? r.key : t.uuid + e;
                      const {
                          url: i,
                          options: o,
                          uuid: c,
                          lastModified: A,
                        } = t,
                        d = {
                          ...((null == r ? void 0 : r.item) || {}),
                          url: i,
                          options: o || {},
                          uuid: c,
                          lastModified: A,
                        };
                      (d.options.removed = Date.now()),
                        (l[s] = JSON.stringify(d)),
                        a && (L(a), (a = void 0)),
                        (a = X(u, 3e3)),
                        n.resolve();
                    }),
                    n.promise()
                  );
                },
                reset: () =>
                  Qc(() => {
                    const e = R();
                    return (
                      ut.sync.clear(() => {
                        (l = {}), e.resolve();
                      }),
                      e.promise()
                    );
                  }),
              };
            return d;
          })();
        return {
          [oa.eCHROMESYNC]: ut.sync.supported ? o : void 0,
          [oa.eGDRIVE]: t,
          [oa.eDROPBOX]: n,
          [oa.eONEDRIVE]: r,
          [oa.eWEBDAV]: s,
          [oa.eYANDEX]: i,
        };
      })();
      let Hc;
      const Qc = (e, t) => {
          const n = R();
          let r = void 0 !== t ? t : 3;
          const s = () => {
            if (zc) X(s, 500);
            else {
              zc = !0;
              try {
                e()
                  .always(() => {
                    zc = !1;
                  })
                  .done((e) => n.resolve(e))
                  .fail(() => {
                    --r > 0
                      ? (w.log("si: some retries left, wait for 60000 ms"),
                        X(s, 6e4))
                      : (w.warn(
                          "si: no retries left, skipping this sync request!"
                        ),
                        n.reject("no retries left"));
                  });
              } catch (e) {
                w.warn(e),
                  (zc = !1),
                  n.reject(
                    ("string" == typeof e ? e : e.message) || "internal error"
                  );
              }
            }
          };
          return s(), n.promise();
        },
        Wc = {
          init: (e, t) => (
            (Vc = []),
            (Nc = e),
            (Hc = qc[e]),
            (null == Hc ? void 0 : Hc.init(t)) || R.Breach()
          ),
          disable: (e) => {
            const t = qc[e];
            return (t && t.disable()) || R.Breach();
          },
          addChangeListener: (e) => {
            Vc.push(e);
          },
          getRemoteUrl: (e) => {
            if (Hc && Hc.getRemoteUrl) return Hc.getRemoteUrl(e);
          },
          getRemoteDomains: () => {
            if (Hc && Hc.getRemoteDomains) return Hc.getRemoteDomains();
          },
          caps: (() => {
            const e = {};
            return (
              Object.defineProperties(e, {
                specialMeta: {
                  get: function () {
                    return Hc && !!Hc.getMeta;
                  },
                  enumerable: !0,
                },
                syncsSource: {
                  get: function () {
                    return Hc && !!Hc.getSource;
                  },
                  enumerable: !0,
                },
              }),
              e
            );
          })(),
          types: oa,
          list: () => (null == Hc ? void 0 : Hc.list()) || R.Pledge([]),
          setMeta: (e, t) =>
            (null == Hc ? void 0 : Hc.setMeta(e, t)) || R.Pledge(),
          getMeta: (e) => (null == Hc ? void 0 : Hc.getMeta(e)) || R.Pledge(),
          setSource: (e, t) =>
            (null == Hc ? void 0 : Hc.setSource)
              ? Hc.setSource(e, t)
              : R.Pledge(),
          getSource: (e, t) =>
            (null == Hc ? void 0 : Hc.getSource)
              ? Hc.getSource(e, t)
              : R.Pledge(),
          reset: () => (null == Hc ? void 0 : Hc.reset()) || R.Pledge(),
          remove: (e) => (null == Hc ? void 0 : Hc.remove(e)) || R.Pledge(),
        },
        Xc = (e) => {
          const {
              uuid: t,
              name: n,
              downloadURL: r,
              fileURL: s,
              lastModified: i,
              options: o,
            } = e,
            a = r ? r.split("#")[0] : void 0,
            l = s ? s.split("#")[0] : void 0,
            c = [l, a].filter((e) => {
              const t = e ? Zn(e) : void 0;
              if (!t || "file:" !== t.protocol) return e;
            })[0],
            { comment: u } = o;
          return {
            uuid: t,
            name: n,
            options: { comment: u || void 0 },
            durl: a,
            furl: l,
            url: c,
            lastModified: i || e.lastUpdated,
          };
        },
        Yc = (e) => (
          ((e, t, n) => {
            (ro = (e) => {
              let t = R();
              const n = Lc.openAndWatch(
                {
                  url: e.url,
                  filter: e.filter ? new RegExp(e.filter) : void 0,
                  active: !1,
                },
                (e) => {
                  e ? t && t.notify(e) : t && (t.resolve(), (t = void 0));
                }
              );
              return {
                promise: t.promise(),
                close: function () {
                  n.cancel();
                },
              };
            }),
              (po = n),
              (oo = (e) => xl("cloud", e, go));
          })(0, 0, e),
          Wc
        ),
        Jc = Wc.getRemoteDomains,
        Kc = Wc.getRemoteUrl,
        $c = "PageFilter",
        eu = {
          init: () => {
            const e = () => {
              kd.remove($c);
            };
            un.addChangeListener("forbiddenPages", e),
              un.addChangeListener("page_whitelist", e),
              un.addChangeListener("page_filter_mode", e);
          },
          isAllowed: (e) => {
            let t = !1,
              n = !1;
            const r = (Jc() || []).map((e) => `*://${e}/*`),
              s = un.values.forbiddenPages.concat(r),
              i = s.length > 0,
              o = un.values.page_whitelist.length > 0;
            switch (un.values.page_filter_mode) {
              case "black":
                n = i;
                break;
              case "off":
                break;
              case "white":
                t = o;
                break;
              default:
                (t = o), (n = i);
            }
            let a = kd.get($c);
            return (
              a ||
                ((a = wd({
                  inc: t ? un.values.page_whitelist : void 0,
                  exc: n ? s : void 0,
                })),
                kd.set($c, a)),
              (!n && !t) || bd(e, a)
            );
          },
        };
      let tu, nu;
      const ru = {},
        su = (e) => e && e.includes("*"),
        iu = () => {
          const e = (e) => {
            for (let t = 0; t < au.length; t++)
              if (au[t].tabId === e) return au.splice(t, 1)[0];
            return au.pop();
          };
          let t;
          md().then((n) => {
            for (; !ou && (t = e(n.id)); ) t.fn();
          });
        };
      let ou,
        au = [];
      const lu = (e, t, n, r) => {
          const s = ((e, t) => {
              const n = (e) =>
                e
                  ? e
                      .map((e) => {
                        let n = e;
                        if (n.match(/^'?self'?$/)) {
                          const e = Zn(t.url);
                          n = (null == e ? void 0 : e.hostname) || null;
                        } else if ("'none'" == n) n = "none";
                        else {
                          if (["none", "localhost", "*"].includes(n)) return n;
                          if (In(n)) return n;
                          if (0 === n.indexOf(".")) return null;
                          if (1 === (n.match(/\./g) || []).length && Gn(n))
                            return null;
                        }
                        return n;
                      })
                      .filter((e) => e)
                  : [];
              return {
                connects:
                  e.options.override.merge_connects &&
                  "paranoid" != un.values.connect_mode
                    ? n(e.connects)
                    : [],
                userconnects: n(e.options.override.use_connects),
                blockers: n(e.options.override.use_blockers),
              };
            })(e, t),
            i = ((e) => {
              const t = R();
              return (
                eu.isAllowed(e)
                  ? t.resolve({ allowed: !0 })
                  : t.resolve({ allowed: !1 }),
                t.promise()
              );
            })(n)
              .then((r) => {
                if (!0 !== r.allowed) return R.Breach("URL is blacklisted");
                let i, o;
                return (i = Zn(n)) &&
                  i.origin &&
                  (o = Zn(t.url)) &&
                  o.origin &&
                  i.origin === o.origin
                  ? R.Pledge({ permitted: !0 })
                  : ((e, t, n) => {
                      const r = R(),
                        s = () => {
                          r.resolve({ permitted: !0 });
                        },
                        i = (e) => {
                          r.resolve({ permitted: !1, reason: e });
                        },
                        o = () => {
                          r.resolve({ unknown: !0 });
                        };
                      let a, l;
                      const c = (e) => (su(e) ? s : null),
                        u = (e, t) => {
                          let n = null;
                          const r = In(e);
                          return (
                            t.every(({ a: t, blocker: o }) => {
                              if (!t) return !0;
                              for (const a of t)
                                if (
                                  a &&
                                  (r || In(a)
                                    ? a === e
                                    : -1 !=
                                      e.search(
                                        new RegExp("(^|.+\\.)" + Pt(a) + "$")
                                      ))
                                )
                                  return (n = o ? i : s), !1;
                              return !0;
                            }),
                            n
                          );
                        };
                      return (
                        "off" == un.values.connect_mode ||
                        n.startsWith("data:") ||
                        n.startsWith("blob:")
                          ? s()
                          : (a = Zn(n)) && a.hostname
                          ? (l = u(a.hostname, [{ a: ru[e.uuid] }])) ||
                            (l = c(ru[e.uuid]))
                            ? l()
                            : 0 === t.connects.length &&
                              0 === t.userconnects.length &&
                              0 === t.blockers.length
                            ? "casual" == un.values.connect_mode
                              ? s()
                              : "strict" == un.values.connect_mode
                              ? i("No @connects given, but strict mode enabled")
                              : o()
                            : t.connects.includes("none")
                            ? i("None value found")
                            : (("casual" == un.values.connect_mode &&
                                !su(t.blockers) &&
                                (l = c(t.connects))) ||
                                (l = c(t.userconnects)) ||
                                (l =
                                  u(a.hostname, [
                                    { a: t.blockers, blocker: !0 },
                                    { a: t.connects },
                                    { a: t.userconnects },
                                  ]) || o),
                              l())
                          : i("URL can not be parsed"),
                        r.promise()
                      );
                    })(e, s, n);
              })
              .then((i) => {
                var o;
                if (!1 === i.permitted)
                  return R.Breach(
                    "URL is not permitted" + (i.reason ? ": " + i.reason : "")
                  );
                if (!0 === i.permitted) return R.Pledge();
                if (0 === s.connects.length || su(s.connects)) {
                  if (["ask", "paranoid"].includes(un.values.connect_mode)) {
                    if (su(s.blockers))
                      return R.Breach(
                        "URL was permanently blocked by the user"
                      );
                    if (ou) {
                      w.log(
                        'cor: queuing access permission check from "' +
                          e.name +
                          '" to',
                        n,
                        t
                      );
                      const s = R();
                      return (
                        au.push({
                          tabId:
                            null === (o = null == t ? void 0 : t.tab) ||
                            void 0 === o
                              ? void 0
                              : o.id,
                          fn: () => {
                            s.consume(lu.apply(void 0, [e, t, n, r]));
                          },
                        }),
                        s.promise()
                      );
                    }
                    return ((e, t, n, r, s) => {
                      const i = R(),
                        o = () => {
                          i.resolve({ approved: !0 });
                        },
                        a = () => {
                          i.resolve({ forbidden: !0 });
                        };
                      w.log(
                        'cor: "' +
                          e.name +
                          '" is asking for permission to access',
                        r,
                        t
                      );
                      const l = Zn(r);
                      if (l && l.hostname) {
                        const i = ((e) => {
                            if (In(e)) return;
                            const t = e.split(".");
                            if (t.length < 3) return e;
                            const n = Gn(t.slice(-2).join(".")) ? -3 : -2;
                            return t.slice(n).join(".");
                          })(l.hostname),
                          c = t.tab ? t.tab.id : null;
                        (ou = !0),
                          md()
                            .then((o) =>
                              bi.askForConnect({
                                src_url: t.url,
                                hostname: l.hostname,
                                domain: i,
                                all_domains: su(n.connects),
                                tabid: c,
                                active: c === o.id,
                                timeout: s,
                                url: r,
                                settings_url:
                                  ze.getURL("options.html") +
                                  "#nav=" +
                                  e.uuid +
                                  "+settings",
                                connect_url:
                                  "https://www.tampermonkey.net/documentation.php#_connect",
                                script: {
                                  name: Dr.getTranslation(e, "name"),
                                  uuid: e.uuid,
                                  icon: e.icon64 || e.icon || gs("unknown"),
                                },
                              })
                            )
                            .done(({ message: t }) => {
                              let n;
                              if (!t)
                                return (
                                  w.log("cor: unexpected response", t), void a()
                                );
                              const r = t.whole_domain ? i : l.hostname;
                              if (!r)
                                return (
                                  w.log("cor: internal error", t, i), void a()
                                );
                              t.allow
                                ? t.once
                                  ? (w.log(
                                      'cor: allowing "' +
                                        e.name +
                                        '" to access',
                                      r,
                                      "once"
                                    ),
                                    o())
                                  : t.temporary
                                  ? (w.log(
                                      'cor: allowing "' +
                                        e.name +
                                        '" to access',
                                      r,
                                      "temporarily"
                                    ),
                                    void 0 === ru[e.uuid] && (ru[e.uuid] = []),
                                    ru[e.uuid].includes(r) ||
                                      ru[e.uuid].push(r),
                                    o())
                                  : ((n = o),
                                    t.all_domains
                                      ? (w.log(
                                          'cor: allowing "' +
                                            e.name +
                                            '" to access all domains always'
                                        ),
                                        e.options.override.use_connects.push(
                                          "*"
                                        ))
                                      : (w.log(
                                          'cor: allowing "' +
                                            e.name +
                                            '" to access',
                                          r,
                                          "always"
                                        ),
                                        e.options.override.use_connects.push(r),
                                        (n = o)))
                                : t.once || t.aborted
                                ? (w.log(
                                    'cor: denying "' + e.name + '" to access',
                                    r,
                                    "once"
                                  ),
                                  a())
                                : (e.options.override.use_blockers ||
                                    (e.options.override.use_blockers = []),
                                  (n = a),
                                  t.all_domains
                                    ? (w.log(
                                        'cor: denying "' +
                                          e.name +
                                          '" to access any domains (additional) domain'
                                      ),
                                      e.options.override.use_blockers.push("*"))
                                    : (w.log(
                                        'cor: denying "' +
                                          e.name +
                                          '" to access',
                                        r,
                                        "always"
                                      ),
                                      e.options.override.use_blockers.push(r))),
                                n && tu(e.uuid, e, !1).always(n);
                            })
                            .fail(a)
                            .always(() => {
                              (ou = !1), au.length && X(iu, 1);
                            });
                      } else a();
                      return i.promise();
                    })(e, t, s, n, r).then((e) =>
                      !0 === e.approved
                        ? R.Pledge()
                        : R.Breach("Request was blocked by the user")
                    );
                  }
                  return R.Breach();
                }
                return R.Breach(
                  "This domain is not a part of the @connect list"
                );
              });
          return i;
        },
        cu = {
          getSessionConnects: (e) => ru[e] || [],
          setSessionConnects: (e, t) => {
            ru[e] = t || [];
          },
          purgeAppeals: (e) => {
            au = au.filter((t) => t.tabId !== e);
          },
          exec: (e, t, n, r, s) => {
            let i,
              o,
              a,
              l,
              c,
              u,
              A,
              d = e.url;
            const h = [],
              p = Math.max(Math.min(e.timeout || 0, 6e4), 2e4),
              f = () => {
                let e;
                for (; !A && (e = h.shift()); ) e();
              },
              m = (t, n) => {
                const r =
                    'Refused to connect to "' +
                    (n || e.url) +
                    '": ' +
                    (t || "Blocked by @connect CORS check"),
                  i = VA(r);
                ["onerror", "ondone"].forEach((e) => {
                  const t = s[e];
                  t && t({ response: i, exception: r });
                });
              };
            if (
              n &&
              n.url &&
              n.tab &&
              e.url &&
              t &&
              (o = nu(t)) &&
              ({ script: a, cond: l } = o) &&
              a &&
              l &&
              !a.deleted
            )
              return (
                lu(a, n, e.url, p)
                  .done(() => {
                    if (u) return;
                    const t = {};
                    for (const [e, r] of Object.entries(s)) {
                      if (!r) continue;
                      const s = (e, ...t) => {
                        if (c) return;
                        if (A) return void h.push(() => s(e, ...t));
                        const o = e;
                        (o && o.finalUrl && d !== o.finalUrl
                          ? ((A = !0),
                            lu(a, n, o.finalUrl, p)
                              .fail(() => {
                                u ||
                                  c ||
                                  (i && i.abort(),
                                  (c = !0),
                                  m(
                                    "Request was redirected to a not whitelisted URL",
                                    o.finalUrl
                                  ),
                                  w.warn(
                                    "cor: request to",
                                    d,
                                    "was redirect to a not whitelisted URL",
                                    o.finalUrl
                                  ));
                              })
                              .always(() => {
                                (d = o.finalUrl), (A = !1), h.length && X(f, 1);
                              }))
                          : R.Pledge()
                        ).always(() => {
                          c || r({ response: o });
                        });
                      };
                      t[e] = s;
                    }
                    i = cd.external(e, t, r);
                  })
                  .fail((e) => {
                    u || (m(e), w.warn("cor: access to", d, "was denied"));
                  })
                  .always(() => {
                    if (u) {
                      const e = {
                        response: VA("aborted"),
                        exception: "Aborted by user",
                      };
                      s.onabort && s.onabort(e), s.ondone && s.ondone(e);
                    }
                  }),
                {
                  abort: () => {
                    i ? i.abort() : (u = !0);
                  },
                }
              );
            m();
          },
        },
        uu = cu,
        Au = (e) => (e.sort((e, t) => e.position - t.position), e),
        du = (e) => {
          let t;
          void 0 === e.ask && (e.ask = !0),
            e.url || (e.url = ""),
            "" === e.force_url && delete e.force_url;
          const n = { errors: [], info: [], warnings: [], flags: {} },
            r = R(),
            s = Date.now(),
            i = e.save && !e.ask && un.values.editor_easySave;
          let o;
          const a = ts(e.src) || void 0;
          if (!a || !a.name || null == a.version)
            return (
              n.errors.push(Dr.getMessage("Invalid_UserScript__Sry_") + "\n\n"),
              e.name &&
                n.errors.push(
                  Dr.getMessage("Script_name_0name0", e.name) + "\n\n"
                ),
              e.url &&
                n.errors.push(Dr.getMessage("Downloaded_from_0url0", e.url)),
              w.warn("scriptman: invalid userscript", n, a),
              R.Breach({ messages: n })
            );
          const {
            antifeatures: l,
            connects: c,
            name: u,
            namespace: A,
            textContent: d,
            version: h,
          } = a;
          let p,
            f,
            m,
            {
              downloadURL: g,
              enabled: v,
              excludes: _,
              fileURL: b,
              includes: y,
              lastModified: k,
              matches: x,
              options: E,
              sync: S,
              position: C,
              uuid: M,
              updateURL: I,
              system: G,
            } = a;
          return (
            R.Pledge()
              .then(() => {
                let n = e.uuid;
                if ((e.replace && !n && (n = Cd.getUidsByName(u, A)[0]), n)) {
                  const e = Cd.getByUid(n);
                  e.cond && e.script && (t = e.script);
                } else if (M) n = M;
                else {
                  if (!e.replace)
                    return (
                      w.warn(
                        "scriptman: neither UUID, @uuid nor replace option set"
                      ),
                      R.Breach()
                    );
                  n = Xt();
                }
                return n &&
                  "" ===
                    n.replace(
                      /[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}/,
                      ""
                    )
                  ? ((M = n), R.Pledge(M))
                  : (w.warn("scriptman: invalid UUID", n), R.Breach());
              })
              .then(() => {
                if (!e.clean && !e.defaultscript && t && t.system)
                  return R.Breach();
              })
              .then(() => {
                if ((e.clean && e.name && e.name != u) || -1 != u.indexOf("\n"))
                  return (
                    n.errors.push(
                      Dr.getMessage("Invalid_UserScript_name__Sry_")
                    ),
                    R.Breach()
                  );
              })
              .then(() => {
                if (t) {
                  if (
                    (t.name != u && (n.flags.renamed = !0),
                    e.internal ||
                      t.evilness != Wi.SEVERITY_FOISTED_SCRIPT ||
                      (n.warnings.push(
                        Dr.getMessage(
                          "This_is_a_possibly_foisted_script_and_a_modification_will_enable_it_"
                        )
                      ),
                      (n.flags.forceAsk = !0)),
                    t.lastModified &&
                      void 0 !== e.lastModTime &&
                      t.lastModified !== e.lastModTime)
                  ) {
                    let e = Dr.getMessage("some_secs");
                    try {
                      const n = Math.max(
                        1,
                        Math.floor((s - t.lastModified) / 1e3)
                      );
                      isNaN(n) || (e = n);
                    } catch (e) {}
                    n.warnings.push(
                      Dr.getMessage(
                        "CONFLICT__This_script_was_modified_0t0_seconds_ago_",
                        e
                      )
                    ),
                      (n.flags.forceAsk = !0);
                  }
                  h == t.version &&
                    (e.save
                      ? (n.flags.modification = !0)
                      : (n.flags.reset = !0)),
                    e.clean && (n.flags.factory = !0),
                    (o = !e.internal);
                } else
                  (n.flags.first_install = !0), (o = !e.internal || e.save);
                y.length ||
                  x.length ||
                  i ||
                  e.internal ||
                  n.warnings.push(
                    Dr.getMessage(
                      "This_script_does_not_provide_any__include_information_"
                    )
                  ),
                  l &&
                    !e.internal &&
                    Object.keys(l).forEach((e) => {
                      const r = l[e];
                      let s;
                      s = Dr.getMessage(
                        "ads" == e
                          ? "Antifeature_ads"
                          : "miner" == e
                          ? "Antifeature_miner"
                          : "tracking" == e
                          ? "Antifeature_tracking"
                          : "Antifeature_other"
                      );
                      const o =
                        r[Dr.getBestLocale(Object.keys(r)) || "default"] ||
                        r.en ||
                        Dr.getMessage("Antifeature_no_details");
                      let a, c;
                      t &&
                        t.antifeatures &&
                        (c = t.antifeatures[e]) &&
                        (a =
                          c[Dr.getBestLocale(Object.keys(c)) || "default"] ||
                          c.en ||
                          Dr.getMessage("Antifeature_no_details")),
                        (i && a && o === a) ||
                          n.warnings.push(
                            Dr.getMessage(
                              "Antifeature__0name0__0description0",
                              s,
                              o
                            )
                          );
                    }),
                  (n.flags.sync = !!e.sync),
                  (n.flags.internal = e.internal),
                  (n.flags.ask = e.ask),
                  (n.flags.save = e.save),
                  (n.flags.whitewash = e.whitewash);
              })
              .then(() => {
                if (
                  ((G = e.defaultscript),
                  (C = mu.determineLastPosition() + 1),
                  (k = s),
                  e.force_meta)
                ) {
                  let t;
                  (t = e.force_meta.fileURL) && (b = t),
                    (t = e.force_meta.lastModified) && (k = t);
                }
                if (n.flags.factory || n.flags.reset) t && (k = t.lastModified);
                else if (
                  (e.force_url && ((I = null), (g = e.force_url)),
                  t &&
                    ((E.override = zt(t.options.override, {})),
                    (E.comment = t.options.comment),
                    (E.check_for_updates = t.options.check_for_updates),
                    d != t.textContent))
                ) {
                  const r = t.options.user_modified;
                  if (e.save && !e.internal) {
                    E.user_modified = Date.now();
                    const e = b || g;
                    !un.values.editor_easySave &&
                      !r &&
                      E.check_for_updates &&
                      e &&
                      "none" != e &&
                      n.warnings.push(
                        Dr.getMessage(
                          "Modifying_a_script_will_disable_automatic_script_updates_"
                        )
                      );
                  } else
                    !0 !== e.replace &&
                      !0 !== e.internal &&
                      !0 !== e.clean &&
                      !0 !== e.whitewash &&
                      r &&
                      n.warnings.push(
                        Dr.getMessage(
                          "The_script_was_modified_locally_on_0date0__Updating_it_will_overwrite_your_changes_",
                          new Date(r).toLocaleString()
                        )
                      );
                }
                (E.override.orig_includes = y),
                  (E.override.orig_excludes = _),
                  (E.override.orig_matches = x),
                  (E.override.orig_connects = c),
                  (E.override.orig_noframes = E.noframes),
                  (E.override.orig_run_at = E.run_at || "document-idle"),
                  (E.noframes = null),
                  (E.run_at = null);
              })
              .then(() => {
                if (
                  t &&
                  ((b = t.fileURL),
                  t.deleted || (C = t.position),
                  t.sync && (S = t.sync),
                  !n.flags.factory && !n.flags.reset)
                ) {
                  (v = t.enabled),
                    (E.noframes = t.options.noframes),
                    (E.run_at = t.options.run_at);
                  const {
                    compatopts_for_requires: r,
                    compat_wrappedjsobject: s,
                    compat_metadata: o,
                    compat_foreach: a,
                    compat_powerful_this: l,
                  } = t.options;
                  (E = {
                    ...E,
                    compatopts_for_requires: r,
                    compat_wrappedjsobject: s,
                    compat_metadata: o,
                    compat_foreach: a,
                    compat_powerful_this: l,
                  }),
                    e.save && !e.force_url && (g = t.downloadURL || g);
                  const u = mu.determineSourceURL(t),
                    A = mu.determineSourceURL({
                      fileURL: b,
                      downloadURL: g,
                      updateURL: I,
                    }),
                    d = u ? Fn(u) : u || Dr.getMessage("_not_set_"),
                    h = A ? Fn(A) : A || Dr.getMessage("_not_set_");
                  if (
                    (d == h ||
                      i ||
                      e.internal ||
                      n.warnings.push(
                        Dr.getMessage(
                          "The_update_url_has_changed_from_0oldurl0_to__0newurl0",
                          [d, h]
                        )
                      ),
                    !e.save)
                  ) {
                    const e = t.options.override.orig_includes || t.includes,
                      r = t.options.override.orig_matches || t.matches,
                      s = t.options.override.orig_excludes || t.excludes;
                    Wt(e, y, "notinfirst").length +
                      Wt(r, x, "notinfirst").length +
                      Wt(_, s, "notinfirst").length &&
                      n.warnings.push(
                        Dr.getMessage(
                          "At_least_one_of_the_include_match_or_exclude_statements_was_changed_"
                        )
                      ),
                      Wt(t.connects || [], c || [], "notinfirst").length &&
                        n.warnings.push(
                          Dr.getMessage(
                            "At_least_one_new_connect_statement_was_added_"
                          )
                        );
                  }
                }
              })
              .then(() => {
                if (t && !n.flags.factory && h == t.version) {
                  if (e.defaultscript) return R.Breach();
                  if (e.noreinstall) return R.Breach();
                }
              })
              .then(() => {
                t
                  ? (n.flags.factory || n.flags.reset
                      ? (n.flags.reset
                          ? ((n.heading = Dr.getMessage(
                              "You_are_about_to_reinstall_a_UserScript_"
                            )),
                            (n.flags.reinstall = !0))
                          : ((n.heading = Dr.getMessage(
                              "You_are_about_to_install_a_UserScript_"
                            )),
                            (n.flags.install = !0)),
                        e.internal ||
                          n.warnings.splice(
                            0,
                            0,
                            Dr.getMessage("All_script_settings_will_be_reset_")
                          ))
                      : n.flags.modification
                      ? (n.heading = Dr.getMessage(
                          "You_are_about_to_modify_a_UserScript_"
                        ))
                      : es(h, t.version) == es.eOLDER
                      ? ((n.heading = Dr.getMessage(
                          "You_are_about_to_downgrade_a_UserScript"
                        )),
                        (n.flags.downgrade = !0),
                        i ||
                          e.internal ||
                          n.warnings.splice(
                            0,
                            0,
                            Dr.getMessage(
                              "The_downgraded_script_might_have_problems_to_read_its_stored_data_"
                            )
                          ))
                      : ((n.heading = Dr.getMessage(
                          "You_are_about_to_update_a_UserScript_"
                        )),
                        (n.flags.update = !0)),
                    n.info.push({
                      label: Dr.getMessage("Installed_Version_"),
                      value: "v" + t.version,
                    }))
                  : ((n.heading = Dr.getMessage(
                      "You_are_about_to_install_a_UserScript_"
                    )),
                    i ||
                      e.internal ||
                      n.info.splice(
                        0,
                        0,
                        Dr.getMessage(
                          "Malicious_scripts_can_violate_your_privacy_"
                        )
                      ),
                    (n.flags.install = !0)),
                  i ||
                    e.internal ||
                    Wi.getWarningsFor(
                      mu.determineSourceURL({
                        fileURL: b,
                        downloadURL: g,
                        updateURL: I,
                      })
                    ).forEach((e) => {
                      n.warnings.splice(0, 0, e);
                    }),
                  n.flags.whitewash
                    ? (n.action = Dr.getMessage("Enable"))
                    : n.flags.install
                    ? (n.action = Dr.getMessage("Install"))
                    : n.flags.reinstall
                    ? (n.action = Dr.getMessage("Reinstall"))
                    : n.flags.modification
                    ? (n.action = Dr.getMessage("Modify"))
                    : n.flags.downgrade
                    ? (n.action = Dr.getMessage("Downgrade"))
                    : n.flags.update &&
                      (t && t.options.user_modified
                        ? (n.action = Dr.getMessage("Overwrite"))
                        : (n.action = Dr.getMessage("Update")));
              })
              .then(() => {
                if (
                  (e.url && (b = e.url),
                  e.sync && (S = e.sync),
                  e.force_options && zt(e.force_options, E, rs().options, !0),
                  e.force_settings)
                ) {
                  const { enabled: t, position: n } = e.force_settings;
                  void 0 !== t && (v = t), void 0 !== n && (C = n);
                }
                ({
                  options: E,
                  includes: y,
                  excludes: _,
                  matches: x,
                } = mu.mergeCludes({
                  options: E,
                  includes: y,
                  excludes: _,
                  matches: x,
                }));
              })
              .then(() => {
                const e = b ? b.split("/").slice(0, -1).join("/") : void 0;
                (f = a.requires.map(({ url: t }) => ({
                  unsafe_url: t,
                  abs_url: e,
                }))),
                  (m = a.resources.map(({ name: t, url: n }) => ({
                    unsafe_url: n,
                    abs_url: e,
                    name: t,
                  })));
              })
              .then(async () => {
                var t;
                const {
                  compat_wrappedjsobject: r,
                  compat_metadata: s,
                  compat_foreach: i,
                } = E;
                (r || s || i) &&
                  n.info.push({
                    label: Dr.getMessage("Note"),
                    value: Dr.getMessage(
                      "A_recheck_of_the_GreaseMonkey_FF_compatibility_options_may_be_required_in_order_to_run_this_script_"
                    ),
                  });
                let o,
                  l,
                  c = {
                    ...a,
                    downloadURL: g,
                    enabled: v,
                    excludes: _,
                    fileURL: b,
                    includes: y,
                    lastModified: k,
                    matches: x,
                    options: E,
                    sync: S,
                    position: C,
                    uuid: M,
                    updateURL: I,
                    system: G,
                  };
                if (
                  (o = mu.determineOrigin(c)) &&
                  (l =
                    null === (t = os[o.token]) || void 0 === t
                      ? void 0
                      : t.convert)
                ) {
                  const t = await l(c);
                  if (
                    (t.info &&
                      ("includes added" === t.info
                        ? n.info.push(
                            Dr.getMessage(
                              "Automatically_added_user_includes_for_compatibility_reasons_"
                            )
                          )
                        : w.warn(
                            "scriptman: unknown script convert info",
                            t.info
                          )),
                    t.warning)
                  ) {
                    let r;
                    "deleted by hoster" === t.warning &&
                      (r = Dr.getMessage(
                        "This_script_was_deleted_by_the_hoster_"
                      )),
                      r
                        ? e.internal
                          ? n.info.push(r)
                          : n.warnings.push(r)
                        : w.warn(
                            "scriptman: unknown script convert warning",
                            t.warning
                          );
                  }
                  c = t.script || c;
                }
                return (
                  (p = mu.getEvilness(c)),
                  {
                    ...c,
                    uuid: M,
                    textContent: d,
                    evilness: p,
                    requires: f,
                    resources: m,
                  }
                );
              })
              .done((e) => {
                const s = {
                  script: e,
                  oldscript: t,
                  messages: n,
                  trigger_sync: !!o,
                  short_info: [
                    { label: Dr.getMessage("Author"), prop: "author" },
                    {
                      label: Dr.getMessage("Description"),
                      prop: "description",
                      i18n: !0,
                    },
                    { label: Dr.getMessage("Source"), prop: "fileURL" },
                  ],
                  hints: [],
                };
                r.resolve(s);
              })
              .fail(() => {
                r.reject({ messages: n });
              }),
            r.promise()
          );
        },
        hu = (e) => {
          const t = R(),
            n = e.messages,
            r = e.script,
            s = n.warnings.length || n.flags.ask,
            i = e.trigger_sync,
            o = () => {
              n.flags.modification || no.dropAll(r.uuid), t.notify();
              const e = mu.doModify(r.uuid, r, i) || {};
              return (
                n.flags.save ||
                  (!n.flags.install && !n.flags.update) ||
                  n.flags.factory ||
                  n.flags.reset ||
                  mr(r.name, n.flags.install ? "i" : "u", r.fileURL || ""),
                (n.flags.first_install || n.flags.factory) &&
                  Cd.setStorageByUid(r.uuid, { ts: Date.now(), data: {} }),
                e
              );
            },
            a = {
              uuid: r.uuid,
              lastModified: void 0,
              installed: !0,
              renamed: n.flags.renamed,
            };
          if (s) {
            if (
              ze.inIncognitoContext &&
              "temporary" == un.values.incognito_mode
            ) {
              const t = {
                globalhint: !0,
                options: {
                  id: "incognito",
                  image: "critical",
                  text: Dr.getMessage(
                    "All_modifications_are_only_kept_until_this_incognito_session_is_closed_"
                  ),
                },
              };
              e.hints.push(t);
            }
            bi.install(e)
              .done(({ ok: e, aborted: n }) => {
                e && o(), t.resolve({ installed: e, aborted: n });
              })
              .fail(() => {
                t.reject();
              });
          } else
            X(() => {
              o(), t.resolve(a);
            }, 1);
          return t.promise();
        },
        pu = (e, t) => {
          const n = t || {},
            r = Object.values(e).map((t) => {
              let r, s, i;
              t.evilness &&
                (t.evilness == Wi.SEVERITY_FOISTED_SCRIPT
                  ? (r = Dr.getMessage(
                      "The_origin_of_this_script_cant_be_determined_"
                    ))
                  : t.evilness >=
                      Math.min(
                        Wi.SEVERITY_MAX,
                        un.values.script_blacklist_severity
                      ) && (s = Dr.getMessage("This_script_is_blacklisted_"))),
                t.evilness && (i = Wi.getWarningsFor(gu.determineSourceURL(t)));
              const o = n.options_page,
                a = {
                  userscript: !0,
                  foisted: r,
                  blacklisted: s,
                  warnings: i,
                  icon: t.icon64 || t.icon || void 0,
                };
              if (o) {
                const { textContent: r, requires: s, resources: i, ...o } = t,
                  l = (e, r) => {
                    const s = e.url || Un(e.unsafe_url, e.abs_url),
                      i = no.getElement(t.uuid, s);
                    let o,
                      a,
                      l,
                      c,
                      u,
                      A = 0,
                      d = null,
                      h = null;
                    return (
                      i &&
                        i.data &&
                        (i.data.content &&
                          ((u = i.data.content), (A = u.length)),
                        (h = i.data.sri),
                        (d = i.ts),
                        (o = i.modified),
                        (c = i.data.meta || "text/plain"),
                        (l =
                          r ||
                          /text\/.*|application\/(?:x-)?(?:java|ecma)script/.test(
                            c
                          )),
                        (a = !0)),
                      {
                        display_url: e.url || e.unsafe_url,
                        abs_url: e.abs_url,
                        unsafe_url: e.unsafe_url,
                        url: s,
                        data: { length: A, content: n.externals ? u : void 0 },
                        sri: h || void 0,
                        ts: d,
                        mimetype: c,
                        editable: a,
                        viewable: l,
                        modified: o,
                      }
                    );
                  },
                  c = s.map((e) => l(e, !0)),
                  u = i.map((e) => l(e)),
                  A = gu.determineOrigin(t),
                  d = gu.isContexter(t),
                  h = uu.getSessionConnects(t.uuid),
                  p = Cd.getStorageByUid(t.uuid),
                  f = Object.keys(p.data).length,
                  m = Kc(t),
                  g = t.deleted,
                  v = t.lastUpdated,
                  _ = t.downloadURL || t.fileURL || void 0,
                  w = e.length;
                return {
                  ...o,
                  ...a,
                  requires: c,
                  resources: u,
                  ...(n.referrer
                    ? { referrer: n.referrer, length: r.length }
                    : { code: r }),
                  origin: A,
                  contexter: d,
                  temp_connects: h,
                  ...(n.storage ? { storage: p } : {}),
                  storage_key_count: f,
                  remote_url: m,
                  deleted: g,
                  lastUpdated: v,
                  file_url: _,
                  positionof: w,
                };
              }
              {
                const e = gu.determineOrigin(t),
                  r = n.active_urls || {},
                  s = n.active_counts || {},
                  i = n.all_time_active_counts || {};
                return {
                  ...a,
                  name: t.name,
                  name_i18n: t.name_i18n,
                  uuid: t.uuid,
                  nnew: !1,
                  system: t.system,
                  support: !!t.supportURL || (e && !!e.issue_url),
                  abuse: void 0,
                  active_urls: r[t.uuid],
                  active_count: s[t.uuid],
                  all_time_active_count: i[t.uuid],
                  referrer: n.referrer,
                  contexter: gu.isContexter(t),
                  enabled: t.enabled,
                  position: t.position,
                  deleted: t.deleted,
                  options: t.options,
                };
              }
            });
          return r;
        },
        fu = Ht(1e3),
        mu = {
          determineSourceURL: (e) => {
            if (e)
              return (
                [e.downloadURL, e.fileURL].filter((e) => {
                  var t;
                  if (
                    !e ||
                    "file:" !==
                      (null === (t = Zn(e)) || void 0 === t
                        ? void 0
                        : t.protocol)
                  )
                    return e;
                })[0] || void 0
              );
          },
          determineMetaURL: (e) => {
            if (!e) return;
            let t;
            const n = mu.determineOrigin(e);
            return (
              n && n.meta_header
                ? (t = e.fileURL)
                : !e.fileURL ||
                  (n && !n.meta_url) ||
                  ((t = e.fileURL.replace(".user.js", ".meta.js")),
                  e.fileURL == t &&
                    (t = e.fileURL.replace(".tamper.js", ".meta.js")),
                  e.fileURL == t && (t = null)),
              [e.updateURL, e.downloadURL, t].filter((e) => {
                var t;
                if (
                  !e ||
                  "file:" !==
                    (null === (t = Zn(e)) || void 0 === t ? void 0 : t.protocol)
                )
                  return e;
              })[0] || void 0
            );
          },
          mergeCludes: (e) => {
            let t, n;
            const r = e.options.override;
            if (
              (["includes", "excludes", "matches"].forEach((t) => {
                const n = `merge_${t}`,
                  s = `orig_${t}`;
                e[t] = r[n] && r[s] ? r[s].slice() : [];
              }),
              r.use_includes)
            )
              for (t = 0; t < r.use_includes.length; t++)
                (n = e.excludes.indexOf(r.use_includes[t])),
                  n >= 0 && e.excludes.splice(n, 1),
                  e.includes.push(r.use_includes[t]);
            if (r.use_matches)
              for (t = 0; t < r.use_matches.length; t++)
                (n = e.excludes.indexOf(r.use_matches[t])),
                  n >= 0 && e.excludes.splice(n, 1),
                  e.matches.push(r.use_matches[t]);
            if (r.use_excludes)
              for (t = 0; t < r.use_excludes.length; t++)
                e.excludes.push(r.use_excludes[t]);
            return e;
          },
          doSave: (e) => du(e).then(hu),
          doRemove: (e, t) => {
            if (t)
              Cd.removeByUid(e), Cd.setStorageByUid(e, void 0), no.dropAll(e);
            else if ((Cd.softRemoveByUid(e, !0), "off" == un.values.trash_mode))
              return mu.doRemove(e, !0);
            return R.Pledge();
          },
          doModify: (e, t, n) => (
            void 0 === n && (n = !0),
            Cd.setByUid(e, t, n),
            n
              ? no
                  .loadResources(e, t.resources)
                  .then(() => no.loadRequires(e, t.requires))
                  .then(() => {
                    const n = []
                      .concat(t.resources)
                      .concat(t.requires)
                      .map((e) => Un(e.unsafe_url, e.abs_url))
                      .filter((e) => e);
                    return no.dropAllBut(e, n);
                  })
              : R.Pledge()
          ),
          exportToJson: (e, t) => {
            const n = R();
            let r = mu.determineScriptsToRun();
            (r = r.filter((e) => !e.deleted)),
              e && (r = r.filter((t) => e[t.uuid]));
            const { storage: s, externals: i, global_settings: o } = t || {},
              a = {
                scripts: pu(r, { options_page: !0, storage: s, externals: i }),
              };
            return (
              o && (a.global_settings = Ot.getValue(Ze.STORAGE.CONFIG, {})),
              n.resolve(a),
              n.promise()
            );
          },
          importFromJson: (e) => {
            if (!e || !e.scripts || !e.scripts.length)
              return R.Breach("invalid json");
            const t = {},
              n = [],
              r = [],
              s = [],
              i = {},
              o = {};
            for (const a of e.scripts)
              try {
                const e = R(),
                  l = a.uuid || Xt();
                if ("new-user-script" == l) continue;
                a.storage && (i[l] = a.storage);
                for (const e of ["resources", "requires"]) {
                  const t = a[e];
                  t && t.length && ((o[l] = o[l] || {}), (o[l][e] = t));
                }
                const c = a.file_url || a.update_url;
                du({
                  uuid: a.uuid,
                  name: a.name,
                  src: a.source,
                  force_settings: { enabled: a.enabled, position: a.position },
                  force_options: a.options,
                  force_meta: { lastModified: a.lastModified },
                  replace: !0,
                  url: c,
                  ask: !1,
                })
                  .done((n) => {
                    const i = Xt();
                    (t[i] = n),
                      a.storage &&
                        a.storage.data &&
                        Object.keys(a.storage.data).length &&
                        r.push(i),
                      o[l] && s.push(i),
                      e.resolve();
                  })
                  .fail((t) => {
                    w.warn("import: Error @ script", a.name, t), e.resolve();
                  }),
                  n.push(e.promise());
              } catch (e) {
                w.warn("import: Error while importing script", a.name, e);
              }
            const a = (() => {
              const e = R();
              return (
                R.when(n).always(() => {
                  e.resolve();
                }),
                e.promise()
              );
            })()
              .then(() =>
                bi.import({
                  scripts: t,
                  storage_ids: r,
                  externals_ids: s,
                  global_settings: !!e.global_settings,
                  hints:
                    ze.inIncognitoContext &&
                    "temporary" == un.values.incognito_mode
                      ? [
                          {
                            globalhint: !0,
                            options: {
                              id: "incognito",
                              image: "critical",
                              text: Dr.getMessage(
                                "All_modifications_are_only_kept_until_this_incognito_session_is_closed_"
                              ),
                            },
                          },
                        ]
                      : [],
                })
              )
              .then(
                ({ message: e, ok: n, aborted: r }) => {
                  const s = R(),
                    a = [],
                    l = [];
                  if (r) return R.Breach(Dr.getMessage("Aborted_by_user"));
                  if (!e) return R.Breach("invalid response");
                  if (n)
                    for (let n, r = 0; (n = e.import_ids[r]); r++)
                      (() => {
                        const r = n;
                        if (t[r]) {
                          t[r].messages.warnings = [];
                          const n = t[r].script.uuid,
                            s = hu(t[r])
                              .progress(() => {
                                if (!e.externals_ids.includes(r)) return;
                                const t = o[n];
                                ["resources", "requires"].forEach((e) => {
                                  let r;
                                  t &&
                                    (r = t[e]) &&
                                    r.length &&
                                    r.forEach((e) => {
                                      no.setElement(
                                        n,
                                        e.url,
                                        {
                                          content: e.content || "",
                                          meta: e.mimetype || "text/javascript",
                                        },
                                        e.modified
                                      );
                                    });
                                });
                              })
                              .done(() => {
                                let t;
                                e.storage_ids.includes(r) &&
                                  i[n] &&
                                  ((t = Cd.setStorageByUid(n, {
                                    data: i[n].data || {},
                                    ts: Date.now(),
                                  })),
                                  l.push(t));
                              });
                          a.push(s);
                        }
                      })();
                  return (
                    R.when(a).always(() => {
                      mu.reorderScripts(),
                        R.when(l).always(() => {
                          s.resolve(e);
                        });
                    }),
                    s.promise()
                  );
                },
                (e) => e.error
              )
              .then((t) => {
                if (e.global_settings && t.global_settings) {
                  const t = Ot.setValue(
                    Ze.STORAGE.CONFIG,
                    e.global_settings
                  ).then(
                    () => (
                      a.done(() => {
                        X(ia.reset, 1);
                      }),
                      R.Pledge({ global_settings: !0 })
                    )
                  );
                  return Ot.setTemporary(!0), t;
                }
                return R.Pledge({});
              });
            return a;
          },
          installFromUrl: (e, t, n) => {
            const r = R(),
              s = {
                messages: {
                  info: [],
                  errors: [
                    Dr.getMessage("Unable_to_load_script_from_url_0url0", e),
                  ],
                  warnings: [],
                  flags: {},
                },
              };
            t = t || {};
            const i = n || {},
              o = ["url", e, JSON.stringify(t)].join("_");
            if (fu.is(o))
              return (
                w.debug("scriptman: de-bounced installFromUrl", e), R.Breach(s)
              );
            fu.add(o);
            const a = Zn(e);
            return a && a.protocol.match(/(https?|file):/)
              ? ("file:" != a.protocol ||
                  Te.ALLOWS_FILE_SCHEME_ACCESS ||
                  w.warn(
                    "scriptman: Access to local files is forbidden! Loading the following script for installation may fail:",
                    e,
                    "-> more info:",
                    "https://www.tampermonkey.net/faq.php#Q204"
                  ),
                fd(e)
                  .then((n) => {
                    const s = { url: e, ask: !0, replace: !0, ...t };
                    r.consume(mu.installFromSource(n, s, i));
                  })
                  .fail((e) => {
                    let t;
                    e
                      ? ((t = s),
                        "file:" != a.protocol ||
                          Te.ALLOWS_FILE_SCHEME_ACCESS ||
                          t.messages.warnings.unshift(
                            Dr.getMessage(
                              "Tampermonkey_has_no_file_access_permission_"
                            )
                          ),
                        (t.heading = Dr.getMessage(
                          "You_are_about_to_install_a_UserScript_"
                        )),
                        i.silent_fail
                          ? r.reject(t)
                          : bi.installError(t).always((e) => {
                              r.reject(e);
                            }))
                      : r.reject();
                  }),
                r.promise())
              : (w.warn("scriptman: can't install from ", e), R.Breach(s));
          },
          installFromSource: (e, t, n) => {
            const r = R();
            t = t || {};
            const s = n || {},
              i = { src: e, ask: !0, replace: !0, ...t };
            return (
              mu
                .doSave(i)
                .done((e) => {
                  r.resolve(!!e.installed);
                })
                .fail((e) => {
                  e
                    ? ((e.heading = Dr.getMessage(
                        "You_are_about_to_install_a_UserScript_"
                      )),
                      s.silent_fail
                        ? r.reject(e)
                        : bi.installError(e).always(() => r.reject()))
                    : r.reject();
                }),
              r.promise()
            );
          },
          determineLastPosition: () => {
            let e = 0;
            return (
              Cd.getUidList().forEach((t) => {
                const n = Cd.getByUid(t);
                n.script && n.cond
                  ? n.script.position &&
                    n.script.position != Number.MAX_SAFE_INTEGER &&
                    n.script.position > e &&
                    (e = n.script.position)
                  : w.warn("scriptman: inconsistent script entry", t);
              }),
              e
            );
          },
          getEvilness: (e) => {
            let t = 0;
            return (e.fileURL && (t = Wi.getEvilnessOf(e.fileURL))) ||
              (e.downloadURL && (t = Wi.getEvilnessOf(e.downloadURL))) ||
              (e.updateURL && (t = Wi.getEvilnessOf(e.updateURL)))
              ? (w.debug("scriptman: found blacklisted script", e), t)
              : 0;
          },
          blackCheckAll: () => {
            const e = Cd.getUidList()
              .map((e) => {
                const t = Cd.getByUid(e),
                  { script: n, cond: r } = t;
                if (!n || !r) return;
                const s = mu.getEvilness(n);
                return s !== n.evilness
                  ? ((n.evilness = s), mu.doModify(e, n, !1))
                  : void 0;
              })
              .filter((e) => e);
            return R.when(e).then(() => {});
          },
          reorderScripts: (e, t) => {
            const n = t || 0;
            let r = mu.determineScriptsToRun();
            if (e)
              for (let t = 0; t < r.length; t++) {
                const s = r[t];
                if (s.uuid == e) {
                  const e = s.position < n ? 0.5 : -0.5;
                  s.position = n + e;
                }
              }
            r = Au(r);
            let s = 1;
            const i = r.map(
              (e) => (
                e.deleted
                  ? (e.position = Number.MAX_SAFE_INTEGER)
                  : (e.position = s++),
                mu.doModify(e.uuid, e, !1)
              )
            );
            return R.when(i).then(() => {});
          },
          scriptWillRun: (e, t) => {
            if (!t || !e) return;
            let n = kd.get(e);
            if (!n) {
              const t = Ot.getValue(Ze.PREFIX.COND + e, null);
              if (!t) return;
              const { match: r, inc: s, exc: i } = t;
              let o;
              switch (un.values.script_include_mode) {
                case "off":
                  o = {
                    match: r,
                    exc: i,
                  };
                  break;
                case "match":
                  o = {
                    match: (r || []).concat(
                      (s || []).filter((e) => "/" !== e[0])
                    ),
                    exc: i,
                  };
                  break;
                case "unsafe":
                case "default":
                  o = { match: r, inc: s, exc: i };
              }
              (n = wd(o, !0)), kd.set(e, n);
            }
            return !!bd(t, n, e);
          },
          determineScriptsToRun: (e, t, n) => {
            const r = [];
            return (
              w.log("scriptman: determineScriptsToRun @" + e),
              Cd.getUidList().forEach((s) => {
                let i = !0,
                  o = 0;
                const a = Cd.getByUid(s);
                if (void 0 === n || !a.script || a.script.enabled === n) {
                  if (e) {
                    const t = Date.now();
                    (i = !!mu.scriptWillRun(s, e)), (o = Date.now() - t);
                  }
                  if (a.script && a.cond) {
                    if (
                      (t &&
                        o > 1e3 &&
                        (w.warn(
                          "scriptman: checking " +
                            a.script.name +
                            "'s (" +
                            s +
                            ") includes and excludes took " +
                            o +
                            "ms!"
                        ),
                        $s.all("status", {
                          key: "slowdown",
                          class: "warning",
                          text: Dr.getMessage(
                            "Script_0name0_is_slowing_down_some_page_loads_",
                            Dr.getTranslation(a.script, "name")
                          ),
                          timeout: 3e5,
                        })),
                      !i)
                    )
                      return;
                    w.verbose(
                      "scriptman: determineScriptsToRun: found script ",
                      a
                    ),
                      r.push(a.script);
                  } else w.warn("scriptman: inconsistent script entry", s, a);
                }
              }),
              Au(r)
            );
          },
          isContexter: (e) =>
            e.options &&
            ("context-menu" === e.options.run_at ||
              (null === e.options.run_at &&
                "context-menu" === e.options.override.orig_run_at)),
          determineOrigin: (e) => {
            const t = e.fileURL || e.downloadURL || e.updateURL;
            return t ? as(t) : void 0;
          },
          clean: (e) => {
            const t = Date.now();
            Cd.getUidList().forEach((n) => {
              const r = Cd.getByUid(n);
              if (r.script && r.cond) {
                if (!r.script.deleted) return;
                {
                  const e = "on" === un.values.trash_mode,
                    s = Math.floor(
                      (r.script.deleted + un.values.trash_cleanup_after - t) /
                        1e3
                    );
                  if (e && s >= 0)
                    return void w.log(
                      `scriptman: script entry in trash ${n} will be cleaned in ${s}s`,
                      r
                    );
                  w.log(
                    `scriptman: script entry in trash ${n} will be cleaned now`,
                    r
                  );
                }
              } else
                w.warn(
                  `scriptman: inconsistent script entry ${n} will be cleaned now`,
                  r
                );
              e || mu.doRemove(n, !0);
            });
          },
        },
        gu = mu,
        vu = gu,
        _u = ":",
        wu = "/",
        bu = "-",
        yu = "-error-",
        ku = "default-src",
        Ru = "script-src",
        xu = "style-src",
        Eu = "frame-src",
        Su = "report-uri",
        Cu = "frame-ancestors",
        Mu = "reflected-xss",
        Iu = "upgrade-insecure-requests",
        Gu = "child-src",
        Uu = "block-all-mixed-content",
        Zu = "sandbox",
        Tu = "worker-src",
        Bu = "navigate-to",
        Ou = "script-src-elem",
        Fu = "script-src-attr",
        Du = "style-src-elem",
        ju = "style-src-attr",
        Pu = ["sha256", "sha384", "sha512"],
        Lu = [
          yu,
          ku,
          Ru,
          "object-src",
          xu,
          "img-src",
          "media-src",
          Eu,
          "font-src",
          "connect-src",
          Su,
          Cu,
          Mu,
          "base-uri",
          "form-action",
          "manifest-src",
          Iu,
          Gu,
          Uu,
          Zu,
          Tu,
          Bu,
          Ou,
          Fu,
          Du,
          ju,
        ],
        Nu = "'self'",
        Vu = "'unsafe-inline'",
        zu = "'unsafe-eval'",
        qu = "'unsafe-hashes'",
        Hu = "'none'",
        Qu = "'nonce-",
        Wu = "'report-sample'",
        Xu = "'strict-dynamic'",
        Yu = "'unsafe-allow-redirects'",
        Ju = "'wasm-unsafe-eval'",
        Ku = "'sha-",
        $u = [Nu, Vu, zu, qu, Hu, Qu, Wu, Xu, Yu, Ju, Ku],
        eA = -1,
        tA = (e) => ("http" === e ? 80 : "https" === e ? 443 : eA);
      class nA {
        constructor(e) {
          (this.mValue = e),
            (this.mCurCharPos = 0),
            (this.mEndCharPos = e.length),
            (this.mCurToken = "");
        }
        get mCurChar() {
          return this.mValue[this.mCurCharPos];
        }
        atEnd() {
          return this.mCurCharPos >= this.mEndCharPos;
        }
        skipWhiteSpace() {
          for (; this.mCurCharPos < this.mEndCharPos && o(this.mCurChar); )
            this.mCurToken += this.mValue[this.mCurCharPos++];
          this.mCurToken = "";
        }
        skipWhiteSpaceAndSemicolon() {
          for (
            ;
            this.mCurCharPos < this.mEndCharPos &&
            (";" === this.mCurChar || o(this.mCurChar));

          )
            this.mCurToken += this.mValue[this.mCurCharPos++];
          this.mCurToken = "";
        }
        accept(e) {
          return (
            this.mCurChar === e &&
            ((this.mCurToken += this.mValue[this.mCurCharPos++]), !0)
          );
        }
        generateNextToken() {
          for (
            this.skipWhiteSpaceAndSemicolon(),
              this.mCurToken.length &&
                console.warn(
                  "nsCSPTokenizer::mCurToken not empty",
                  this.mCurToken
                );
            !this.atEnd() && !o(this.mCurChar) && ";" !== this.mCurChar;

          )
            this.mCurToken += this.mValue[this.mCurCharPos++];
        }
        generateTokens(e) {
          let t = [];
          for (; !this.atEnd(); )
            this.generateNextToken(),
              t.push(this.mCurToken),
              this.skipWhiteSpace(),
              (this.atEnd() || this.accept(";")) && (e.push(t), (t = []));
        }
        static tokenizeCSPPolicy(e) {
          const t = [];
          return new nA(e).generateTokens(t), t;
        }
      }
      class rA {
        constructor(e) {
          (this.mDirective = e), (this.mSrcs = []);
        }
        permits(e, t, n, r, s, i) {
          if (!this.equals(e) && !this.isDefaultDirective())
            return (
              console.warn(
                `cspd::permits, aUri: ${Bn(
                  n
                )}, aDirective: ${e}, this: ${this.toString()}`
              ),
              !1
            );
          if (t)
            if (e === Du) {
              if (A(t, this.mSrcs)) return !0;
            } else if (e === Ou || e === Tu) {
              if (A(t, this.mSrcs)) return !0;
              const e = [];
              let n = !1;
              for (let t = 0; t < this.mSrcs.length; t++)
                this.mSrcs[t].isHash()
                  ? e.push(this.mSrcs[t])
                  : this.mSrcs[t].isKeyword(Xu) && (n = !0);
              if (e.length) {
                t.GetIntegrityMetadata();
                const n = [];
                if (n.length) {
                  let t = !0;
                  for (const r of n) {
                    const n = r.GetAlgorithm(),
                      s = r.GetHash(0);
                    let i = !1;
                    for (const t of e) {
                      const e = t.getAlgorithm(),
                        r = t.getHash();
                      if (n === e && s === r) {
                        i = !0;
                        break;
                      }
                    }
                    if (!i) {
                      t = !1;
                      break;
                    }
                  }
                  if (t) return !0;
                }
              }
              if (n && 5 != t.InternalContentPolicyType())
                return !t.GetParserCreatedScript();
            }
          for (let e = 0; e < this.mSrcs.length; e++)
            if (this.mSrcs[e].permits(n, r, s, i)) return !0;
          return !1;
        }
        allows(e, t) {
          return this.mSrcs.some((n) => n.allows(e, t));
        }
        toString() {
          let e = "";
          return (
            (e += this.mDirective + " "),
            (e += this.mSrcs.map((e) => e.toString()).join(" ")),
            e
          );
        }
        addSrcs(e) {
          this.mSrcs = [...e];
        }
        getSrcs() {
          return [...this.mSrcs];
        }
        isDefaultDirective() {
          return this.mDirective === ku;
        }
        equals(e) {
          return this.mDirective === e;
        }
        getReportURIs() {
          return this.mDirective != Su
            ? (console.warn(
                "cspd::getReportURIs: not a report-uri directive!",
                this.mDirective
              ),
              [])
            : this.mSrcs.map((e) => e.toString());
        }
        getDirName() {
          return this.mDirective;
        }
        allowsAllInlineBehavior(e) {
          let t = !1;
          for (const n of this.mSrcs) {
            if (n.isNonce() || n.isHash()) return !1;
            if ((e === Ou || e === Fu) && n.isKeyword(Xu)) return !1;
            n.isKeyword(Vu) && (t = !0);
          }
          return t;
        }
      }
      class sA extends rA {
        constructor(e, t) {
          super(e), (this.mStringSrc = t);
        }
        allows(e, t) {
          return !1;
        }
        permits(e, t, n, r, s, i) {
          return !1;
        }
        equals(e) {
          return this.mStringSrc[0] === e;
        }
        toString() {
          return this.mStringSrc.join(" ");
        }
      }
      class iA extends rA {
        constructor(e) {
          super(e);
        }
        permits(e, t, n, r, s, i) {
          return !1;
        }
        allows(e, t) {
          return !1;
        }
        toString() {
          return Iu;
        }
        addSrcs(e) {
          throw new Error("upgrade-insecure-requests does not hold any srcs");
        }
        getDirName() {
          return Iu;
        }
      }
      class oA extends rA {
        constructor(e) {
          super(e),
            (this.mRestrictWorkers = !1),
            (this.mRestrictScriptElem = !1),
            (this.mRestrictScriptAttr = !1),
            (this.mDirective = e);
        }
        setRestrictWorkers() {
          this.mRestrictWorkers = !0;
        }
        setRestrictScriptElem() {
          this.mRestrictScriptElem = !0;
        }
        setRestrictScriptAttr() {
          this.mRestrictScriptAttr = !0;
        }
        equals(e) {
          return e === Tu
            ? this.mRestrictWorkers
            : e === Ou
            ? this.mRestrictScriptElem
            : e === Fu
            ? this.mRestrictScriptAttr
            : this.mDirective === e;
        }
      }
      class aA {
        permits(e, t, n, r) {
          return !1;
        }
        allows(e, t) {
          return !1;
        }
        isReportSample() {
          return !1;
        }
        isKeyword(e) {
          return !1;
        }
        isHash() {
          return !1;
        }
        isNonce() {
          return !1;
        }
      }
      class lA extends aA {
        constructor(e) {
          if ((super(), (this.mKeyword = e), e === Nu))
            throw new Error("'self' should have been replaced in the parser");
        }
        allows(e, t) {
          return this.mKeyword === e;
        }
        toString() {
          return i(this.mKeyword);
        }
        isReportSample() {
          return this.mKeyword == Wu;
        }
        isKeyword(e) {
          return this.mKeyword == e;
        }
      }
      class cA extends aA {
        constructor(e) {
          super(),
            (this.mPath = ""),
            (this.mHost = e.toLowerCase()),
            (this.mGeneratedFromSelfKeyword = !1),
            (this.mIsUniqueOrigin = !1),
            (this.mWithinFrameAncstorsDir = !1);
        }
        permits(e, t, n, r) {
          if (this.mIsUniqueOrigin) return !1;
          if (!h(this.mScheme, e, n, r, this.mGeneratedFromSelfKeyword))
            return !1;
          const i = s(e.hostname);
          if ("*" == this.mHost) {
            if (
              "blob" === e.scheme ||
              "data" === e.scheme ||
              "filesystem" === e.scheme
            )
              return !1;
            if (!this.mScheme) return !0;
          } else if ("*" == this.mHost[0]) {
            if ("." != this.mHost[1])
              throw new Error(
                "Second character needs to be '.' whenever host starts with '*'"
              );
            const e = this.mHost.substr(1);
            if (!i.endsWith(e)) return !1;
          } else if (this.mHost != i) return !1;
          if (
            !(function (e, t, n) {
              if ("*" === t) return !0;
              let r = n.port;
              if (!r) {
                if (!e) return !1;
                const t = tA(e);
                return t == eA || 0 == t;
              }
              if (r === eA && !t) return !0;
              if (r === eA) {
                const e = n.scheme;
                r = tA(e);
              }
              const s = r.toString();
              if (t === s) return !0;
              let i = t;
              if (!i) {
                if (!e) throw new Error("need a scheme to query default port");
                i = tA(e).toString();
              }
              return i === s || ("80" === i && "443" === s);
            })(this.mScheme, this.mPort, e)
          )
            return !1;
          if (!t && this.mPath) {
            const t = e.pathname;
            if (this.mWithinFrameAncstorsDir) return !0;
            const n = s(t);
            if ("/" == this.mPath.substr(-1)) {
              if (!n.startsWith(this.mPath)) return !1;
            } else if (this.mPath != n) return !1;
          }
          return !0;
        }
        toString() {
          let e = "";
          return this.mGeneratedFromSelfKeyword
            ? Nu
            : "*" !== this.mHost || this.mScheme || this.mPort
            ? ((e += this.mScheme),
              (e += "://"),
              (e += this.mHost),
              this.mPort && (e += ":" + this.mPort),
              (e += i(this.mPath)),
              e)
            : this.mHost;
        }
        setScheme(e) {
          this.mScheme = e.toLowerCase();
        }
        setPort(e) {
          this.mPort = `${e}`;
        }
        appendPath(e) {
          this.mPath += e;
        }
        setGeneratedFromSelfKeyword() {
          this.mGeneratedFromSelfKeyword = !0;
        }
        setIsUniqueOrigin() {
          this.mIsUniqueOrigin = !0;
        }
        setWithinFrameAncestorsDir(e) {
          this.mWithinFrameAncstorsDir = e;
        }
        getScheme() {
          return this.mScheme;
        }
        getHost() {
          return this.mHost;
        }
        getPort() {
          return `${this.mPort || eA}`;
        }
        getPath() {
          return this.mPath;
        }
      }
      class uA extends aA {
        constructor(e) {
          super(), (this.mNonce = e);
        }
        allows(e, t) {
          return e === Qu && this.mNonce === t;
        }
        toString() {
          return `${Qu}${this.mNonce}'`;
        }
        getNonce() {
          return this.mNonce;
        }
        isNonce() {
          return !0;
        }
      }
      class AA extends aA {
        constructor(e, t) {
          super(),
            (this.mAlgorithm = e.toLowerCase()),
            (this.mHash = t.replace(/-/g, "+").replace(/_/g, "/"));
        }
        allows(e, t) {
          return !1;
        }
        toString() {
          return `'${this.mAlgorithm}-${this.mHash}'`;
        }
        getAlgorithm() {
          return this.mAlgorithm;
        }
        getHash() {
          return this.mHash;
        }
        isHash() {
          return !0;
        }
      }
      class dA extends aA {
        constructor(e) {
          super(), (this.mScheme = e.toLowerCase());
        }
        permits(e, t, n, r) {
          if ("" === this.mScheme)
            throw new Error("scheme cannot be the empty string");
          return h(this.mScheme, e, n, r, !1);
        }
        toString() {
          return `${this.mScheme}:`;
        }
        getScheme() {
          return this.mScheme;
        }
      }
      class hA extends aA {
        constructor(e) {
          super(), (this.mReportURI = e);
        }
        toString() {
          return i(Bn(this.mReportURI));
        }
      }
      class pA {
        constructor() {
          (this.mDeliveredViaMetaTag = !1),
            (this.mUpgradeInsecDir = null),
            (this.mDirectives = []),
            (this.mReportOnly = !1);
        }
        setDeliveredViaMetaTagFlag(e) {
          this.mDeliveredViaMetaTag = e;
        }
        getDeliveredViaMetaTagFlag() {
          return this.mDeliveredViaMetaTag;
        }
        matchingOrDefaultDirective(e) {
          let t = null;
          for (let n = 0; n < this.mDirectives.length; n++)
            if (this.mDirectives[n].isDefaultDirective())
              t = this.mDirectives[n];
            else if (this.mDirectives[n].equals(e)) return this.mDirectives[n];
          return t;
        }
        permits(e, t, n, r, s) {
          let i = null;
          for (const s of this.mDirectives) {
            if (s.equals(e))
              return s.permits(
                e,
                t,
                n,
                r,
                this.mReportOnly,
                !!this.mUpgradeInsecDir
              )
                ? { permitted: !0 }
                : { permitted: !1, violatedDirective: s.getDirName() };
            s.isDefaultDirective() && (i = s);
          }
          return !s && i
            ? i.permits(e, t, n, r, this.mReportOnly, !!this.mUpgradeInsecDir)
              ? { permitted: !0 }
              : { permitted: !1, violatedDirective: i.getDirName() }
            : { permitted: !0 };
        }
        allows(e, t, n) {
          const r = this.matchingOrDefaultDirective(e);
          return !r || r.allows(t, n);
        }
        toString() {
          return this.mDirectives.map((e) => e.toString()).join("; ");
        }
        hasDirective(e, t) {
          for (const n of this.mDirectives)
            if (t) {
              if (n.getDirName() === e) return !0;
            } else if (n.equals(e)) return !0;
          return !1;
        }
        addDirective(e) {
          this.mDirectives.push(e);
        }
        getDirectives() {
          return this.mDirectives;
        }
        setReportOnlyFlag(e) {
          this.mReportOnly = e;
        }
        getReportOnlyFlag() {
          return this.mReportOnly;
        }
        getDirectiveAsString(e) {
          for (const t of this.mDirectives)
            if (!t.equals(yu) && t.equals(e)) return t.toString();
          return "";
        }
        getNumDirectives() {
          return this.mDirectives.length;
        }
        getReportURIs() {
          for (const e of this.mDirectives)
            if (e.equals(Su)) return e.getReportURIs();
          return [];
        }
        allowsAllInlineBehavior(e) {
          const t = this.matchingOrDefaultDirective(e);
          return !t || t.allowsAllInlineBehavior(e);
        }
        addNonce(e) {
          let t = null,
            n = null,
            r = null;
          for (let e = 0; e < this.mDirectives.length; e++) {
            const s = this.mDirectives[e];
            s.equals(Ou)
              ? (t = e)
              : s.equals(Ru)
              ? (n = e)
              : s.equals(ku) && (r = e);
          }
          const s = new uA(e),
            i = null !== t ? t : null !== n ? n : r;
          if (null !== i) {
            const e = this.mDirectives[i]
              .getSrcs()
              .filter((e) => !e.allows(Hu));
            this.mDirectives[i].addSrcs([s, ...e]);
          } else {
            const e = new rA(Ru);
            e.addSrcs([s]), this.mDirectives.push(e);
          }
        }
        getAllowsEval() {
          return !(!this.allows(Ru, zu) && !this.getReportOnlyFlag());
        }
        getAllowsInline(e, t, n, r, s, i, o, a, l) {
          if (![Ou, Fu, Du, ju].includes(e))
            return (
              console.warn(
                "csppo: can only allow inline for (script/style)-src-(attr/elem)"
              ),
              !0
            );
          let c = "";
          if (this.allowsAllInlineBehavior(e)) return !0;
          if (this.allows(e, Qu, n)) return !0;
          "" === c && s && (c = s.innerText), "" === c && (c = o);
          const u = this.allows(e, qu);
          if ((!t || u) && this.allows(e, Ku, c)) return !0;
          let A = !1;
          return (
            [Ou, Fu].includes(e) && this.allows(e, Xu) && (A = !r),
            !(!A && !this.getReportOnlyFlag())
          );
        }
      }
      class fA {
        constructor(e, t, n) {
          (this.mCurCharPos = 0),
            (this.mEndCharPos = 0),
            (this.mCurValue = ""),
            (this.mValue = ""),
            (this.mHasHashOrNonce = !1),
            (this.mHasAnyUnsafeEval = !1),
            (this.mStrictDynamic = !1),
            (this.mUnsafeInlineKeywordSrc = void 0),
            (this.mWorkerSrc = void 0),
            (this.mScriptSrc = void 0),
            (this.mParsingFrameAncestorsDir = !1),
            (this.mTokens = e),
            (this.mCurDir = []),
            (this.mCurToken = ""),
            (this.mSelfURI = t),
            (this.mPolicy = void 0),
            (this.mDeliveredViaMetaTag = n);
        }
        get mCurChar() {
          return this.mValue[this.mCurCharPos];
        }
        atEnd() {
          return this.mCurCharPos >= this.mEndCharPos;
        }
        accept(e) {
          return (
            !this.atEnd() &&
            ("string" == typeof e ? this.mCurChar === e : e(this.mCurChar)) &&
            this.advance()
          );
        }
        peek(e) {
          return (
            !this.atEnd() &&
            ("string" == typeof e ? this.mCurChar === e : e(this.mCurChar))
          );
        }
        advance() {
          return (
            !this.atEnd() &&
            ((this.mCurValue += this.mCurChar), this.mCurCharPos++, !0)
          );
        }
        resetCurValue() {
          this.mCurValue = "";
        }
        resetCurChar(e) {
          (this.mValue = e),
            (this.mCurCharPos = 0),
            (this.mEndCharPos = e.length),
            this.resetCurValue();
        }
        atEndOfPath() {
          return this.atEnd() || this.peek("?") || this.peek("#");
        }
        atValidUnreservedChar() {
          return (
            this.peek(a) ||
            this.peek(l) ||
            this.peek(bu) ||
            this.peek(".") ||
            this.peek("_") ||
            this.peek("~")
          );
        }
        schemeChar() {
          return (
            !this.atEnd() &&
            (this.accept(a) ||
              this.accept(l) ||
              this.accept("+") ||
              this.accept(bu) ||
              this.accept("."))
          );
        }
        directiveName() {
          const e = (function (e) {
            const t = e.toLowerCase();
            for (let e = 1; e < Lu.length; e++) if (t === Lu[e]) return Lu[e];
            return (
              console.warn(
                `cspp: Cannot convert unknown directive string to CspDirective: '${e}'`
              ),
              yu
            );
          })(this.mCurToken);
          return e == yu
            ? (console.warn(
                "cspp: couldNotProcessUnknownDirective",
                this.mCurToken
              ),
              null)
            : e == Mu
            ? fA.sIgnoreUnknownSources
              ? new sA(yu, this.mCurDir)
              : (console.warn("cspp: notSupportingDirective", this.mCurToken),
                null)
            : ((e != Fu && e != Ou) ||
                fA.sSecurityCspScriptSrcAttrElemEnabled) &&
              ((e != ju && e != Du) || fA.sSecurityCspStyleSrcAttrElemEnabled)
            ? e != Bu || fA.sSecurityCspEnableNavigateTo
              ? this.mPolicy.hasDirective(e)
                ? (console.warn("cspp: duplicateDirective", this.mCurToken),
                  null)
                : !this.mDeliveredViaMetaTag || (e != Su && e != Cu && e != Zu)
                ? (e == Uu && new sA(yu, this.mCurDir),
                  e == Iu
                    ? new iA(e)
                    : e == Gu
                    ? (console.warn(
                        "cspp: deprecatedChildSrcDirective",
                        this.mCurToken
                      ),
                      new sA(yu, this.mCurDir))
                    : e == Eu
                    ? new sA(yu, this.mCurDir)
                    : e == Tu
                    ? ((this.mWorkerSrc = new rA(e)), this.mWorkerSrc)
                    : e == Ru
                    ? ((this.mScriptSrc = new oA(e)), this.mScriptSrc)
                    : e == xu
                    ? new sA(yu, this.mCurDir)
                    : e == ku || e == Ou || e == Fu
                    ? new rA(e)
                    : new sA(yu, this.mCurDir))
                : (console.warn("cspp: ignoringSrcFromMetaCSP", this.mCurToken),
                  null)
              : (console.warn(
                  "cspp: couldNotProcessUnknownDirective",
                  this.mCurToken
                ),
                null)
            : (console.warn("cspp: notSupportingDirective", this.mCurToken),
              null);
        }
        atValidPathChar() {
          return (
            this.atValidUnreservedChar() ||
            this.atValidSubDelimChar() ||
            this.atValidPctEncodedChar() ||
            this.peek(_u) ||
            this.peek("@")
          );
        }
        hostChar() {
          return (
            !this.atEnd() &&
            (this.accept(a) || this.accept(l) || this.accept(bu))
          );
        }
        atValidSubDelimChar() {
          return (
            this.peek("!") ||
            this.peek("$") ||
            this.peek("&") ||
            this.peek("'") ||
            this.peek("(") ||
            this.peek(")") ||
            this.peek("*") ||
            this.peek("+") ||
            this.peek("=")
          );
        }
        atValidPctEncodedChar() {
          return (
            !(this.mCurCharPos + 2 >= this.mEndCharPos) &&
            "%" === this.mCurChar &&
            c(this.mValue[this.mCurCharPos + 1]) &&
            c(this.mValue[this.mCurCharPos + 2])
          );
        }
        port() {
          if ((this.accept(_u), this.resetCurValue(), this.accept("*")))
            return !0;
          if (!this.accept(l))
            return console.warn("Couldn't parse port:", this.mCurToken), !1;
          for (; this.accept(l); );
          return !0;
        }
        subPath(e) {
          let t = 0,
            n = "";
          for (; !this.atEndOfPath(); ) {
            if (this.peek(wu))
              (n = s(this.mCurValue)), e.appendPath(n), this.resetCurValue();
            else if (!this.atValidPathChar())
              return (
                console.warn("Couldn't parse invalid source:", this.mCurToken),
                !1
              );
            if (
              (this.peek("%") && (this.advance(), this.advance()),
              this.advance(),
              ++t > 512)
            )
              return !1;
          }
          return (
            (n = s(this.mCurValue)), e.appendPath(n), this.resetCurValue(), !0
          );
        }
        path(e) {
          return (
            this.resetCurValue(),
            this.accept(wu)
              ? this.atEndOfPath()
                ? (e.appendPath("/"), !0)
                : this.peek(wu)
                ? (console.warn(
                    "Couldn't parse invalid source:",
                    this.mCurToken
                  ),
                  !1)
                : this.subPath(e)
              : (console.warn("Couldn't parse invalid source:", this.mCurToken),
                !1)
          );
        }
        subHost() {
          let e = 0;
          for (; !this.atEndOfPath() && !this.peek(_u) && !this.peek(wu); ) {
            for (e++; this.hostChar(); ) e++;
            if (this.accept(".") && !this.hostChar()) return !1;
            if (e > 512) return !1;
          }
          return !0;
        }
        host() {
          if (this.accept("*")) {
            if (this.atEnd() || this.peek(":")) return new cA(this.mCurValue);
            if (!this.accept("."))
              return (
                console.warn("cspp: couldntParseInvalidHost", this.mCurToken),
                null
              );
          }
          if (!this.hostChar())
            return (
              console.warn("cspp: couldntParseInvalidHost", this.mCurToken),
              null
            );
          if (!this.subHost())
            return (
              console.warn("cspp: couldntParseInvalidHost", this.mCurToken),
              null
            );
          if (
            (function (e) {
              const t = e.toLowerCase();
              for (const e of $u) {
                const n = e.toLowerCase();
                if (t === n.substring(1, n.length - 1)) return !0;
              }
              return !1;
            })(this.mCurValue)
          ) {
            const e = this.mCurValue.toLowerCase();
            console.warn("cspp: hostNameMightBeKeyword", this.mCurToken, e);
          }
          return new cA(this.mCurValue);
        }
        keywordSource() {
          return r(this.mCurToken, Nu)
            ? (function (e) {
                const t = e.hostname,
                  n = new cA(t);
                n.setGeneratedFromSelfKeyword();
                const r = e.scheme;
                if ((n.setScheme(r), "" === t)) return n.setIsUniqueOrigin(), n;
                const s = e.port || eA;
                return s > 0 && n.setPort(s), n;
              })(this.mSelfURI)
            : r(this.mCurToken, Wu)
            ? new lA(this.mCurToken)
            : r(this.mCurToken, Xu)
            ? this.mCurDir[0] !== Ru &&
              this.mCurDir[0] !== Ou &&
              this.mCurDir[0] !== Fu &&
              this.mCurDir[0] !== ku
              ? (console.warn("cspp: ignoringStrictDynamic", this.mCurToken),
                null)
              : ((this.mStrictDynamic = !0), new lA(this.mCurToken))
            : r(this.mCurToken, Vu)
            ? this.mUnsafeInlineKeywordSrc
              ? (console.warn("cspp: ignoringDuplicateSrc", this.mCurToken),
                null)
              : ((this.mUnsafeInlineKeywordSrc = new lA(this.mCurToken)),
                this.mUnsafeInlineKeywordSrc)
            : r(this.mCurToken, zu) ||
              (fA.sSecurityCspWasmUnsafeEvalEnabled && r(this.mCurToken, Ju))
            ? ((this.mHasAnyUnsafeEval = !0), new lA(this.mCurToken))
            : fA.sSecurityCspUnsafeHashesEnabled && r(this.mCurToken, qu)
            ? new lA(this.mCurToken)
            : r(this.mCurToken, Yu)
            ? d(this.mCurDir[0], Bu)
              ? new lA(this.mCurToken)
              : (console.warn(
                  "cspp: IgnoringSourceWithinDirective",
                  this.mCurToken
                ),
                null)
            : null;
        }
        nonceSource() {
          if (
            !this.mCurToken.startsWith("'nonce-") ||
            "'" !== this.mCurToken[this.mCurToken.length - 1]
          )
            return null;
          const e = this.mCurToken.substring(1, this.mCurToken.length - 1),
            t = e.indexOf("-");
          return t < 0
            ? null
            : u(e.substring(t + 1))
            ? ((this.mHasHashOrNonce = !0), new uA(e.substring(t + 1)))
            : null;
        }
        hashSource() {
          if (
            "'" !== this.mCurToken[0] ||
            "'" !== this.mCurToken[this.mCurToken.length - 1]
          )
            return null;
          const e = this.mCurToken.substring(1, this.mCurToken.length - 1),
            t = e.indexOf("-");
          if (t < 0) return null;
          if (!u(e.substring(t + 1))) return null;
          const n = e.substring(0, t).toLowerCase(),
            r = e.substring(t + 1);
          for (const e of Pu)
            if (n === e) return (this.mHasHashOrNonce = !0), new AA(n, r);
          return null;
        }
        hostSource() {
          const e = this.host();
          if (!e) return null;
          if (this.peek(":")) {
            if (!this.port()) return null;
            e.setPort(this.mCurValue);
          }
          return this.atEndOfPath() || this.path(e) ? e : null;
        }
        schemeSource() {
          if (!this.accept(a)) return null;
          for (; this.schemeChar(); );
          const e = this.mCurValue;
          return this.accept(_u)
            ? this.peek(l) || this.peek("*")
              ? null
              : new dA(e)
            : null;
        }
        sourceExpression() {
          const e = this.keywordSource();
          if (e) return e;
          const t = this.nonceSource();
          if (t) return t;
          const n = this.hashSource();
          if (n) return n;
          if ("*" === this.mCurToken) return new cA("*");
          this.resetCurChar(this.mCurToken);
          let r = "";
          const s = this.schemeSource();
          if (s) {
            if (this.atEnd()) return s;
            if (
              ((r = s.toString()),
              (r = r.replace(":", "")),
              !this.accept(wu) || !this.accept(wu))
            )
              return (
                console.warn(
                  "cspp: failedToParseUnrecognizedSource",
                  this.mCurToken
                ),
                null
              );
          }
          this.resetCurValue(),
            r ||
              (this.resetCurChar(this.mCurToken), (r = this.mSelfURI.scheme));
          const i = this.hostSource();
          return i
            ? (i.setScheme(r),
              i.setWithinFrameAncestorsDir(this.mParsingFrameAncestorsDir),
              i)
            : null;
        }
        sourceList() {
          let e = !1;
          const t = [];
          for (let n = 1; n < this.mCurDir.length; n++) {
            if (
              ((this.mCurToken = this.mCurDir[n]),
              this.resetCurValue(),
              r(this.mCurToken, Hu))
            ) {
              e = !0;
              continue;
            }
            const s = this.sourceExpression();
            s && t.push(s);
          }
          if (e)
            if (0 == t.length || (1 == t.length && t[0].isReportSample())) {
              const e = new lA(Hu);
              t.push(e);
            } else
              console.warn("cspp: ignoringUnknownOption", Hu, this.mCurDir[0]);
          return t;
        }
        reportURIList(e) {
          const t = [];
          for (let e = 1; e < this.mCurDir.length; e++) {
            let n, r;
            if (
              ((this.mCurToken = this.mCurDir[e]),
              !(n = Tn(this.mCurToken, this.mSelfURI)) || !(r = Zn(n)))
            ) {
              const e = this.mCurToken;
              console.warn("cspp: couldNotParseReportURI", e);
              continue;
            }
            const s = new hA(r);
            t.push(s);
          }
          if (0 !== t.length) e.addSrcs(t), this.mPolicy.addDirective(e);
          else {
            const e = this.mCurToken;
            console.warn("cspp: ignoringDirectiveWithNoValues", e);
          }
        }
        directiveValue() {
          return this.sourceList();
        }
        directive() {
          if (((this.mCurToken = this.mCurDir[0]), !this.mCurDir.length))
            return void console.warn(
              "cspp: failedToParseUnrecognizedSource - directive missing",
              this.mCurDir
            );
          let e = this.directiveName();
          if (!e) {
            if (fA.sIgnoreUnknownSources) return;
            if (!this.mCurDir[0]) return;
            e = new sA(yu, this.mCurDir);
          }
          if (d(this.mCurDir[0], Su)) return void this.reportURIList(e);
          if ((this.mPolicy.addDirective(e), e.equals(yu))) return;
          if (e.equals(Uu))
            return void (
              this.mCurDir.length > 1 &&
              console.warn(
                "cspp: ignoreSrcForDirective - block-all-mixed-content",
                e.getDirName(),
                this.mCurDir
              )
            );
          if (e.equals(Iu))
            return void (
              this.mCurDir.length > 1 &&
              console.warn(
                "cspp: ignoreSrcForDirective - upgrade-insecure-requests",
                e.getDirName(),
                this.mCurDir
              )
            );
          if (d(this.mCurDir[0], Zu)) return;
          (this.mHasHashOrNonce = !1),
            (this.mStrictDynamic = !1),
            (this.mHasAnyUnsafeEval = !1),
            (this.mUnsafeInlineKeywordSrc = void 0);
          const t = this.directiveValue();
          if (0 == t.length) {
            const e = new lA(Hu);
            t.push(e);
          }
          if (this.mStrictDynamic && !e.equals(ku)) {
            for (const e of t) {
              const t = e.toString();
              e.isKeyword(Xu) ||
                e.isKeyword(zu) ||
                e.isKeyword(Ju) ||
                e.isKeyword(qu) ||
                e.isNonce() ||
                e.isHash() ||
                console.warn("cspp: ignoringScriptSrcForStrictDynamic", t);
            }
            this.mHasHashOrNonce ||
              console.warn("cspp: strictDynamicButNoHashOrNonce", this.mCurDir);
          }
          this.mHasHashOrNonce &&
            this.mUnsafeInlineKeywordSrc &&
            (e.isDefaultDirective() ||
              e.equals(Ru) ||
              e.equals(Ou) ||
              e.equals(Fu) ||
              e.equals(xu) ||
              e.equals(Du) ||
              e.equals(ju)) &&
            console.warn(
              "cspp: ignoringSrcWithinNonceOrHashDirective - 'unsafe-inline'",
              this.mCurDir
            ),
            this.mHasAnyUnsafeEval &&
              (e.equals(Ou) || e.equals(Fu)) &&
              console.warn("cspp: ignoringUnsafeEval", this.mCurDir),
            e.addSrcs(t);
        }
        policy() {
          this.mPolicy = new pA();
          for (let e = 0; e < this.mTokens.length; e++)
            (this.mCurDir = this.mTokens[e]), this.directive();
          return (
            !this.mScriptSrc ||
              this.mWorkerSrc ||
              this.mChildSrc ||
              this.mScriptSrc.setRestrictWorkers(),
            this.mScriptSrc &&
              !this.mPolicy.hasDirective(Ou) &&
              this.mScriptSrc.setRestrictScriptElem(),
            this.mScriptSrc &&
              !this.mPolicy.hasDirective(Fu) &&
              this.mScriptSrc.setRestrictScriptAttr(),
            this.mPolicy
          );
        }
        static parseContentSecurityPolicy(e, t, n) {
          const r = new fA(e, t, n).policy();
          return r
            ? (r.setDeliveredViaMetaTagFlag(n),
              0 == r.getNumDirectives() ? null : r)
            : null;
        }
      }
      (fA.sCSPExperimentalEnabled = !0),
        (fA.sIgnoreUnknownSources = !0),
        (fA.sSecurityCspWasmUnsafeEvalEnabled = !0),
        (fA.sSecurityCspUnsafeHashesEnabled = !0),
        (fA.sSecurityCspScriptSrcAttrElemEnabled = !0),
        (fA.sSecurityCspStyleSrcAttrElemEnabled = !0),
        (fA.sSecurityCspEnableNavigateTo = !0);
      class mA {
        constructor() {
          this.mPolicies = [];
        }
        addPolicies(e) {
          this.mPolicies = [...e];
        }
        getPolicies() {
          return [...this.mPolicies];
        }
        getAllowsEval() {
          for (const e of this.mPolicies) if (!e.getAllowsEval()) return !1;
          return !0;
        }
        getAllowsInline(e, t, n, r, s, i, o, a, l) {
          for (const c of this.mPolicies)
            if (!c.getAllowsInline(e, t, n, r, s, i, o, a, l)) return !1;
          return !0;
        }
        toStrings() {
          return this.mPolicies.map((e) => e.toString());
        }
      }
      const gA = {},
        vA = {},
        _A = ("TM_" + Xt().substr(0, 5)).toLowerCase(),
        wA = [
          "content-security-policy",
          "x-content-security-policy",
          "x-webkit-csp",
        ],
        bA = "feature-policy",
        yA = "x-frame-options",
        kA = rt.extraHeaderNeeded,
        RA = (e, t) =>
          e
            .split(",")
            .map((e) => {
              let n, r, s, i;
              const o = [],
                a = [],
                l = e.split(";");
              let c, u;
              if (
                (l.forEach((e, t) => {
                  0 === e.search(/^\s*script-src /)
                    ? (r = t)
                    : 0 === e.search(/^\s*default-src /)
                    ? (s = t)
                    : 0 === e.search(/^\s*img-src /)
                    ? (i = t)
                    : 0 === e.search(/^\s*trusted-types /) ||
                      0 === e.search(/^\s*require-trusted-types-for /)
                    ? a.push(t)
                    : 0 === e.search(/^\s*frame-ancestors /) && o.push(t);
                }),
                void 0 !== s &&
                  void 0 === r &&
                  ((n = !0),
                  l.push(l[s].replace(/default-src /, "script-src ")),
                  (r = l.length - 1),
                  w.verbose("webRequest: add script-src CSP", t)),
                void 0 !== s &&
                  void 0 === i &&
                  ((n = !0),
                  l.push(l[s].replace(/default-src /, "img-src ")),
                  (i = l.length - 1),
                  w.verbose("webRequest: add img-src CSP", t)),
                void 0 !== i &&
                  ((u = !1),
                  (c = l[i]),
                  -1 == c.search(/data:/) &&
                    ((u = !0), (c = c.replace(/img-src /, "img-src data: "))),
                  -1 != c.search(/'none'/) &&
                    ((u = !0), (c = c.replace(/ 'none'/, ""))),
                  u &&
                    (w.verbose("webRequest: relaxing", l[i], " to ", c, t),
                    (l[i] = c),
                    (n = !0))),
                void 0 !== r &&
                  ((u = !1),
                  (c = l[r]),
                  -1 == c.search(/ 'unsafe-eval'(\s|$)/) &&
                    ((u = !0),
                    (c = c.replace(
                      /script-src /,
                      "script-src 'unsafe-eval' "
                    ))),
                  -1 != c.search(/ 'none'(\s|$)/) &&
                    ((u = !0), (c = c.replace(/ 'none'/, ""))),
                  u &&
                    (w.verbose("webRequest: relaxing", l[r], c, t),
                    (l[r] = c),
                    (n = !0))),
                void 0 !== s &&
                  ((u = !1),
                  (c = l[s]),
                  u && (w.verbose("webRequest: relaxing", c, t), (n = !0))),
                a.length)
              ) {
                for (const e of a) l[e] = "";
                n = !0;
              }
              return n ? l.filter((e) => e).join(";") : null;
            })
            .filter((e) => e)
            .join(",") || null,
        xA = (e) => {
          if (
            ((e) => {
              let t;
              return (
                Ge() >= 63 && (t = e.initiator),
                t && 0 !== (t + "/").indexOf(ze.getURL("/")) ? t : null
              );
            })(e)
          )
            return;
          const t = [];
          let n,
            r,
            s = e.requestHeaders || [];
          const i = {},
            o = new RegExp("^" + _A);
          return (
            (s = s.filter(
              (s) =>
                !s.name ||
                0 != s.name.search(o) ||
                ((r = s.name.replace(o, "")),
                (i[r.toLowerCase()] = !0),
                "internal" == r
                  ? (vA[e.requestId] = s.value)
                  : s.value && t.push({ name: r, value: ke(s.value) }),
                void (n = !0))
            )),
            n
              ? {
                  requestHeaders: s
                    .filter((e) => !e.name || !i[e.name.toLowerCase()])
                    .concat(t),
                }
              : void 0
          );
        },
        EA = (e) => {
          if (k.late)
            if ("main_frame" == e.type) {
              if (
                (hi.emit("reset", { tabId: e.tabId, early: !0 }),
                e.tabId > 0 &&
                  "POST" != e.method &&
                  "auto" == un.values.scriptUrlDetection &&
                  hd(e.url))
              )
                return (
                  w.verbose(
                    "webRequest: user script detected @ " +
                      e.url +
                      " -> open install page"
                  ),
                  vu
                    .installFromUrl(e.url, {}, { silent_fail: !0 })
                    .fail((t) => {
                      w.info(
                        "webRequest: user script detected @ " +
                          e.url +
                          " was invalid",
                        t ? t.messages : ""
                      ),
                        Je(e.tabId, { url: e.url + "#bypass=true" }, () => {});
                    }),
                  { redirectUrl: "javascript:history.back()" }
                );
            } else {
              let t, n;
              const r = dd(e);
              if (!r)
                return void w.error(
                  "webRequest: unable to determine tab sender",
                  e
                );
              if (
                (t = ((e, t) => {
                  var n;
                  const r = t.frameId;
                  if (void 0 !== r)
                    return null === (n = ic[e]) || void 0 === n
                      ? void 0
                      : n.requests[r];
                })(e.tabId, r)) &&
                (n = ((e, t) => {
                  let n = {};
                  const r = e.url;
                  return (
                    Object.keys(t).forEach((e) => {
                      const s = t[e];
                      Object.entries(s.rules).some(([e, t]) => {
                        let i, o, a;
                        if (!(i = t.selector) || !(o = t.action)) return;
                        const l = s.id + "/" + e;
                        if (
                          ((a = kd.get(l)) ||
                            ((a = wd({
                              inc: i.include,
                              match: i.match,
                              exc: i.exclude,
                            })),
                            kd.set(l, a)),
                          bd(r, a))
                        ) {
                          if (o.cancel)
                            return (
                              w.log(
                                "webRequest: request was canceled by script " +
                                  s.uuid,
                                r,
                                t,
                                s
                              ),
                              s.callback &&
                                s.callback({
                                  type: "cancel",
                                  details: { rule: t, url: r },
                                }),
                              (n = { cancel: !0 }),
                              !0
                            );
                          if (o.redirect) {
                            const { url: e, from: i, to: a } = o.redirect;
                            let l, c;
                            if (e) l = e;
                            else if (i && a && (c = r.match(i))) {
                              c.shift();
                              let e = a;
                              c.concat(["", "", ""]).forEach((t, n) => {
                                e = e.replace("$" + (n + 1), t || "");
                              }),
                                (l = e);
                            }
                            const u = (e) => {
                              w.warn(
                                "webRequest: error while request redirect by script " +
                                  s.uuid,
                                r,
                                t,
                                s
                              ),
                                s.callback &&
                                  s.callback({
                                    type: "redirect",
                                    message: "error",
                                    details: {
                                      description: e,
                                      rule: t,
                                      url: r,
                                      redirect_url: l,
                                    },
                                  });
                            };
                            if (!l)
                              return void u(
                                "unable to determine the redirect URL"
                              );
                            (l = Fn(l)),
                              eu.isAllowed(l)
                                ? vu.scriptWillRun(s.uuid, l)
                                  ? (w.log(
                                      "webRequest: request was redirected by script " +
                                        s.uuid,
                                      r,
                                      l,
                                      t,
                                      s
                                    ),
                                    s.callback &&
                                      s.callback({
                                        type: "redirect",
                                        details: {
                                          rule: t,
                                          url: r,
                                          redirect_url: l,
                                        },
                                      }),
                                    (n.redirectUrl = l))
                                  : u(
                                      "the redirect URL needs to be included by the scripts @include or @match tag"
                                    )
                                : u(
                                    "the redirect URL is filtered by the security settings"
                                  );
                          }
                        }
                      });
                    }),
                    n
                  );
                })(e, t))
              )
                return n;
            }
          else
            k.registerLateCallback(() => {
              EA(e);
            });
        },
        SA = (e) => {
          let t,
            n = !0;
          if (
            (R.Pledge()
              .then(() => {
                if (!k.late) {
                  const e = R();
                  return k.registerLateCallback(() => e.resolve()), e.promise();
                }
              })
              .then(() => {
                let n = e.responseHeaders || [];
                if ("xmlhttprequest" == e.type) {
                  let r, s;
                  if (vA[e.requestId]) {
                    if (!Oe.COOKIE_PASSTHROUGH) {
                      const e = [];
                      n = n
                        .map((t, n) => {
                          if (t.name && t.value) {
                            const r = t.name.toLowerCase();
                            if (r.startsWith(WA)) return void (s = !0);
                            "set-cookie" == r &&
                              (e.push({ name: `${WA}-${n}`, value: t.value }),
                              (s = !0));
                          }
                          return t;
                        })
                        .filter((e) => !!e)
                        .concat(e);
                    }
                    (r = gA[e.requestId]) &&
                      (n.push({
                        name: QA,
                        value: r,
                      }),
                      (s = !0)),
                      (t = s ? { responseHeaders: n } : null);
                  } else t = null;
                }
              })
              .then(() => {
                if (void 0 !== t) return;
                let r,
                  s,
                  i,
                  o,
                  a,
                  l,
                  c = e.responseHeaders || [];
                const u = un.values.webrequest_fixCSP,
                  A = GA && De,
                  d = A && "remove" == u,
                  h = A && ("yes" == u || m),
                  p = GA && m,
                  f = GA && m,
                  g = d || h || p || f,
                  v = g && Ge() >= 60,
                  _ = g && m;
                if (
                  (c.some((e) => {
                    if (!e.name) return;
                    const t = e.name.toLowerCase();
                    if (((s = s || "location" == t), g && wA.includes(t))) {
                      let t;
                      if (((i = !0), p && !l && (t = e.value))) {
                        const e = t.match(/'nonce-([^']+)'/);
                        l = e ? e[1] : void 0;
                      }
                    }
                    return v && (o = o || t == bA), _ && (a = a || t == yA), s;
                  }),
                  s)
                )
                  return (
                    w.verbose(
                      "webRequest: redirect found, skip script determination",
                      e
                    ),
                    void (t = null)
                  );
                const { tabId: b, url: y } = e,
                  k = dd(e);
                let x, E;
                const S = ud(e);
                if (!k)
                  return (
                    w.error("webRequest: unable to determine tab sender", e),
                    void (t = null)
                  );
                let C;
                return (
                  (E =
                    "xmlhttprequest" == e.type ? Pl(k, y, S) : yc(b, k, y, S)),
                  R.Pledge()
                    .then(() => {
                      if (f)
                        return Hl.acquire()
                          .then(() => "uninitialized")
                          .always(() => Hl.release())
                          .then((e) => {
                            C = e;
                          });
                    })
                    .then(() => {
                      if (
                        E &&
                        (p && l
                          ? (E.nonce = `n:${l}`)
                          : f && (E.nonce = `b:${C}`),
                        h || d || f)
                      ) {
                        const { runners: e, contexters: t } = E;
                        x = e.length + t.length > 0;
                      }
                      if (x && (i || o || a)) {
                        const t = [];
                        if (
                          (c.forEach((n, s) => {
                            if (!n.name || !n.value) return;
                            const l = n.name.toLowerCase();
                            if (i && wA.includes(l))
                              for (const e of n.value.split(",")) {
                                const r = { name: n.name, value: e };
                                t.push({ i: s, item: r });
                              }
                            if (o && l == bA)
                              if (d)
                                (r = !0),
                                  (c[s] = { name: n.name, value: void 0 });
                              else {
                                const t = ((e, t) => {
                                  let n, r;
                                  const s = e.split(";");
                                  let i, o;
                                  return (
                                    s.forEach((e, t) => {
                                      0 === e.search(/^\s*sync-xhr /) &&
                                        (r = t);
                                    }),
                                    void 0 !== r &&
                                      ((o = !1),
                                      (i = s[r]),
                                      -1 != i.search(/'none'/) &&
                                        ((o = !0),
                                        (i = i.replace(/ 'none'/, " *"))),
                                      o &&
                                        (w.verbose(
                                          "webRequest: relaxing",
                                          s[r],
                                          i,
                                          t
                                        ),
                                        (s[r] = i),
                                        (n = !0))),
                                    n ? s.join(";") : null
                                  );
                                })(n.value, e);
                                t &&
                                  ((r = !0),
                                  (c[s] = { name: n.name, value: t }));
                              }
                            a &&
                              l == yA &&
                              (c[s] = { name: n.name, value: void 0 });
                          }),
                          d)
                        )
                          t.forEach(({ i: e, item: t }) => {
                            (r = !0), (c[e] = { name: t.name, value: void 0 });
                          });
                        else if (f) {
                          const n = t.map(({ item: e }) => e.value || "");
                          let s, i, o;
                          if (
                            (s = Zn(e.url)) &&
                            (i = ve(`${s.hostname}#${C}`)) &&
                            (o = ((e, t, n) => {
                              const r = Zn(t.url);
                              if (!r)
                                return (
                                  w.verbose(
                                    `webRequest: unable to parse URL ${t.url}`
                                  ),
                                  null
                                );
                              const s = e.map((e) => {
                                  const t = nA.tokenizeCSPPolicy(e);
                                  return (
                                    fA.parseContentSecurityPolicy(t, r, !1) ||
                                    (w.verbose(
                                      `webRequest: unable to parse CSP ${e}`
                                    ),
                                    null)
                                  );
                                }),
                                i = s.filter((e) => null !== e),
                                o = new mA();
                              o.addPolicies(i);
                              const a = ((e, t) => {
                                if (
                                  e.getAllowsInline(
                                    Ou,
                                    !1,
                                    "",
                                    !1,
                                    null,
                                    null,
                                    "",
                                    0,
                                    0
                                  )
                                )
                                  return;
                                if (
                                  e.getAllowsInline(
                                    Ou,
                                    !1,
                                    t,
                                    !1,
                                    null,
                                    null,
                                    "",
                                    0,
                                    0
                                  )
                                )
                                  return !1;
                                const n = e.getPolicies();
                                for (const e of n)
                                  e.getAllowsInline(
                                    Ou,
                                    !1,
                                    t,
                                    !1,
                                    null,
                                    null,
                                    "",
                                    0,
                                    0
                                  ) || e.addNonce(t);
                                return !0;
                              })(o, n);
                              if (a) {
                                let t = 0;
                                const n = o.toStrings();
                                return n.length != i.length
                                  ? (w.verbose(
                                      "webRequest: internal error on adding nonce to CSP",
                                      e
                                    ),
                                    null)
                                  : s.map((r, s) =>
                                      null === r ? e[s] : n[t++]
                                    );
                              }
                              return null;
                            })(n, e, i))
                          ) {
                            const e = {},
                              n = o;
                            t.forEach(({ item: t, i: r }, s) => {
                              const i = n[s];
                              e[r]
                                ? (c[r].value += "," + i)
                                : (c[r] = { name: t.name, value: i }),
                                (e[r] = !0);
                            }),
                              (r = !0);
                          }
                        } else {
                          const n = {};
                          t.forEach(({ i: t, item: s }) => {
                            if (!s.name || !s.value) return;
                            const i = RA(s.value, e);
                            null === i ||
                              ("" === i
                                ? ((r = !0),
                                  (c[t] = { name: s.name, value: void 0 }))
                                : (n[t]
                                    ? (c[t].value += "," + i)
                                    : (c[t] = { name: s.name, value: i }),
                                  (r = !0),
                                  (n[t] = !0)));
                          });
                        }
                      }
                    })
                    .then(() => {
                      let t, n;
                      if (
                        Te.FAST_EXEC_SUPPORT &&
                        ["instant"].includes(un.values.runtime_inject_mode) &&
                        (t = kc(b, k, y, S)) &&
                        "runners" in t &&
                        (n = Zn(y))
                      ) {
                        const s = n.pathname + n.search,
                          i =
                            "TM_" +
                            qe.short_id +
                            he(s.length + s)
                              .substr(0, 255)
                              .replace(/[#=/]/g, "_") +
                            Date.now(),
                          o = Ll(t, y, S, e.cookieStoreId),
                          a = JSON.stringify(o),
                          l = new Blob([a], { type: "binary/octet-stream" }),
                          u = URL.createObjectURL(l);
                        ((e, t, n) => {
                          uc(e).objurl[t.id] = n;
                        })(b, k, u),
                          c.push({
                            name: "set-cookie",
                            value: i + "=" + z(u) + "; max-age=15;",
                          }),
                          (r = !0);
                      }
                    })
                    .then(() => {
                      if (
                        x &&
                        n &&
                        rt.filterResponseData &&
                        (d || h) &&
                        "yes" == un.values.webrequest_fixContentCSP &&
                        ["main_frame", "sub_frame"].includes(e.type)
                      ) {
                        let t;
                        if (
                          (c.some((e) => {
                            if (e.name && e.value)
                              return "content-type" == e.name.toLowerCase() &&
                                "text/html" ==
                                  e.value.split(";")[0].toLowerCase().trim()
                                ? ((t = !0), !0)
                                : void 0;
                          }),
                          t)
                        ) {
                          const t = rt.filterResponseData(e.requestId);
                          (t.ondata = (n) => {
                            const r = new O("x-user-defined").decode(n.data, {
                                stream: !0,
                              }),
                              s = new RegExp(
                                '(<head>[\\s\\S]*)(<meta[^>]+http-equiv="(?:' +
                                  wA.join("|") +
                                  ')"[^>]*>)([\\s\\S]*?<\\/head>)',
                                "i"
                              );
                            let i;
                            const o = r.replace(s, (t, n, r, s) => {
                              const o = new RegExp('(content=")([^">]+)(")');
                              return (
                                n +
                                r.replace(o, (t, n, r, s) => {
                                  const o = RA(r || "", e);
                                  return (
                                    null !== o && (i = !0), n + (o || r) + s
                                  );
                                }) +
                                s
                              );
                            });
                            i ? t.write(me(o)) : t.write(n.data),
                              t.disconnect();
                          }),
                            (t.onstop = () => {
                              t && t.disconnect();
                            });
                        }
                      }
                      r
                        ? ((c = c.filter((e) => void 0 !== e.value)),
                          (t = { responseHeaders: c }))
                        : (t = null);
                    })
                );
              }),
            (n = !1),
            void 0 !== t)
          )
            return t || void 0;
        },
        CA = (e) => {
          const t = e.redirectUrl;
          if (t) {
            if (((gA[e.requestId] = t), vA[e.requestId])) {
              const { tabId: n } = e,
                r = dd(e);
              if (!r)
                return void w.warn(
                  "webRequest: unable to determine tab sender",
                  e
                );
              di.emit("onRequestRedirect", { tabId: n, sender: r, url: t });
            }
          } else w.warn("webRequest: onBeforeRedirect without redirectUrl", e);
        },
        MA = (e) => {
          const {
            type: t,
            tabId: n,
            url: r,
            cookieStoreId: s,
            requestId: i,
          } = e;
          if (k.late)
            if ("xmlhttprequest" == t) delete vA[i], delete gA[i];
            else {
              const t = dd(e);
              if (!t)
                return void w.warn(
                  "webRequest: unable to determine tab sender",
                  e
                );
              hi.emit("response", {
                tabId: n,
                sender: t,
                url: r,
                cookieStoreId: s,
                incognito: ud(e),
              });
            }
          else
            k.registerLateCallback(() => {
              MA(e);
            });
        },
        IA = (e) => {
          const { type: t, tabId: n, requestId: r } = e;
          "xmlhttprequest" == t
            ? (delete vA[r], delete gA[r])
            : "main_frame" == t
            ? hi.emit("reset", { tabId: n, early: !0 })
            : w.warn("webRequest: unexpected request type", e);
        },
        GA = !0,
        UA = GA ? ["blocking"] : [],
        ZA = ["http://*/*", "https://*/*", "ftp://*/*", "file:///*"].concat(
          Te.WEBREQUEST_WEBSOCKET ? ["ws://*/*", "wss://*/*"] : []
        ),
        TA = (e) => {
          try {
            e ||
              (Te.WEBREQUEST_XHR_SUPPORT &&
                "no" != un.values.webrequest_modHeaders &&
                rt.onBeforeSendHeaders.addListener(
                  xA,
                  { urls: ZA, types: ["xmlhttprequest"] },
                  [...UA, "requestHeaders", ...(kA ? ["extraHeaders"] : [])]
                )),
              e &&
                (rt.onBeforeRequest.addListener(
                  EA,
                  {
                    urls: ZA,
                    types: [
                      "main_frame",
                      "sub_frame",
                      "script",
                      "xmlhttprequest",
                      ...(Te.WEBREQUEST_WEBSOCKET ? ["websocket"] : []),
                    ],
                  },
                  [...UA]
                ),
                rt.onHeadersReceived.addListener(
                  SA,
                  {
                    urls: ZA,
                    types: ["main_frame", "sub_frame", "xmlhttprequest"],
                  },
                  [...UA, "responseHeaders", ...(kA ? ["extraHeaders"] : [])]
                ),
                Te.WEBREQUEST_XHR_SUPPORT &&
                  rt.onBeforeRedirect.addListener(
                    CA,
                    { urls: ZA, types: ["xmlhttprequest"] },
                    []
                  ),
                rt.onResponseStarted.addListener(
                  MA,
                  {
                    urls: ZA,
                    types: ["main_frame", "sub_frame", "xmlhttprequest"],
                  },
                  []
                ),
                rt.onErrorOccurred.addListener(IA, {
                  urls: ZA,
                  types: ["main_frame", "xmlhttprequest"],
                })),
              rt.handlerBehaviorChanged();
          } catch (e) {
            w.warn("webRequest: error initializings", e.message);
          }
        };
      const BA = {},
        OA = [
          "arraybuffer",
          "blob",
          "document",
          "json",
          "xml",
          "headers",
          "stream",
        ];
      let FA = {};
      const DA = (e) =>
          ["https:", "http:", "data:", "blob"].some((t) => e.startsWith(t)),
        jA = [
          "internal",
          "user-agent",
          "accept-charset",
          "accept-encoding",
          "access-control-request-headers",
          "access-control-request-method",
          "connection",
          "content-length",
          "cookie",
          "cookie2",
          "date",
          "dnt",
          "expect",
          "host",
          "keep-alive",
          "origin",
          "referer",
          "te",
          "trailer",
          "transfer-encoding",
          "upgrade",
          "via",
        ],
        PA = { "cache-control": "no-cache", pragma: "no-cache" },
        LA = { "cache-control": "max-age=0, must-revalidate" },
        NA = (e) => {
          const t = {};
          return (
            Object.keys(e).forEach((n) => {
              let r = n,
                s = e[n];
              if (FA.prefix)
                (i = n.toLowerCase()),
                  (jA.includes(i) ||
                    0 === i.indexOf("proxy-") ||
                    0 === i.indexOf("sec-")) &&
                    ((r = FA.prefix + n), (s = null === s ? "" : ye(s)));
              else if (null === s) return;
              var i;
              t[r] = s;
            }),
            { forbidden: {}, regular: t }
          );
        },
        VA = (e) => ({
          responseText: "",
          response: null,
          readyState: 4,
          responseHeaders: "",
          status: 0,
          statusText: "",
          error: (e = e || "Forbidden"),
        }),
        zA = (e) => {
          if ("Blob" === e.type) return new Blob([me(e.value)]);
          if ("File" === e.type) {
            if (!e.name) return;
            return new File([me(e.value)], e.name, {
              type: e.meta,
              lastModified: e.lastModified || Date.now(),
            });
          }
          if ("FormData" == e.type) {
            const t = new FormData();
            return (
              Object.keys(e.value).forEach((n) => {
                const r = "Array" === e.value[n].type,
                  s = zA(e.value[n]),
                  i = r ? s : [s];
                i.forEach((e, r) => {
                  t.append(n, i[r]);
                });
              }),
              t
            );
          }
          if ("URLSearchParams" === e.type) return new URLSearchParams(e.value);
          if ("Array" === e.type || "Object" === e.type) {
            let t, n, r;
            "Object" === e.type
              ? ((r = Object.keys(e.value)),
                (n = (e) => (e < r.length ? r[e] : null)),
                (t = {}))
              : ((n = (t) => (t < e.value.length ? t : null)), (t = []));
            for (let r, s = 0; null !== (r = n(s)); s++) t[r] = zA(e.value[r]);
            return t;
          }
          return e.value;
        },
        qA = (e) => {
          const t = {};
          return (
            e &&
              e.split("\n").forEach((e) => {
                const n = e.match(/^([^:]+): ?(.*)/);
                if (n) {
                  const e = n[1].toLowerCase();
                  t[e] =
                    (void 0 !== t[e] ? ", " : "") +
                    (n[2] || "").replace(/,/g, "%2C");
                }
              }),
            t
          );
        },
        HA = (e, t, n) => {
          const r = { ...(t || {}) },
            s = async (e, t) => {
              const n = r[e];
              n && n("function" == typeof t ? await t() : t);
            },
            i = async (e, t) => {
              r[e] && (await s(e, t), (r[e] = void 0));
            };
          if (!(n = n || {}).internal && !DA(e.url)) {
            w.warn("xhr: invalid scheme of url:", e.url);
            const t = VA("Invalid scheme");
            return i("onerror", t), void i("ondone", t);
          }
          const o =
              void 0 !== e.responseType ? e.responseType.toLowerCase() : void 0,
            a = e.url && "http" == e.url.substr(0, 4),
            l =
              (!FA.mozAnon && e.anonymous) ||
              "stream" == o ||
              (e.redirect && "follow" !== e.redirect),
            c = e.fetch;
          if ("stream" == o && !a) {
            w.warn(
              "xhr: stream reqponse requested, but fetch is not available"
            );
            const e = VA("No fetch support");
            return i("onerror", e), void i("ondone", e);
          }
          return a && (l || c)
            ? XA(e, r, n, e.retries || 0, i, s)
            : YA(e, r, n, e.retries || 0, i, s);
        },
        QA = "tm-finalurl" + Pe.short_id.toLowerCase(),
        WA = "tm-setcookie" + Pe.short_id.toLowerCase(),
        XA = (e, t, n, r, s, i) => {
          const o = ee;
          let a, l, c, u, A;
          const d = (e, t, n) => {
              const r = [];
              let s;
              const i = n || e.headers;
              if (i) {
                const t = [],
                  n = [];
                i.forEach((e, i) => {
                  const o = i.toLowerCase();
                  o.startsWith(WA)
                    ? t.push(e)
                    : "set-cookie" === o
                    ? n.push(e)
                    : o === QA
                    ? (s = e)
                    : r.push(o + ":" + e);
                }),
                  (s = s || e.url),
                  (t.length ? t : n).forEach((e) => r.push("set-cookie:" + e));
              }
              const o = void 0 === t ? 4 : t,
                a = e.status || 0,
                l = e.statusText || "";
              return {
                readyState: o,
                responseHeaders: r.join("\n"),
                finalUrl: s,
                status: a,
                statusText: l,
              };
            },
            h = (e) => {
              let t;
              u && u(),
                l ||
                  (c
                    ? ((t = d({ status: 408, statusText: "Request Timeout" })),
                      s("ontimeout"))
                    : "AbortError" == (null == e ? void 0 : e.name)
                    ? ((t = VA("aborted")), s("onabort", t))
                    : ((t = d({
                        status: 408,
                        statusText:
                          (null == e ? void 0 : e.message) || "Request Timeout",
                      })),
                      s("onerror", t)),
                  (l = !0),
                  s("ondone", t));
            },
            p = e.responseType ? e.responseType.toLowerCase() : "";
          if ("document" == p && !o)
            return void h({
              name: "Error",
              message: "response type not supported",
            });
          const f = async (e, t, r) => {
            let s;
            if (r) s = e;
            else {
              const t = e;
              if (
                !n.no_blob &&
                (Te.SHARED_BLOBS ||
                  (Te.SHARED_OBJECT_URLS && !n.foreign_context))
              ) {
                const e = new Rs({ blob: t });
                return (
                  i("onpartial", { tfd: await e.toTransferableData() }),
                  void X(() => e.dispose(), 3e5)
                );
              }
              s = await be(e);
            }
            const o = Yt(s, t);
            o.forEach((e, t) => {
              i("onpartial", { partial: e, index: t, length: o.length });
            });
          };
          let m = !1;
          const g = (e) => {
            e && (c = !0),
              v
                ? v.abort()
                : c
                ? h()
                : h({ name: "AbortError", message: "Aborted by user" });
          };
          let v;
          return (
            (async () => {
              try {
                const c = {};
                c.method = e.method || "GET";
                const _ = Zn(e.url);
                let b, y;
                if (_) {
                  let t = !1;
                  _.username && ((e.user = e.user || _.username), (t = !0)),
                    _.password &&
                      ((e.password = e.password || _.password), (t = !0)),
                    (b = t ? Bn(_) : e.url);
                } else b = e.url;
                if (e.headers) {
                  const { forbidden: t, regular: n } = NA(e.headers);
                  y = { ...n, ...t };
                }
                if (e.redirect && "follow" !== e.redirect) {
                  c.redirect = e.redirect;
                  {
                    const { responseHeaders: e, done: t } = await (async (
                      e
                    ) => {
                      const t = BA[e];
                      t && (await t);
                      const n = Zn(e);
                      0;
                      let r, s, i;
                      if (n && n.protocol.startsWith("http")) {
                        const t = n ? Bn(n) : e;
                        let o, a, l;
                        (r = new Promise((e) => (l = e))),
                          (s = (e) => {
                            var n;
                            if (
                              (e.initiator ||
                                (e.originUrl &&
                                  (null === (n = Zn(e.originUrl)) ||
                                  void 0 === n
                                    ? void 0
                                    : n.origin))) == $ &&
                              (e.url === t || e.requestId === o) &&
                              l
                            ) {
                              o = e.requestId;
                              let t = e.responseHeaders || [];
                              const n = [];
                              let r = !1,
                                s = 0;
                              (t = t
                                .map((e, t) => {
                                  if (e.name) {
                                    const i = e.name.toLowerCase();
                                    if (i.startsWith(WA)) return;
                                    "set-cookie" == i
                                      ? n.push({
                                          name: `${WA}-${t + s}`,
                                          value: e.value,
                                        })
                                      : "location" == i && (r = !0);
                                  }
                                  return e;
                                })
                                .filter((e) => !!e)
                                .concat(n)),
                                t.push({ name: QA, value: e.url }),
                                l(t);
                            }
                          }),
                          (i = (e) => {
                            e.requestId === o && (a = e.redirectUrl || a);
                          }),
                          rt.onHeadersReceived.addDynamicListener(
                            s,
                            { urls: ZA, types: ["xmlhttprequest"] },
                            [
                              "responseHeaders",
                              ...(rt.extraHeaderNeeded ? ["extraHeaders"] : []),
                            ]
                          ),
                          rt.onBeforeRedirect.addDynamicListener(
                            i,
                            { urls: ZA, types: ["xmlhttprequest"] },
                            []
                          );
                      }
                      const o = async () => {
                        if (!a) return;
                        const t = a;
                        (a = void 0),
                          s && rt.onHeadersReceived.removeListener(s),
                          i && rt.onBeforeRedirect.removeListener(i),
                          delete BA[e],
                          t();
                      };
                      let a;
                      X(o, 6e4);
                      const l = new Promise((e) => (a = e));
                      return (BA[e] = l), { done: o, responseHeaders: r };
                    })(b);
                    t &&
                      (u = () => {
                        t(), (u = void 0);
                      }),
                      e && (A = e);
                  }
                }
                e.nocache
                  ? (c.cache = "reload")
                  : e.revalidate &&
                    ((c.cache = "default"),
                    (y = y || {}),
                    (y = { ...y, ...LA })),
                  e.anonymous
                    ? (c.credentials = "omit")
                    : (c.credentials = "include"),
                  e.user &&
                    e.password &&
                    ((y = y || {}),
                    (y.Authorization =
                      "Basic " + j(e.user + ":" + e.password))),
                  y && (c.headers = new Headers(y)),
                  void 0 !== e.data &&
                    null !== e.data &&
                    ("typified" === e.data_type
                      ? (c.body = zA(e.data))
                      : "string" == typeof e.data
                      ? (c.body = e.data)
                      : (c.body = JSON.stringify(e.data))),
                  (v = T ? new T() : void 0),
                  v && (c.signal = v.signal),
                  s("onloadstart", d({ status: 0, statusText: "" }, 1)),
                  J(b, c)
                    .then(async (c) => {
                      var h;
                      let g;
                      if ((a && (L(a), (a = null)), A)) {
                        const e = await Promise.race([A, x(5e3)]);
                        if (e) {
                          g = ((e) => {
                            const t = new Headers();
                            for (const [n, r] of e.entries()) t.append(n, r);
                            return t;
                          })(c.headers);
                          for (const t of e)
                            void 0 !== t.value && g.set(t.name, t.value);
                        }
                      }
                      if ((u && u(), l)) return;
                      let v = d(c, void 0, g);
                      if (
                        v.status > 0 &&
                        (v.status < 200 || v.status >= 300) &&
                        r > 0
                      )
                        return void XA(e, t, n, r - 1, s, i);
                      const {
                        partialSize: _,
                        overrideMimeType: b,
                        responseType: y,
                      } = e;
                      if (
                        (i("onreadystatechange", d(c, 2, g)), "stream" == p)
                      ) {
                        let t;
                        if (c.ok) {
                          if (
                            (t =
                              null === (h = c.body) || void 0 === h
                                ? void 0
                                : h.getReader())
                          )
                            for (;;) {
                              const { done: n, value: r } = await t.read();
                              if (r) {
                                const t = new Blob([r]);
                                await f(t, parseInt(e.partialSize), !1);
                              }
                              if (n) break;
                            }
                        } else
                          try {
                            const t = await c.text(),
                              n = new Blob([t]);
                            await f(n, parseInt(e.partialSize), !1);
                          } catch (e) {}
                      } else if (c.ok)
                        if (_) {
                          let t;
                          ["arraybuffer", "blob"].includes(p) || void 0 !== b
                            ? ((v.response = await c.blob()), (t = !1))
                            : ((v.response = await c.text()), (t = !0)),
                            (v = await (async (t, n) => {
                              if (e.partialSize) {
                                const r = t.response;
                                [
                                  "response",
                                  "responseText",
                                  "responseXML",
                                ].forEach((e) => {
                                  delete t[e];
                                }),
                                  !m &&
                                    r &&
                                    ((m = !0),
                                    await f(r, parseInt(e.partialSize), n));
                              }
                              return t;
                            })(v, t));
                        } else if (void 0 !== y) {
                          let e;
                          if ("arraybuffer" == p)
                            v.response = await c.arrayBuffer();
                          else if ("blob" == p) v.response = await c.blob();
                          else if ("document" == p) {
                            e = (
                              qA(v.responseHeaders)["content-type"] ||
                              "text/xml"
                            )
                              .toString()
                              .split(";")[0];
                            const t = new o();
                            v.response = t.parseFromString(await c.text(), e);
                          } else if ("json" == p) {
                            const e = await c.text();
                            v.response = JSON.parse(e);
                          } else
                            w.warn(
                              "xhr: responseType",
                              p,
                              " is not implemented!"
                            ),
                              (v.responseText = v.response = await c.text());
                        } else if (void 0 !== b && O) {
                          const e = await c.arrayBuffer(),
                            t = (b.toLowerCase().match(/charset=([^;]+)/) ||
                              [])[1];
                          v.responseText = v.response = new O(t).decode(e);
                        } else {
                          const e = await c.text();
                          v.responseText = v.response = e;
                        }
                      else if (
                        ((v.responseXML = void 0),
                        "follow" !== e.redirect && "opaqueredirect" == c.type)
                      )
                        (v.responseText = v.response = void 0),
                          (v.status = 301);
                      else
                        try {
                          v.responseText = v.response = await c.text();
                        } catch (e) {}
                      s("onreadystatechange", v),
                        s("onload", v),
                        s("ondone", v);
                    })
                    .catch(h),
                  void 0 !== e.timeout &&
                    null !== e.data &&
                    (a = X(() => {
                      (a = null), g(!0);
                    }, e.timeout));
              } catch (e) {
                u && u();
                const t = e;
                w.error(t.message, t.stack);
                const n = VA(t.message);
                s("onerror", n), s("ondone", n);
              }
            })(),
            { abort: () => g() }
          );
        },
        YA = (e, t, n, r, s, i) => {
          const o = e.responseType ? e.responseType.toLowerCase() : "";
          let a, l;
          e.anonymous && (a = FA.mozAnon ? { mozAnon: !0 } : { anonymous: !0 });
          const c = new ue(a),
            u = (t) => {
              let n = "",
                r = e.url;
              if (c.readyState >= 2) {
                let e;
                (n = c.getAllResponseHeaders()),
                  n &&
                    ((n = n.replace(
                      /tm-finalurl[0-9a-zA-Z]*: .*[\r\n]{1,2}/i,
                      ""
                    )),
                    (n = n.replace(
                      /tm-setcookie[0-9a-zA-Z]+-[0-9]+:/i,
                      "set-cookie:"
                    ))),
                  (e = c.getResponseHeader(QA) || c.responseURL) && (r = e);
              }
              const s = {
                readyState: c.readyState,
                responseHeaders: n,
                finalUrl: r,
                status: c.readyState >= 2 ? c.status : 0,
                statusText: c.readyState >= 2 ? c.statusText : "",
              };
              return (
                t && 4 == c.readyState
                  ? c.responseType
                    ? ((s.responseXML = void 0),
                      (s.responseText = void 0),
                      (s.responseType = c.responseType),
                      (s.response = c.response))
                    : ((s.responseXML = c.responseXML || void 0),
                      (s.responseText = c.responseText),
                      (s.response = c.response))
                  : ((s.responseXML = void 0),
                    (s.responseText = ""),
                    (s.response = void 0)),
                s
              );
            };
          let A = !1;
          const d = async (t) => {
              if (e.partialSize) {
                const r = t.response,
                  s = !["arraybuffer", "blob"].includes(o);
                ["response", "responseText", "responseXML"].forEach((e) => {
                  delete t[e];
                }),
                  !A &&
                    r &&
                    ((A = !0),
                    await (async (e, t, r) => {
                      let s;
                      if (r) s = e;
                      else {
                        const t = e;
                        if (
                          !n.no_blob &&
                          (Te.SHARED_BLOBS ||
                            (Te.SHARED_OBJECT_URLS && !n.foreign_context))
                        ) {
                          const e = new Rs({ blob: t });
                          return (
                            i("onpartial", {
                              tfd: await e.toTransferableData(),
                            }),
                            void X(() => e.dispose(), 3e5)
                          );
                        }
                        s = await be(e);
                      }
                      const o = Yt(s, t);
                      o.forEach((e, t) => {
                        i("onpartial", {
                          partial: e,
                          index: t,
                          length: o.length,
                        });
                      });
                    })(r, parseInt(e.partialSize), s));
              }
              return t;
            },
            h = I({ threads: 1 }),
            p = (e) => (t) => h.add(() => e(t)),
            f = {
              onload: p(async () => {
                let o = u(!0);
                o.status > 0 && (o.status < 200 || o.status >= 300) && r > 0
                  ? YA(e, t, n, r - 1, s, i)
                  : (e.partialSize && (o = await d(o)),
                    await s("onload", o),
                    4 == o.readyState && (await s("ondone", o)));
              }),
              onerror: p(async () => {
                const o = u();
                4 == o.readyState && 200 != o.status && 0 != o.status && r > 0
                  ? YA(e, t, n, r - 1, s, i)
                  : (await s("onerror", o), await s("ondone", o));
              }),
              onloadstart: p(async () => {
                await i("onloadstart", () => u());
              }),
              onreadystatechange: p(async () => {
                await i("onreadystatechange", async () => {
                  let e = u();
                  return (e = await d(e)), e;
                });
              }),
              onprogress: p(async (e) => {
                await i("onprogress", async () => {
                  let t = u();
                  return (t = await d(t)), v(e, t);
                });
              }),
              ontimeout: p(async () => {
                const e = u();
                await s("ontimeout"), await s("ondone", e);
              }),
              onabort: p(async () => {
                const e = VA("aborted");
                await s("onabort"), await s("ondone", e);
              }),
            },
            m = {
              onuploadprogress: p(async (e) => {
                await i("onuploadprogress", async () => v(e));
              }),
            },
            g =
              0 ==
              Object.keys(f)
                .concat(["ondone"])
                .filter((e) => !!t[e]).length;
          if (g) throw new Error("Synchronous XHR is not supported anymore");
          const v = (e, t) => {
              let n, r, s, i, o, a;
              try {
                if (e.lengthComputable || e.total > 0)
                  (n = e.loaded), (r = e.total);
                else if (t) {
                  const s =
                    !c.responseType || ["", "text"].includes(c.responseType)
                      ? c.responseText
                      : null;
                  let i = Number(qA(t.responseHeaders)["content-length"] || "");
                  const o = t.readyState > 2 && s ? s.length : 0;
                  0 == i && (i = -1), (n = e.loaded || o), (r = e.total || i);
                }
                (i = e.lengthComputable), (s = n), (o = n), (a = r);
              } catch (e) {}
              return Object.assign(t || {}, {
                lengthComputable: i,
                loaded: s,
                done: n,
                position: o,
                total: r,
                totalSize: a,
              });
            },
            _ = ["ontimeout", "onload", "onerror", "onabort"];
          Object.keys(f).forEach((e) => {
            (t[e] || _.includes(e)) && (c[e] = f[e]);
          });
          const b = { onuploadprogress: "onprogress" };
          c.upload &&
            Object.keys(m).forEach((e) => {
              const n = b[e];
              n && t[e] && (c.upload[n] = m[e]);
            });
          try {
            if (!n.internal && !DA(e.url))
              throw new Error("Invalid scheme of url: " + e.url);
            let t;
            if (
              (c.open(e.method || "GET", e.url, !g, e.user, e.password),
              e.headers)
            ) {
              const { forbidden: n, regular: r } = NA(e.headers);
              t = { ...r, ...n };
            }
            (e.nocache || e.revalidate) &&
              ((t = t || {}),
              e.nocache
                ? (t = { ...t, ...PA })
                : e.revalidate && (t = { ...t, ...LA })),
              t &&
                Object.keys(t).forEach((e) => {
                  try {
                    c.setRequestHeader(e, t[e]);
                  } catch (n) {
                    w.warn("xhr: rejected header", e, t[e]);
                  }
                }),
              void 0 !== e.overrideMimeType &&
                c.overrideMimeType(e.overrideMimeType),
              e.partialSize
                ? ["arraybuffer", "blob"].includes(o)
                  ? (c.responseType = e.responseType = "blob")
                  : delete e.responseType
                : void 0 !== e.responseType &&
                  ((l = e.responseType.toLowerCase()),
                  "xml" != l &&
                    "headers" != l &&
                    "stream" != l &&
                    (c.responseType = l)),
              void 0 !== e.timeout && (c.timeout = e.timeout),
              void 0 !== e.data
                ? "typified" === e.data_type
                  ? c.send(zA(e.data))
                  : "string" == typeof e.data
                  ? c.send(e.data)
                  : c.send(JSON.stringify(e.data))
                : c.send();
          } catch (e) {
            const t = e;
            w.error(t.stack);
            const n = VA(t.message);
            s("onerror", n), s("ondone", n);
          }
          return {
            abort: function () {
              c.abort();
            },
          };
        },
        JA = () => FA;
      let KA,
        $A,
        ed,
        td,
        nd = {};
      const rd = "runtime_host_permissions",
        sd = () =>
          x(1)
            .then(
              () =>
                !bt.supported ||
                (0, Mi.has)("<all_urls>").then(
                  (e) => e,
                  () => !0
                )
            )
            .always((e) => {
              e
                ? $s.removeAll(rd)
                : ($s.all("status", {
                    key: rd,
                    id: rd,
                    class: "warning",
                    text: Dr.getMessage(
                      "Limited_runtime_host_permissions_might_break_some_Tampermonkey_features_"
                    ),
                    timeout: 31536e6,
                  }),
                  void 0 === KA &&
                    di.on("onRequestRedirect", ({ url: e }) => {
                      od(e, 1e3);
                    })),
                (KA = e),
                (ed = void 0);
            });
      let id;
      const od = (e, t) => {
          if (
            (id ||
              (id = X(() => {
                (id = void 0),
                  R.Pledge()
                    .then(() => {
                      if (void 0 === KA)
                        return (
                          $A ||
                            (Mi.addListener((e) => {
                              w.info("pcx: detected permission change", e),
                                (KA = void 0),
                                (ed = sd());
                            }),
                            ($A = !0)),
                          (ed = ed || sd()),
                          ed
                        );
                    })
                    .then(() => td)
                    .then(() => {
                      const e = Object.values(nd);
                      if (((nd = {}), KA)) return e;
                      {
                        const t = {},
                          n = e.map((e) => {
                            const n = Zn(e.url);
                            if (n && ["data:", "blob:"].includes(n.protocol))
                              return R.Pledge();
                            const r = ((e) =>
                              ((e) => {
                                const t = "string" == typeof e ? Zn(e) : e;
                                if (!t) throw new Error("invalid url");
                                return Bn(t, { nopath: !0 });
                              })(e) + "/*")(n || e.url);
                            return Mi.hasOrigin(r).then((e) => {
                              e || (t[r] = !0);
                            });
                          }),
                          r = (td = R.sidebyside(n)
                            .then(() => {
                              const n = Object.keys(t);
                              return n.length
                                ? (w.info(
                                    "pcx: need to ask for some permissions",
                                    n
                                  ),
                                  Mi.askOrigin(
                                    n,
                                    Dr.getMessage(
                                      "Cross_Origin_Request_Permission"
                                    ),
                                    Dr.getMessage(
                                      "Click_here_to_allow_TM_to_access_the_following_hosts_0host_list0",
                                      n.join("\n")
                                    )
                                  ).then(() => ((td = void 0), e)))
                                : e;
                            })
                            .always(() => {
                              td = void 0;
                            }));
                        return r;
                      }
                    })
                    .always((e) => {
                      e && e.forEach((e) => e.deferred.resolve()),
                        Object.keys(nd).length && od();
                    });
              }, t || 100)),
            !e)
          )
            return R.Pledge();
          if (nd[e]) return nd[e].deferred.promise();
          const n = R(),
            r = { url: e, deferred: n };
          return (nd[e] = r), n.promise();
        },
        ad = (e, t, n, r) => {
          let s, i;
          const o = t || {};
          return (
            od(e.url).then(() => {
              if (i) {
                const e = VA("aborted");
                return (
                  o.onabort && o.onabort(e), void (o.ondone && o.ondone(e))
                );
              }
              ((n = n || {}).internal = r), (s = HA(e, o, n));
            }),
            {
              abort: function () {
                if (s) return s.abort();
                i = !0;
              },
            }
          );
        },
        ld = {
          init: () => {},
          internal: (e, t, n) => ad(e, t, n, !0),
          external: (e, t, n) => ad(e, t, n, !1),
        },
        cd = ld,
        ud = (e) =>
          !(
            !Le.inIncognitoContext &&
            (!e || (!e.incognito && Ne.isDefaultStoreId(e.cookieStoreId)))
          ),
        Ad = ({ frameType: e, frameId: t }) =>
          void 0 !== e ? "outermost_frame" === e : void 0 === t || 0 === t,
        dd = (e, t) => {
          const { frameId: n, documentId: r, frameType: s } = e,
            { topframe: i } = t || {},
            o = void 0 !== n ? n : i ? 0 : void 0;
          if (r || void 0 !== o)
            return {
              frameId: o,
              frameType: s || (i ? "outermost_frame" : void 0),
              documentId: r,
              get id() {
                return r || `${o}`;
              },
            };
        },
        hd = (e, t) => {
          if (
            !e ||
            -1 != e.search(/#bypass=true/) ||
            -1 != e.search(qe.getInternalPageRegexp()) ||
            !["https:", "http:", "file:", "ftp:"].some((t) => e.startsWith(t))
          )
            return !1;
          const n = t ? e : e.split(/[?#$]/)[0],
            r =
              -1 != n.search(/[^/]{1}\.user\.(js#|js\?|js$)/) ||
              -1 != n.search(/[^/]{1}\.tamper\.(js#|js\?|js$)/);
          return r
            ? !(
                -1 != n.search(/^htt[ps]{1,2}:\/\/code\.google\.com/) ||
                (-1 != n.search(/^htt[ps]{1,2}:\/\/(github|gitlab)\.com/) &&
                  !as(n)) ||
                (-1 != n.search(/^htt[ps]{1,2}:\/\/bitbucket\.org/) && !as(n))
              )
            : r;
        },
        pd = (e, t) => {
          const n = R(),
            r = Zn(e);
          if (
            r &&
            ["file:"].concat(Fe.INTERNAL_PAGE_PROTOCOLS).includes(r.protocol)
          )
            dt(
              e,
              (e) => {
                n.resolve(e);
              },
              (e) => {
                n.reject(e);
              }
            );
          else {
            const r = {
              method: "GET",
              retries: Oe.RETRIES,
              timeout: 6e4,
              revalidate: !0,
              headers: null == t ? void 0 : t.headers,
              responseType: "arraybuffer",
              url: e,
            };
            cd.internal(r, {
              onload: (t) => {
                4 != t.readyState ||
                (200 != t.status && 0 != t.status) ||
                t.error
                  ? (w.verbose(
                      "getScriptFromUrl: " + e + " req.status = " + t.status
                    ),
                    n.reject(t.responseText || "request error"))
                  : n.resolve(t.response);
              },
              onerror: (e) => n.reject(e.responseText || "request error"),
              ontimeout: () => n.reject("timeout"),
            });
          }
          return n.promise();
        },
        fd = (e) => {
          const t = R();
          return (
            pd(e, { headers: { Accept: "text/x-userscript, */*" } }).then(
              (e) => {
                ge(e, { encoding: "UTF-8" }).then(
                  (e) => {
                    t.resolve(e);
                  },
                  (e) => {
                    t.reject(e.message || "charset issue");
                  }
                );
              }
            ),
            t.promise()
          );
        },
        md = () => {
          const e = R();
          return (
            $e(null, (t) => {
              t ? e.resolve(t) : e.reject();
            }),
            e.promise()
          );
        },
        gd = (e) =>
          new Promise((t) => {
            try {
              et(e, (e) => {
                const n = qe.lastError;
                return t(e), n;
              });
            } catch (e) {
              t(void 0), w.warn("getTab error", e);
            }
          }),
        vd = (e, t) => {
          let n, r;
          try {
            t || "/" != e.substr(0, 1)
              ? t
                ? ((r = _n(e)), (n = new RegExp(r)))
                : ((r = ((e) => {
                    let t;
                    if ("*" == e) t = "^(https?|file)://.*";
                    else {
                      t = e;
                      const n = mn.exec(t);
                      if (n) {
                        let [, e, r, s] = n;
                        (e = e ? jt(e).replace(/\*/gi, "[^:]*") : ""),
                          (r = r
                            ? jt(s ? r.replace(/\.\*$/, An) : r).replace(
                                /\*+/g,
                                (e, t) =>
                                  1 == e.length &&
                                  (s ||
                                    (!t &&
                                      r.length > 1 &&
                                      (r.match(/\*/g) || []).length > 1 &&
                                      r.replace(/\*\./g, "").length > 0))
                                    ? "[^/]*"
                                    : ".*"
                              )
                            : r || ""),
                          (s = s ? jt(s).replace(/\*/gi, ".*") : ""),
                          (t = "^" + [e, r, s].join("") + "$");
                      } else
                        (t = "^" + jt(t) + "$"),
                          (t = t.replace(/\*/gi, ".*")),
                          (t = t.replace(/(\^|:\/\/)\.\*/, "$1([^?#])*"));
                      t = t.replace(jt(An + "/"), pn + "/");
                    }
                    return t;
                  })(e)),
                  (n = new RegExp(r, "i")))
              : ((r =
                  ("^" == e.substr(1, 1) ? "" : ".*") +
                  e.replace(/^\//g, "").replace(/\/$/g, "") +
                  ("$" == e.substr(-2, 1) ? "" : ".*")),
                (r = r.replace(/(\.\*){1,}/g, ".*")),
                (n = new RegExp(r, "i")));
          } catch (t) {
            return void w.warn("scriptman: invalid regexp ", e);
          }
          return n;
        },
        _d = (e, t) => "" === e.replace(t, ""),
        wd = (e, t) => {
          let n = [],
            r = [];
          const s = (e, t) =>
              e && e.length
                ? e.map((e) => vd(e, t)).filter((e) => void 0 !== e)
                : [],
            { inc: i, match: o, exc: a } = e;
          return (
            (n = s(i).concat(s(o, !0))),
            (r = s(a)),
            {
              rinc: n.length || t ? n : void 0,
              rexc: r.length || t ? r : void 0,
            }
          );
        },
        bd = (e, t, n) => {
          let r = !1;
          if (t.rinc) {
            if (
              (t.rinc.every(
                (t) =>
                  !_d(e, t) ||
                  (w.debug(
                    'scriptman: @include "' +
                      t +
                      '" matched' +
                      (n ? " (" + n + ")" : '"')
                  ),
                  (r = !0),
                  !1)
              ),
              !r)
            )
              return r;
          } else r = !0;
          return (
            t.rexc &&
              t.rexc.every(
                (t) =>
                  !_d(e, t) ||
                  (w.debug(
                    'scriptman: @exclude "' +
                      t +
                      '" matched' +
                      (n ? " (" + n + ")" : '"')
                  ),
                  (r = !1),
                  !1)
              ),
            r
          );
        },
        yd = G({ timeout: 5, check_interval: 10, retimeout_on_get: !0 }),
        kd = G({ timeout: 300, check_interval: 120, retimeout_on_get: !0 }),
        Rd = { ts: 0, data: {} };
      let xd = [];
      const Ed = {
          init: () => {
            Ot.addDifferentOriginChangeListener(Ze.PREFIX.STORE, (e, t) => {
              const n = e.substr(Ze.PREFIX.STORE.length),
                r = t && t.data ? t : void 0;
              if (r)
                for (const [e, t] of Object.entries(r.data))
                  Ed.notifyStorageListeners({ uuid: n }, void 0, (n) => {
                    const s = { data: {}, ts: 0 };
                    (s.data[e] = t), (s.ts = r.ts);
                    const i = s;
                    void 0 === s.data[e] && (i.removed = e), n(i);
                  });
            });
          },
          getUidList: () => {
            const e = [];
            return (
              Ot.listValues().forEach((t) => {
                t.startsWith(Ze.PREFIX.SCRIPT_UID) &&
                  e.push(t.substr(Ze.PREFIX.SCRIPT_UID.length));
              }),
              e
            );
          },
          getUidsByName: (e, t) => {
            const n = [];
            return (
              Ed.getUidList().forEach((r) => {
                const s = Ed.getMetaByUid(r);
                !s || s.name != e || (t && t != s.namespace) || n.push(r);
              }),
              n
            );
          },
          getUidByName: (e) => Ed.getUidsByName(e)[0],
          getStorageByUid: (e) => {
            const t = Ot.getValue(Ze.PREFIX.STORE + e, { ts: 0, data: {} });
            let { ts: n, data: r } = t || Rd;
            return (
              void 0 === n && (n = 0),
              void 0 === r && (r = {}),
              { ts: n, data: r }
            );
          },
          setStorageByUid: (e, t) =>
            t
              ? Ot.setValue(Ze.PREFIX.STORE + e, t)
              : Ot.deleteValue(Ze.PREFIX.STORE + e),
          setStorageByUidAndNotify: (e, t, n, r, s, i) => {
            w.verbose("sb: (" + e + "): set key " + r + ' to "' + s + '"');
            const o = Sd.getStorageByUid(e);
            i ? delete o.data[r] : (o.data[r] = s),
              (o.ts = t = t || Date.now());
            const a = Sd.setStorageByUid(e, o);
            return (
              Sd.notifyStorageListeners({ uuid: e }, { id: n }, (e) => {
                e({ storage: { [r]: s }, ts: t, removed: i ? r : void 0 });
              }),
              a
            );
          },
          getMetaByUid: (e) => Ot.getValue(Ze.PREFIX.META + e, null),
          getByUid: (e, t) => {
            if (!e) return w.error("sb: no UUID set"), {};
            let n,
              r = Ot.getValue(Ze.PREFIX.META + e, null);
            if (r) {
              const { requires: s, resources: i } = r;
              let { sync: o } = r;
              (r.requires = (s || []).map((e) => {
                const { unsafe_url: t, abs_url: n } = e;
                return { unsafe_url: t, abs_url: n };
              })),
                (r.resources = (i || []).map((e) => {
                  const { name: t, unsafe_url: n, abs_url: r } = e;
                  return { name: t, unsafe_url: n, abs_url: r };
                })),
                (r.uuid = e);
              const a = r.grant || [];
              (r.grant = a.includes("none") ? ["none"] : a),
                r.options.override.use_connects ||
                  ((r.connects = r.connects || []),
                  (r.options.override.merge_connects = !0),
                  (r.options.override.use_connects = [])),
                void 0 === r.options.check_for_updates &&
                  (r.options.check_for_updates = !0),
                void 0 === r.options.user_modified &&
                  (r.options.user_modified = null),
                void 0 === r.options.tab_types && (r.options.tab_types = null),
                void 0 === r.options.compat_powerful_this &&
                  (r.options.compat_powerful_this = null),
                t && (r = zt(r, {})),
                o && !o.imported && (o = { imported: 9 });
              const l = r.textContent,
                c = Ot.getValue(Ze.PREFIX.SCRIPT + e, l);
              c && (n = { ...r, sync: o, textContent: c });
            }
            return {
              script: n,
              cond: Ot.getValue(Ze.PREFIX.COND + e, null),
            };
          },
          setByUid: (e, t, n) => {
            if (!e)
              throw (w.error("sb: no UUID set", t), new Error("No UUID set!"));
            if ("string" != typeof t.textContent)
              throw new Error("No script code set!");
            const { name: r, includes: s, matches: i, excludes: o } = t,
              { textContent: a, ...l } = t,
              c = { ...l, uuid: e },
              u = { ...c, textContent: a },
              A = !!Ot.getValue(Ze.PREFIX.META + e),
              d = {};
            (d[Ze.PREFIX.META + e] = c),
              (d[Ze.PREFIX.SCRIPT_UID + e] = r),
              (d[Ze.PREFIX.COND + e] = { inc: s, match: i, exc: o }),
              (d[Ze.PREFIX.SCRIPT + e] = a);
            const h = Ot.setValues(d);
            return (
              A
                ? di.emit("scriptEvent", {
                    type: "changed",
                    name: r,
                    script: u,
                    changed: A,
                    sync: n,
                  })
                : di.emit("scriptEvent", {
                    type: "added",
                    name: r,
                    script: u,
                    sync: n,
                  }),
              yd.removeAll(),
              kd.remove(e),
              h
            );
          },
          restoreByUid: (e, t) => {
            const n = Ed.getByUid(e);
            if (!n.script || !n.cond) return R.Breach("invalid script");
            const {
              script: r,
              script: { name: s },
            } = n;
            delete r.deleted;
            const i = Ed.setByUid(e, r);
            return (
              void 0 === t && (t = !0),
              di.emit("scriptEvent", {
                type: "added",
                name: s,
                script: r,
                sync: t,
              }),
              i
            );
          },
          softRemoveByUid: (e, t) => {
            const n = Ed.getByUid(e);
            if (!n.script || !n.cond) return R.Breach("invalid script");
            const {
              script: r,
              script: { name: s },
            } = n;
            r.deleted = Date.now();
            const i = Ed.setByUid(e, r);
            return (
              yd.removeAll(),
              kd.remove(e),
              void 0 === t && (t = !0),
              di.emit("scriptEvent", {
                type: "removed",
                name: s,
                script: r,
                sync: t,
              }),
              i
            );
          },
          removeByUid: (e) => {
            const t = Ed.getByUid(e);
            if (!t) return R.Breach("not found");
            const n = R.when([
                Ot.deleteValue(Ze.PREFIX.SCRIPT_UID + e),
                Ot.deleteValue(Ze.PREFIX.COND + e),
                Ot.deleteValue(Ze.PREFIX.SCRIPT + e),
                Ot.deleteValue(Ze.PREFIX.META + e),
                Ot.deleteValue(Ze.PREFIX.STORE + e),
              ]).then(() => {}),
              { script: r } = t;
            return un.values && r && mr(r.name, "r"), n;
          },
          addStorageListener: (e, t, n, r, s) => {
            const i = { tabid: e, id: t, uuid: n, time: r, response: s };
            xd.push(i);
          },
          removeStorageListeners: (e, t) => {
            void 0 === t && (t = !0);
            const n = xd;
            (xd = []),
              n.forEach((n) => {
                if (
                  (void 0 !== e.tabid && e.tabid !== n.tabid) ||
                  (void 0 !== e.uuid && e.uuid !== n.uuid) ||
                  (void 0 !== e.id && e.id !== n.id)
                )
                  xd.push(n);
                else {
                  w.verbose("sb: send empty response ", e);
                  try {
                    t && n.response({});
                  } catch (t) {
                    w.debug(
                      "sb: listener clear for script",
                      e,
                      "failed! Page reload?!"
                    );
                  }
                }
              });
          },
          notifyStorageListeners: (e, t, n) => {
            const r = e || {},
              s = t || {};
            xd.forEach((e) => {
              if (
                (void 0 !== s.uuid && e.uuid === s.uuid) ||
                (void 0 !== s.tabid && e.tabid === s.tabid) ||
                (void 0 !== s.id && e.id === s.id) ||
                (void 0 !== r.tabid && r.tabid !== e.tabid) ||
                (void 0 !== r.uuid && r.uuid !== e.uuid) ||
                (void 0 !== r.id && r.id !== e.id)
              );
              else
                try {
                  w.verbose("sb: notify/refresh/remove", r), n(e.response);
                } catch (e) {
                  w.warn(
                    "sb: listener notification for script",
                    r,
                    "failed! Page reload?!"
                  );
                }
            });
          },
        },
        Sd = Ed,
        Cd = Sd,
        Md = (e) =>
          (() => {
            const t = R();
            return (
              "activate" == e
                ? (ot.openPopup && ot.openPopup(), t.resolve())
                : "toggle-enable" == e
                ? ((un.values.enabled = !un.values.enabled), t.resolve())
                : $e(null, (n) => {
                    if (!n) return void t.reject();
                    let r;
                    "open-dashboard" == e
                      ? (r = ze.getURL("options.html") + "#nav=dashboard")
                      : "open-dashboard-with-running-scripts" == e
                      ? (r =
                          ze.getURL("options.html") +
                          "#nav=dashboard&filter=" +
                          z(n.url))
                      : "open-new-script" == e &&
                        (r =
                          ze.getURL("options.html") +
                          "#url=" +
                          he(n.url) +
                          "&nav=new-user-script"),
                      t.resolve(r ? { url: r, active: !0, parent: n } : void 0);
                  }),
              t.promise()
            );
          })().then((e) => {
            e && Ye(e);
          });
      let Id, Gd, Ud;
      (Id = R.Pledge().promise()),
        (Gd = new Date().getTime()),
        (Ud = !0),
        (self.setTimeout = M);
      const Zd = new Date();
      us(),
        (K.down = Ko),
        (K.dast = Ot),
        w.debug("Starting background fred @" + El);
      const Td = () => {
          const e =
            "temporary" == un.values.incognito_mode && ze.inIncognitoContext;
          Ot.setTemporary(e),
            e &&
              ((un.values.sync_enabled = !1),
              (un.values.scriptUpdateCheckPeriod = 0),
              (un.values.sync_type = 0),
              (un.values.statistics_enabled = !1));
        },
        Bd = (K.init = async () => {
          var e;
          Dr.init(),
            k.init(),
            TA(!0),
            Lc.init(),
            jl.init(),
            ft && ((e = Md), Se.commands.onCommand.addListener(e)),
            qe.setUninstallURL(
              `https://www.tampermonkey.net/uninstall.php?ext=${qe.short_id}`
            ),
            ((e) => {
              jr = e;
            })(Ua),
            at({ path: ze.getURL("images/icon_grey.png") }),
            (function (e) {
              if (ot.setPopup) ot.setPopup(e);
            })({ popup: "action.html" }),
            lt({ title: "Tampermonkey" }),
            qe.onUpdateAvailable.addListener(ui.onUpdateAvailable),
            qe.onInstalled.addListener((e) => {
              w.log("bg: onInstalled", e),
                e || (e = { reason: "mandatory_argument_is_not_set" }),
                "install" == e.reason
                  ? Be.SECURE ||
                    Cd.getUidList().forEach((e) => {
                      const t = Cd.getByUid(e);
                      t.script &&
                        t.cond &&
                        t.script.evilness != Wi.SEVERITY_FOISTED_SCRIPT &&
                        (w.warn(
                          "content security: found unfamiliar script",
                          t.script.name
                        ),
                        (t.script.evilness = Wi.SEVERITY_FOISTED_SCRIPT),
                        vu.doModify(e, t.script, !1));
                    })
                  : "update" == e.reason && e.previousVersion,
                k.ensureLate(() => {
                  "install" == e.reason
                    ? ui.onInstalled()
                    : "update" == e.reason && ui.onUpdated(e.previousVersion);
                });
            }),
            tl.init(),
            w.log("bg: listeners registered!");
          const t = await Id.then(() => !0);
          await (async () => {
            const e = await nc.list();
            await Promise.all(
              e.map(({ key: e, value: t }) =>
                gd(+e).then((n) => {
                  n ? (rc[+e] = t) : nc.delete(e);
                })
              )
            );
          })(),
            await Ot.init(),
            await (() => {
              const e = R(),
                t = "0.0.0.0";
              let n, r;
              const s = ze.manifest.version,
                i = Ot.getSchemaVersion();
              let o = i;
              return (
                Ot.getVersion(t)
                  .then(
                    (e) => ((r = e), (n = es(s, r) == es.eNEWER), Ot.isWiped())
                  )
                  .then((e) => {
                    if (!n && e) {
                      const e = [
                        "Tampermonkey detected inconsistencies that indicate that your browser wiped the extension database!",
                        "You can continue to use Tampermonkey normally, but your settings and scripts might be lost. Click here to get more information.",
                        "https://www.tampermonkey.net/faq.php#Q207",
                      ];
                      w.warn(e.join("\n")), ds(...e);
                    }
                  })
                  .always(() => {
                    let a = 0;
                    const l = () => {
                        if (a < u.length) {
                          const t = () => {
                              a++, l();
                            },
                            n = u[a].schema;
                          u[a].cond(n)
                            ? u[a]
                                .fn()
                                .done(() => {
                                  n &&
                                    (w.info(
                                      "Converted database from",
                                      o,
                                      "to",
                                      n
                                    ),
                                    (o = n)),
                                    t();
                                })
                                .fail(() => {
                                  e.reject();
                                })
                            : t();
                        }
                      },
                      c = () => {
                        w.warn(
                          "Incognito mode detected. Database conversion can only be done in non-incognito mode! Stopping now..."
                        ),
                          As(
                            [
                              "Tampermonkey needs to convert its database but this can't be done in incogonito mode!",
                              "Please open a non-incognito mode window and/or restart your browser.",
                            ],
                            "paused"
                          );
                      },
                      u = [
                        {
                          cond: () =>
                            n &&
                            es("3.6.3650", o) == es.eNEWER &&
                            es("3.5.3650", r) == es.eNEWER,
                          fn: () => {
                            const e = R();
                            if (ze.inIncognitoContext) c(), e.reject();
                            else {
                              o = "3.6.3650";
                              const t = [];
                              [
                                {
                                  o: "TM_config",
                                  n: Ze.STORAGE.CONFIG,
                                },
                                { o: "TM_update_check", n: Ze.STORAGE.UPDATE },
                                { o: "TM_version" },
                                { o: "TM_unload_ts" },
                              ].forEach((e) => {
                                if (e.n) {
                                  const n = Ot.getValue(e.o);
                                  void 0 !== n && t.push(Ot.setValue(e.n, n));
                                }
                                t.push(Ot.deleteValue(e.o));
                              });
                              let n = new RegExp("@re$");
                              const s = [];
                              Ot.listValues().forEach((e) => {
                                if (-1 == e.search(n)) return;
                                const t = e.replace(n, "");
                                s.push(t);
                              }),
                                s.forEach((e) => {
                                  const n = Ot.getValue(e + "@st"),
                                    r = Ot.getValue(e),
                                    s = Ot.getValue(e + "@re"),
                                    i = Ot.getValue(e + "@source"),
                                    o = Cd.getUidByName(e) || Xt();
                                  t.push(Ot.deleteValue(e + "@st")),
                                    t.push(Ot.deleteValue(e)),
                                    t.push(Ot.deleteValue(e + "@re")),
                                    t.push(Ot.deleteValue(e + "@source")),
                                    r && s && i
                                      ? (t.push(
                                          Ot.setValue(
                                            Ze.PREFIX.SCRIPT_UID + o,
                                            e
                                          )
                                        ),
                                        t.push(
                                          Ot.setValue(Ze.PREFIX.COND + o, s)
                                        ),
                                        t.push(
                                          Ot.setValue(Ze.PREFIX.STORE + o, n)
                                        ),
                                        t.push(
                                          Ot.setValue(Ze.PREFIX.SCRIPT + o, i)
                                        ),
                                        t.push(
                                          Ot.setValue(Ze.PREFIX.META + o, r)
                                        ))
                                      : w.warn("invalid script entry", {
                                          source: i,
                                          meta: r,
                                          cond: s,
                                        });
                                }),
                                (n = new RegExp("@st$")),
                                Ot.listValues().forEach((e) => {
                                  -1 != e.search(n) &&
                                    t.push(Ot.deleteValue(e));
                                }),
                                R.when(t).done(() => {
                                  w.info("Converted database from", r, "to", o),
                                    e.resolve();
                                });
                            }
                            return e.promise();
                          },
                        },
                        {
                          schema: "3.7.0",
                          cond: (e) => es(e, o) == es.eNEWER,
                          fn: () => {
                            const e = R();
                            if (ze.inIncognitoContext) c(), e.reject();
                            else {
                              const t = [];
                              Ot.listValues().forEach((e) => {
                                if (!e.startsWith(Ze.PREFIX.META)) return;
                                const n = Ot.getValue(e);
                                if (
                                  n &&
                                  n.options &&
                                  n.options.override &&
                                  !n.options.override.orig_run_at
                                ) {
                                  (n.options.override.orig_run_at =
                                    n.options.run_at || "document-idle"),
                                    (n.options.run_at = null);
                                  const r = { ...n };
                                  t.push(Ot.setValue(e, r));
                                }
                              }),
                                R.when(t).done(() => {
                                  e.resolve();
                                });
                            }
                            return e.promise();
                          },
                        },
                        {
                          schema: "4526",
                          cond: () => n && !1,
                          fn: () => {
                            const e = R();
                            if (ze.inIncognitoContext) c(), e.reject();
                            else {
                              w.info("Update database...");
                              const t = Ot.migrate(
                                "localStorage",
                                "chromeStorage"
                              )
                                .done(() => {
                                  w.info(
                                    "Copied config for default usage of setting storage"
                                  );
                                })
                                .fail(() => {
                                  e.resolve();
                                });
                              e.consume(t);
                            }
                            return e.promise();
                          },
                        },
                        {
                          schema: "4871",
                          cond: (e) => n && es(e, o) == es.eNEWER,
                          fn: () => {
                            const e = R();
                            let t, n;
                            const r = Ot.getValue(Ze.STORAGE.CONFIG);
                            return (
                              r &&
                                r.scriptTemplate &&
                                (n = un.getDefaults()) &&
                                (t = n.script_templates) &&
                                t[0] &&
                                t[0].value &&
                                ((t[0].value = r.scriptTemplate),
                                delete r.scriptTemplate,
                                Ot.setValue(Ze.STORAGE.CONFIG, r)),
                              e.resolve(),
                              e.promise()
                            );
                          },
                        },
                        {
                          schema: "5465",
                          cond: (e) => es(e, o) == es.eNEWER,
                          fn: () => {
                            const e = R();
                            if (ze.inIncognitoContext) c(), e.reject();
                            else {
                              const t = Ot.getValue(Ze.STORAGE.CONFIG);
                              t &&
                                1 == t.sync_version &&
                                ((t.sync_enabled = !1),
                                Ot.setValue(Ze.STORAGE.CONFIG, t)),
                                e.resolve();
                            }
                            return e.promise();
                          },
                        },
                        {
                          cond: () => n || es(o, i) == es.eNEWER,
                          fn: () => {
                            const e = R();
                            return (
                              Ot.setVersion(s, o).done(() => {
                                e.resolve();
                              }),
                              e.promise()
                            );
                          },
                        },
                        {
                          cond: () => n,
                          fn: () => (
                            w.info("First run of version " + s + "!"),
                            ui.scheduleNotification(r, r == t),
                            R.Pledge()
                          ),
                        },
                        {
                          cond: () => !0,
                          fn: () => {
                            const t = R();
                            return e.resolve(), X(t.resolve, 0), t.promise();
                          },
                        },
                      ];
                    l();
                  }),
                e.promise()
              );
            })(),
            await R.Pledge(),
            await un.init(),
            await R.when(
              (
                await un.defaultScripts()
              ).map(async (e) => {
                await S(1e3),
                  vu.doSave({
                    url: void 0,
                    src: e.textContent,
                    ask: !1,
                    replace: !0,
                    internal: !0,
                  });
              })
            ),
            (K.cfgo = un),
            Td(),
            ((e) => {
              if (
                (w.set(un.values.logLevel),
                Dr.setLocale(un.values.i18n),
                un.values.userscript_search_url)
              ) {
                const e = () => {
                  (({ url: e, mode: t }) => {
                    (ko = cd.internal),
                      "string" == typeof e
                        ? (_o = wo = e)
                        : ((_o = ((e) => {
                            const t = e.api || e.www;
                            return `${e.protocol}//${t ? t + "." : ""}${
                              e.domain
                            }`;
                          })(e)),
                          (wo = ((e) => {
                            const t = e.www;
                            return `${e.protocol}//${t ? t + "." : ""}${
                              e.domain
                            }`;
                          })(e))),
                      (yo = t),
                      (bo = Dr.getLocale() || Dr.getUiLocale());
                  })({
                    url: [
                      "dhdg",
                      "gcal",
                      "fire",
                      "iikm",
                      "mfdh",
                      "fcmf",
                    ].includes(qe.short_id)
                      ? Kt
                      : un.values.userscript_search_url,
                    mode: un.values.userscript_search_mode,
                  });
                };
                un.addChangeListener("userscript_search_mode", e), e();
              }
              var t, n;
              (t = vu.doModify),
                (n = Cd.getByUid),
                (tu = t),
                (nu = n),
                ((e) => {
                  FA = e;
                })({
                  prefix:
                    Te.WEBREQUEST_XHR_SUPPORT &&
                    "no" != un.values.webrequest_modHeaders
                      ? _A
                      : void 0,
                  mozAnon: !1,
                }),
                cd.init(),
                ((e, t) => {
                  const n = `${(null == t ? void 0 : t.version) || ""} `,
                    r = qe.short_id;
                  (sr = (rr[r] || rr[Pn])()),
                    F("error", (e) => {
                      const {
                        message: t,
                        filename: r,
                        lineno: s,
                        colno: i,
                        error: o,
                      } = e;
                      ((e, t, r, s, i) => {
                        let o = "";
                        if (i)
                          try {
                            o = i.stack || "";
                          } catch (e) {}
                        vr(
                          e.toString(),
                          n + "bg@" + ze.urls.prepareForReport(t || ""),
                          [r + ":" + s, o].join(";")
                        );
                      })(t, r, s, i, o);
                    });
                  const s = (e) => {
                    let t = "";
                    try {
                      t = e.stack;
                    } catch (e) {}
                    vr(
                      "CSP violation of " + e.effectiveDirective,
                      n + "bg@" + ze.urls.prepareForReport(e.documentURI),
                      [
                        e.sourceFile,
                        " -> ",
                        e.lineNumber + ":" + e.columnNumber,
                        t,
                      ].join(";")
                    );
                  };
                  oe
                    ? oe.addEventListener("securitypolicyviolation", (e) =>
                        s(e)
                      )
                    : F("securitypolicyviolation", (e) => s(e)),
                    (null == t ? void 0 : t.started) &&
                      (Jn = Date.now() - t.started.getTime()),
                    (Yn = !!(null == t ? void 0 : t.trackView));
                })(0, {
                  trackView: e,
                  version: ze.manifest.version,
                  started: Zd,
                }),
                k.ensureLate(() => {
                  const e = un.values.statistics_enabled;
                  null === e
                    ? $s.all("stats", {
                        key: "stats",
                        class: "information",
                        title: Dr.getMessage("Anonymous_statistics"),
                        text: Dr.getMessage(
                          "Please_enable_anonymous_statistics_and_help_to_improve_this_extension_"
                        ),
                        info_url: "https://www.tampermonkey.net/privacy.php",
                        timeout: 864e5,
                        buttons: [
                          { text: Dr.getMessage("Enable"), id: "enable_stats" },
                          { text: Dr.getMessage("No"), id: "disable_stats" },
                        ],
                      })
                    : pr(!!e);
                }),
                hi.on("reset", ({ tabId: e, early: t }) => {
                  Ia.clearByTabId(e),
                    Cd.removeStorageListeners({ tabid: e }, !1),
                    t || Ec.setIcon(e);
                });
              const r = (e) => {
                e >= 0 &&
                  et(e, (t) => {
                    !qe.lastError && t && (Ec.setIcon(e), Ec.setBadge(e));
                  });
              };
              hi.on("commited", ({ tabId: e }) => r(e)),
                hi.on("complete", ({ tabId: e }) => r(e)),
                hi.on("reset", ({ tabId: e }) => uu.purgeAppeals(e)),
                hi.on("remove", ({ tabId: e }) => {
                  uu.purgeAppeals(e),
                    ((e) => {
                      delete il[e];
                    })(e);
                }),
                Ea.init(),
                eu.init(),
                Wi.init(),
                Cd.init(),
                Ko.init(),
                ji.init(),
                TA(),
                dl.init(),
                sl.init();
            })(!0 === t),
            un.addChangeListener("logLevel", () => {
              w.set(un.values.logLevel);
            }),
            un.addChangeListener("i18n", () => {
              Dr.setLocale(un.values.i18n);
            }),
            un.addChangeListener("incognito_mode", () => {
              Td();
            }),
            un.addChangeListener("statistics_enabled", () => {
              pr(!!un.values.statistics_enabled);
            }),
            un.addChangeListener("context_menu_enabled", () => {
              un.values.context_menu_enabled ||
                tl.update({ contexters: [], commands: [] });
            }),
            un.addChangeListener(
              [
                "require_blacklist",
                "script_blacklist_server",
                "script_blacklist_type",
              ],
              vu.blackCheckAll
            ),
            un.addChangeListener("webrequest_modHeaders", (e, t, n, r) => {
              null == r || r.done(() => X(ia.reset, 1));
            }),
            un.addChangeListener(
              ["appearance_badge_color", "appearance_badge_text_color"],
              Ec.init
            ),
            un.addChangeListener("script_include_mode", () => kd.removeAll()),
            Ec.init(),
            await (async () => {
              ct.supported &&
                ((zl = ct),
                await ql(),
                un.addChangeListener("runtime_inject_mode", ql));
            })(),
            vu.clean(),
            await R.Pledge(),
            await (async () => {
              const {
                  brands: e,
                  mobile: t,
                  platform: n,
                } = navigator && navigator.userAgentData
                  ? navigator.userAgentData
                  : { brands: void 0, mobile: void 0, platform: void 0 },
                { arch: r, os: s } = await new Promise((e) =>
                  Pe.getPlatformInfo((t) => e(t || {}))
                ),
                { name: i, version: o } = await new Promise((e) =>
                  Pe.getBrowserInfo((t) => e(t || {}))
                );
              return (
                (ra = {
                  brands: e || [{ brand: i || "", version: o || "" }],
                  mobile: void 0 === t ? Ue() : t,
                  platform:
                    (s
                      ? {
                          mac: "macOS",
                          win: "Windows",
                          android: "Android",
                          cros: "Chrome OS",
                          linux: "Linux",
                          openbsd: "Open/FreeBSD",
                          fuchsia: "Fuchsia",
                        }[s]
                      : void 0) || n,
                  ...(r
                    ? {
                        arm64: { bitness: "64", architecture: "arm" },
                        mips64: { bitness: "64", architecture: "mips" },
                        "x86-32": { bitness: "32", architecture: "x86" },
                        "x86-64": { bitness: "64", architecture: "x86" },
                      }[r]
                    : { architecture: r }),
                }),
                ra
              );
            })(),
            w.log(`bg: ready! [sessionStart=${t}]`),
            k.setReady();
        });
      Bd();
    })();
})();
